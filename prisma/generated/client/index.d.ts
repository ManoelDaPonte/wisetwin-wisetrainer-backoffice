
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model UserCourse
 * 
 */
export type UserCourse = $Result.DefaultSelection<Prisma.$UserCoursePayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Scenario
 * 
 */
export type Scenario = $Result.DefaultSelection<Prisma.$ScenarioPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Option
 * 
 */
export type Option = $Result.DefaultSelection<Prisma.$OptionPayload>
/**
 * Model UserModule
 * 
 */
export type UserModule = $Result.DefaultSelection<Prisma.$UserModulePayload>
/**
 * Model UserResponse
 * 
 */
export type UserResponse = $Result.DefaultSelection<Prisma.$UserResponsePayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model OrganizationTraining
 * 
 */
export type OrganizationTraining = $Result.DefaultSelection<Prisma.$OrganizationTrainingPayload>
/**
 * Model OrganizationInvitation
 * 
 */
export type OrganizationInvitation = $Result.DefaultSelection<Prisma.$OrganizationInvitationPayload>
/**
 * Model OrganizationTag
 * 
 */
export type OrganizationTag = $Result.DefaultSelection<Prisma.$OrganizationTagPayload>
/**
 * Model UserTag
 * 
 */
export type UserTag = $Result.DefaultSelection<Prisma.$UserTagPayload>
/**
 * Model TagTraining
 * 
 */
export type TagTraining = $Result.DefaultSelection<Prisma.$TagTrainingPayload>
/**
 * Model FormationContent
 * 
 */
export type FormationContent = $Result.DefaultSelection<Prisma.$FormationContentPayload>
/**
 * Model FormationStep
 * 
 */
export type FormationStep = $Result.DefaultSelection<Prisma.$FormationStepPayload>
/**
 * Model FormationQuestion
 * 
 */
export type FormationQuestion = $Result.DefaultSelection<Prisma.$FormationQuestionPayload>
/**
 * Model FormationOption
 * 
 */
export type FormationOption = $Result.DefaultSelection<Prisma.$FormationOptionPayload>
/**
 * Model Formation
 * 
 */
export type Formation = $Result.DefaultSelection<Prisma.$FormationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCourse`: Exposes CRUD operations for the **UserCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCourses
    * const userCourses = await prisma.userCourse.findMany()
    * ```
    */
  get userCourse(): Prisma.UserCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scenario`: Exposes CRUD operations for the **Scenario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scenarios
    * const scenarios = await prisma.scenario.findMany()
    * ```
    */
  get scenario(): Prisma.ScenarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userModule`: Exposes CRUD operations for the **UserModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserModules
    * const userModules = await prisma.userModule.findMany()
    * ```
    */
  get userModule(): Prisma.UserModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userResponse`: Exposes CRUD operations for the **UserResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserResponses
    * const userResponses = await prisma.userResponse.findMany()
    * ```
    */
  get userResponse(): Prisma.UserResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationTraining`: Exposes CRUD operations for the **OrganizationTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationTrainings
    * const organizationTrainings = await prisma.organizationTraining.findMany()
    * ```
    */
  get organizationTraining(): Prisma.OrganizationTrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationInvitation`: Exposes CRUD operations for the **OrganizationInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationInvitations
    * const organizationInvitations = await prisma.organizationInvitation.findMany()
    * ```
    */
  get organizationInvitation(): Prisma.OrganizationInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationTag`: Exposes CRUD operations for the **OrganizationTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationTags
    * const organizationTags = await prisma.organizationTag.findMany()
    * ```
    */
  get organizationTag(): Prisma.OrganizationTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTag`: Exposes CRUD operations for the **UserTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTags
    * const userTags = await prisma.userTag.findMany()
    * ```
    */
  get userTag(): Prisma.UserTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagTraining`: Exposes CRUD operations for the **TagTraining** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagTrainings
    * const tagTrainings = await prisma.tagTraining.findMany()
    * ```
    */
  get tagTraining(): Prisma.TagTrainingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formationContent`: Exposes CRUD operations for the **FormationContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormationContents
    * const formationContents = await prisma.formationContent.findMany()
    * ```
    */
  get formationContent(): Prisma.FormationContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formationStep`: Exposes CRUD operations for the **FormationStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormationSteps
    * const formationSteps = await prisma.formationStep.findMany()
    * ```
    */
  get formationStep(): Prisma.FormationStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formationQuestion`: Exposes CRUD operations for the **FormationQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormationQuestions
    * const formationQuestions = await prisma.formationQuestion.findMany()
    * ```
    */
  get formationQuestion(): Prisma.FormationQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formationOption`: Exposes CRUD operations for the **FormationOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormationOptions
    * const formationOptions = await prisma.formationOption.findMany()
    * ```
    */
  get formationOption(): Prisma.FormationOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formation`: Exposes CRUD operations for the **Formation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formations
    * const formations = await prisma.formation.findMany()
    * ```
    */
  get formation(): Prisma.FormationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Course: 'Course',
    UserCourse: 'UserCourse',
    Module: 'Module',
    Scenario: 'Scenario',
    Question: 'Question',
    Option: 'Option',
    UserModule: 'UserModule',
    UserResponse: 'UserResponse',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    UserStats: 'UserStats',
    UserSession: 'UserSession',
    Organization: 'Organization',
    OrganizationMember: 'OrganizationMember',
    OrganizationTraining: 'OrganizationTraining',
    OrganizationInvitation: 'OrganizationInvitation',
    OrganizationTag: 'OrganizationTag',
    UserTag: 'UserTag',
    TagTraining: 'TagTraining',
    FormationContent: 'FormationContent',
    FormationStep: 'FormationStep',
    FormationQuestion: 'FormationQuestion',
    FormationOption: 'FormationOption',
    Formation: 'Formation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "course" | "userCourse" | "module" | "scenario" | "question" | "option" | "userModule" | "userResponse" | "achievement" | "userAchievement" | "userStats" | "userSession" | "organization" | "organizationMember" | "organizationTraining" | "organizationInvitation" | "organizationTag" | "userTag" | "tagTraining" | "formationContent" | "formationStep" | "formationQuestion" | "formationOption" | "formation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      UserCourse: {
        payload: Prisma.$UserCoursePayload<ExtArgs>
        fields: Prisma.UserCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          findFirst: {
            args: Prisma.UserCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          findMany: {
            args: Prisma.UserCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>[]
          }
          create: {
            args: Prisma.UserCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          createMany: {
            args: Prisma.UserCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>[]
          }
          delete: {
            args: Prisma.UserCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          update: {
            args: Prisma.UserCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          deleteMany: {
            args: Prisma.UserCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>[]
          }
          upsert: {
            args: Prisma.UserCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCoursePayload>
          }
          aggregate: {
            args: Prisma.UserCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCourse>
          }
          groupBy: {
            args: Prisma.UserCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCourseCountArgs<ExtArgs>
            result: $Utils.Optional<UserCourseCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Scenario: {
        payload: Prisma.$ScenarioPayload<ExtArgs>
        fields: Prisma.ScenarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScenarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScenarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findFirst: {
            args: Prisma.ScenarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScenarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          findMany: {
            args: Prisma.ScenarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          create: {
            args: Prisma.ScenarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          createMany: {
            args: Prisma.ScenarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScenarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          delete: {
            args: Prisma.ScenarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          update: {
            args: Prisma.ScenarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          deleteMany: {
            args: Prisma.ScenarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScenarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScenarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>[]
          }
          upsert: {
            args: Prisma.ScenarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScenarioPayload>
          }
          aggregate: {
            args: Prisma.ScenarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScenario>
          }
          groupBy: {
            args: Prisma.ScenarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScenarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScenarioCountArgs<ExtArgs>
            result: $Utils.Optional<ScenarioCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Option: {
        payload: Prisma.$OptionPayload<ExtArgs>
        fields: Prisma.OptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findFirst: {
            args: Prisma.OptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findMany: {
            args: Prisma.OptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          create: {
            args: Prisma.OptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          createMany: {
            args: Prisma.OptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          delete: {
            args: Prisma.OptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          update: {
            args: Prisma.OptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          deleteMany: {
            args: Prisma.OptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          upsert: {
            args: Prisma.OptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.OptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      UserModule: {
        payload: Prisma.$UserModulePayload<ExtArgs>
        fields: Prisma.UserModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          findFirst: {
            args: Prisma.UserModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          findMany: {
            args: Prisma.UserModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>[]
          }
          create: {
            args: Prisma.UserModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          createMany: {
            args: Prisma.UserModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>[]
          }
          delete: {
            args: Prisma.UserModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          update: {
            args: Prisma.UserModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          deleteMany: {
            args: Prisma.UserModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>[]
          }
          upsert: {
            args: Prisma.UserModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserModulePayload>
          }
          aggregate: {
            args: Prisma.UserModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserModule>
          }
          groupBy: {
            args: Prisma.UserModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserModuleCountArgs<ExtArgs>
            result: $Utils.Optional<UserModuleCountAggregateOutputType> | number
          }
        }
      }
      UserResponse: {
        payload: Prisma.$UserResponsePayload<ExtArgs>
        fields: Prisma.UserResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          findFirst: {
            args: Prisma.UserResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          findMany: {
            args: Prisma.UserResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>[]
          }
          create: {
            args: Prisma.UserResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          createMany: {
            args: Prisma.UserResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>[]
          }
          delete: {
            args: Prisma.UserResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          update: {
            args: Prisma.UserResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          deleteMany: {
            args: Prisma.UserResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>[]
          }
          upsert: {
            args: Prisma.UserResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserResponsePayload>
          }
          aggregate: {
            args: Prisma.UserResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserResponse>
          }
          groupBy: {
            args: Prisma.UserResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserResponseCountArgs<ExtArgs>
            result: $Utils.Optional<UserResponseCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      OrganizationTraining: {
        payload: Prisma.$OrganizationTrainingPayload<ExtArgs>
        fields: Prisma.OrganizationTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          findFirst: {
            args: Prisma.OrganizationTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          findMany: {
            args: Prisma.OrganizationTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>[]
          }
          create: {
            args: Prisma.OrganizationTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          createMany: {
            args: Prisma.OrganizationTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>[]
          }
          delete: {
            args: Prisma.OrganizationTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          update: {
            args: Prisma.OrganizationTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationTrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTrainingPayload>
          }
          aggregate: {
            args: Prisma.OrganizationTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationTraining>
          }
          groupBy: {
            args: Prisma.OrganizationTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationTrainingCountAggregateOutputType> | number
          }
        }
      }
      OrganizationInvitation: {
        payload: Prisma.$OrganizationInvitationPayload<ExtArgs>
        fields: Prisma.OrganizationInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          findMany: {
            args: Prisma.OrganizationInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          create: {
            args: Prisma.OrganizationInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          createMany: {
            args: Prisma.OrganizationInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          update: {
            args: Prisma.OrganizationInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationInvitationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationInvitation>
          }
          groupBy: {
            args: Prisma.OrganizationInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationInvitationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationTag: {
        payload: Prisma.$OrganizationTagPayload<ExtArgs>
        fields: Prisma.OrganizationTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          findFirst: {
            args: Prisma.OrganizationTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          findMany: {
            args: Prisma.OrganizationTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>[]
          }
          create: {
            args: Prisma.OrganizationTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          createMany: {
            args: Prisma.OrganizationTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>[]
          }
          delete: {
            args: Prisma.OrganizationTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          update: {
            args: Prisma.OrganizationTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationTagPayload>
          }
          aggregate: {
            args: Prisma.OrganizationTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationTag>
          }
          groupBy: {
            args: Prisma.OrganizationTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationTagCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationTagCountAggregateOutputType> | number
          }
        }
      }
      UserTag: {
        payload: Prisma.$UserTagPayload<ExtArgs>
        fields: Prisma.UserTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findFirst: {
            args: Prisma.UserTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          findMany: {
            args: Prisma.UserTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          create: {
            args: Prisma.UserTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          createMany: {
            args: Prisma.UserTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          delete: {
            args: Prisma.UserTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          update: {
            args: Prisma.UserTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          deleteMany: {
            args: Prisma.UserTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>[]
          }
          upsert: {
            args: Prisma.UserTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTagPayload>
          }
          aggregate: {
            args: Prisma.UserTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTag>
          }
          groupBy: {
            args: Prisma.UserTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTagCountArgs<ExtArgs>
            result: $Utils.Optional<UserTagCountAggregateOutputType> | number
          }
        }
      }
      TagTraining: {
        payload: Prisma.$TagTrainingPayload<ExtArgs>
        fields: Prisma.TagTrainingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagTrainingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagTrainingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          findFirst: {
            args: Prisma.TagTrainingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagTrainingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          findMany: {
            args: Prisma.TagTrainingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>[]
          }
          create: {
            args: Prisma.TagTrainingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          createMany: {
            args: Prisma.TagTrainingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagTrainingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>[]
          }
          delete: {
            args: Prisma.TagTrainingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          update: {
            args: Prisma.TagTrainingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          deleteMany: {
            args: Prisma.TagTrainingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagTrainingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagTrainingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>[]
          }
          upsert: {
            args: Prisma.TagTrainingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagTrainingPayload>
          }
          aggregate: {
            args: Prisma.TagTrainingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagTraining>
          }
          groupBy: {
            args: Prisma.TagTrainingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagTrainingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagTrainingCountArgs<ExtArgs>
            result: $Utils.Optional<TagTrainingCountAggregateOutputType> | number
          }
        }
      }
      FormationContent: {
        payload: Prisma.$FormationContentPayload<ExtArgs>
        fields: Prisma.FormationContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormationContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormationContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          findFirst: {
            args: Prisma.FormationContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormationContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          findMany: {
            args: Prisma.FormationContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>[]
          }
          create: {
            args: Prisma.FormationContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          createMany: {
            args: Prisma.FormationContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormationContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>[]
          }
          delete: {
            args: Prisma.FormationContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          update: {
            args: Prisma.FormationContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          deleteMany: {
            args: Prisma.FormationContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormationContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormationContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>[]
          }
          upsert: {
            args: Prisma.FormationContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationContentPayload>
          }
          aggregate: {
            args: Prisma.FormationContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormationContent>
          }
          groupBy: {
            args: Prisma.FormationContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormationContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormationContentCountArgs<ExtArgs>
            result: $Utils.Optional<FormationContentCountAggregateOutputType> | number
          }
        }
      }
      FormationStep: {
        payload: Prisma.$FormationStepPayload<ExtArgs>
        fields: Prisma.FormationStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormationStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormationStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          findFirst: {
            args: Prisma.FormationStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormationStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          findMany: {
            args: Prisma.FormationStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>[]
          }
          create: {
            args: Prisma.FormationStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          createMany: {
            args: Prisma.FormationStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormationStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>[]
          }
          delete: {
            args: Prisma.FormationStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          update: {
            args: Prisma.FormationStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          deleteMany: {
            args: Prisma.FormationStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormationStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormationStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>[]
          }
          upsert: {
            args: Prisma.FormationStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationStepPayload>
          }
          aggregate: {
            args: Prisma.FormationStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormationStep>
          }
          groupBy: {
            args: Prisma.FormationStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormationStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormationStepCountArgs<ExtArgs>
            result: $Utils.Optional<FormationStepCountAggregateOutputType> | number
          }
        }
      }
      FormationQuestion: {
        payload: Prisma.$FormationQuestionPayload<ExtArgs>
        fields: Prisma.FormationQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormationQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormationQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          findFirst: {
            args: Prisma.FormationQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormationQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          findMany: {
            args: Prisma.FormationQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>[]
          }
          create: {
            args: Prisma.FormationQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          createMany: {
            args: Prisma.FormationQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormationQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>[]
          }
          delete: {
            args: Prisma.FormationQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          update: {
            args: Prisma.FormationQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          deleteMany: {
            args: Prisma.FormationQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormationQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormationQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>[]
          }
          upsert: {
            args: Prisma.FormationQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationQuestionPayload>
          }
          aggregate: {
            args: Prisma.FormationQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormationQuestion>
          }
          groupBy: {
            args: Prisma.FormationQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormationQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormationQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<FormationQuestionCountAggregateOutputType> | number
          }
        }
      }
      FormationOption: {
        payload: Prisma.$FormationOptionPayload<ExtArgs>
        fields: Prisma.FormationOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormationOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormationOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          findFirst: {
            args: Prisma.FormationOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormationOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          findMany: {
            args: Prisma.FormationOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>[]
          }
          create: {
            args: Prisma.FormationOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          createMany: {
            args: Prisma.FormationOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormationOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>[]
          }
          delete: {
            args: Prisma.FormationOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          update: {
            args: Prisma.FormationOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          deleteMany: {
            args: Prisma.FormationOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormationOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormationOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>[]
          }
          upsert: {
            args: Prisma.FormationOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationOptionPayload>
          }
          aggregate: {
            args: Prisma.FormationOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormationOption>
          }
          groupBy: {
            args: Prisma.FormationOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormationOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormationOptionCountArgs<ExtArgs>
            result: $Utils.Optional<FormationOptionCountAggregateOutputType> | number
          }
        }
      }
      Formation: {
        payload: Prisma.$FormationPayload<ExtArgs>
        fields: Prisma.FormationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          findFirst: {
            args: Prisma.FormationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          findMany: {
            args: Prisma.FormationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>[]
          }
          create: {
            args: Prisma.FormationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          createMany: {
            args: Prisma.FormationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>[]
          }
          delete: {
            args: Prisma.FormationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          update: {
            args: Prisma.FormationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          deleteMany: {
            args: Prisma.FormationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>[]
          }
          upsert: {
            args: Prisma.FormationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormationPayload>
          }
          aggregate: {
            args: Prisma.FormationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormation>
          }
          groupBy: {
            args: Prisma.FormationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormationCountArgs<ExtArgs>
            result: $Utils.Optional<FormationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    course?: CourseOmit
    userCourse?: UserCourseOmit
    module?: ModuleOmit
    scenario?: ScenarioOmit
    question?: QuestionOmit
    option?: OptionOmit
    userModule?: UserModuleOmit
    userResponse?: UserResponseOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    userStats?: UserStatsOmit
    userSession?: UserSessionOmit
    organization?: OrganizationOmit
    organizationMember?: OrganizationMemberOmit
    organizationTraining?: OrganizationTrainingOmit
    organizationInvitation?: OrganizationInvitationOmit
    organizationTag?: OrganizationTagOmit
    userTag?: UserTagOmit
    tagTraining?: TagTrainingOmit
    formationContent?: FormationContentOmit
    formationStep?: FormationStepOmit
    formationQuestion?: FormationQuestionOmit
    formationOption?: FormationOptionOmit
    formation?: FormationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userCourses: number
    userResponses: number
    userAchievements: number
    UserSession: number
    organizations: number
    tags: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCourses?: boolean | UserCountOutputTypeCountUserCoursesArgs
    userResponses?: boolean | UserCountOutputTypeCountUserResponsesArgs
    userAchievements?: boolean | UserCountOutputTypeCountUserAchievementsArgs
    UserSession?: boolean | UserCountOutputTypeCountUserSessionArgs
    organizations?: boolean | UserCountOutputTypeCountOrganizationsArgs
    tags?: boolean | UserCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    modules: number
    userCourses: number
    userSessions: number
    OrganizationTraining: number
    TagTraining: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | CourseCountOutputTypeCountModulesArgs
    userCourses?: boolean | CourseCountOutputTypeCountUserCoursesArgs
    userSessions?: boolean | CourseCountOutputTypeCountUserSessionsArgs
    OrganizationTraining?: boolean | CourseCountOutputTypeCountOrganizationTrainingArgs
    TagTraining?: boolean | CourseCountOutputTypeCountTagTrainingArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountUserCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOrganizationTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationTrainingWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountTagTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagTrainingWhereInput
  }


  /**
   * Count Type UserCourseCountOutputType
   */

  export type UserCourseCountOutputType = {
    userModules: number
  }

  export type UserCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userModules?: boolean | UserCourseCountOutputTypeCountUserModulesArgs
  }

  // Custom InputTypes
  /**
   * UserCourseCountOutputType without action
   */
  export type UserCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourseCountOutputType
     */
    select?: UserCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCourseCountOutputType without action
   */
  export type UserCourseCountOutputTypeCountUserModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserModuleWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    scenarios: number
    userModules: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenarios?: boolean | ModuleCountOutputTypeCountScenariosArgs
    userModules?: boolean | ModuleCountOutputTypeCountUserModulesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountScenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountUserModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserModuleWhereInput
  }


  /**
   * Count Type ScenarioCountOutputType
   */

  export type ScenarioCountOutputType = {
    questions: number
    userResponses: number
  }

  export type ScenarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ScenarioCountOutputTypeCountQuestionsArgs
    userResponses?: boolean | ScenarioCountOutputTypeCountUserResponsesArgs
  }

  // Custom InputTypes
  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScenarioCountOutputType
     */
    select?: ScenarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * ScenarioCountOutputType without action
   */
  export type ScenarioCountOutputTypeCountUserResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserResponseWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    options: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | QuestionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    trainings: number
    invitations: number
    tags: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    trainings?: boolean | OrganizationCountOutputTypeCountTrainingsArgs
    invitations?: boolean | OrganizationCountOutputTypeCountInvitationsArgs
    tags?: boolean | OrganizationCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationTrainingWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationInvitationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationTagWhereInput
  }


  /**
   * Count Type OrganizationTagCountOutputType
   */

  export type OrganizationTagCountOutputType = {
    users: number
    trainings: number
  }

  export type OrganizationTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationTagCountOutputTypeCountUsersArgs
    trainings?: boolean | OrganizationTagCountOutputTypeCountTrainingsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationTagCountOutputType without action
   */
  export type OrganizationTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTagCountOutputType
     */
    select?: OrganizationTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationTagCountOutputType without action
   */
  export type OrganizationTagCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
  }

  /**
   * OrganizationTagCountOutputType without action
   */
  export type OrganizationTagCountOutputTypeCountTrainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagTrainingWhereInput
  }


  /**
   * Count Type FormationContentCountOutputType
   */

  export type FormationContentCountOutputType = {
    steps: number
    questions: number
  }

  export type FormationContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | FormationContentCountOutputTypeCountStepsArgs
    questions?: boolean | FormationContentCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * FormationContentCountOutputType without action
   */
  export type FormationContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContentCountOutputType
     */
    select?: FormationContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormationContentCountOutputType without action
   */
  export type FormationContentCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationStepWhereInput
  }

  /**
   * FormationContentCountOutputType without action
   */
  export type FormationContentCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationQuestionWhereInput
  }


  /**
   * Count Type FormationQuestionCountOutputType
   */

  export type FormationQuestionCountOutputType = {
    options: number
  }

  export type FormationQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | FormationQuestionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * FormationQuestionCountOutputType without action
   */
  export type FormationQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestionCountOutputType
     */
    select?: FormationQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormationQuestionCountOutputType without action
   */
  export type FormationQuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationOptionWhereInput
  }


  /**
   * Count Type FormationCountOutputType
   */

  export type FormationCountOutputType = {
    contents: number
  }

  export type FormationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contents?: boolean | FormationCountOutputTypeCountContentsArgs
  }

  // Custom InputTypes
  /**
   * FormationCountOutputType without action
   */
  export type FormationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationCountOutputType
     */
    select?: FormationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormationCountOutputType without action
   */
  export type FormationCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationContentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    azureContainer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    azureContainer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    auth0Id: number
    email: number
    name: number
    azureContainer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    azureContainer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    azureContainer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    azureContainer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    auth0Id: string
    email: string
    name: string | null
    azureContainer: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    azureContainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userCourses?: boolean | User$userCoursesArgs<ExtArgs>
    userResponses?: boolean | User$userResponsesArgs<ExtArgs>
    userAchievements?: boolean | User$userAchievementsArgs<ExtArgs>
    userStats?: boolean | User$userStatsArgs<ExtArgs>
    UserSession?: boolean | User$UserSessionArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    azureContainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    azureContainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    azureContainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auth0Id" | "email" | "name" | "azureContainer" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCourses?: boolean | User$userCoursesArgs<ExtArgs>
    userResponses?: boolean | User$userResponsesArgs<ExtArgs>
    userAchievements?: boolean | User$userAchievementsArgs<ExtArgs>
    userStats?: boolean | User$userStatsArgs<ExtArgs>
    UserSession?: boolean | User$UserSessionArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    tags?: boolean | User$tagsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userCourses: Prisma.$UserCoursePayload<ExtArgs>[]
      userResponses: Prisma.$UserResponsePayload<ExtArgs>[]
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      userStats: Prisma.$UserStatsPayload<ExtArgs> | null
      UserSession: Prisma.$UserSessionPayload<ExtArgs>[]
      organizations: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      tags: Prisma.$UserTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auth0Id: string
      email: string
      name: string | null
      azureContainer: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCourses<T extends User$userCoursesArgs<ExtArgs> = {}>(args?: Subset<T, User$userCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userResponses<T extends User$userResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$userResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userAchievements<T extends User$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userStats<T extends User$userStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$userStatsArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    UserSession<T extends User$UserSessionArgs<ExtArgs> = {}>(args?: Subset<T, User$UserSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizations<T extends User$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends User$tagsArgs<ExtArgs> = {}>(args?: Subset<T, User$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly auth0Id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly azureContainer: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.userCourses
   */
  export type User$userCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    where?: UserCourseWhereInput
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    cursor?: UserCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseScalarFieldEnum | UserCourseScalarFieldEnum[]
  }

  /**
   * User.userResponses
   */
  export type User$userResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    where?: UserResponseWhereInput
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    cursor?: UserResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserResponseScalarFieldEnum | UserResponseScalarFieldEnum[]
  }

  /**
   * User.userAchievements
   */
  export type User$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.userStats
   */
  export type User$userStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    where?: UserStatsWhereInput
  }

  /**
   * User.UserSession
   */
  export type User$UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.organizations
   */
  export type User$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * User.tags
   */
  export type User$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    cursor?: UserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    difficulty: string | null
    duration: string | null
    sourceType: string | null
    sourceOrganizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    difficulty: string | null
    duration: string | null
    sourceType: string | null
    sourceOrganizationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    courseId: number
    name: number
    description: number
    imageUrl: number
    category: number
    difficulty: number
    duration: number
    sourceType: number
    sourceOrganizationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    sourceType?: true
    sourceOrganizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    sourceType?: true
    sourceOrganizationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    courseId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    sourceType?: true
    sourceOrganizationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    courseId: string
    name: string
    description: string
    imageUrl: string | null
    category: string
    difficulty: string
    duration: string
    sourceType: string | null
    sourceOrganizationId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    sourceType?: boolean
    sourceOrganizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | Course$modulesArgs<ExtArgs>
    userCourses?: boolean | Course$userCoursesArgs<ExtArgs>
    userSessions?: boolean | Course$userSessionsArgs<ExtArgs>
    OrganizationTraining?: boolean | Course$OrganizationTrainingArgs<ExtArgs>
    TagTraining?: boolean | Course$TagTrainingArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    sourceType?: boolean
    sourceOrganizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    sourceType?: boolean
    sourceOrganizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    courseId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    sourceType?: boolean
    sourceOrganizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "name" | "description" | "imageUrl" | "category" | "difficulty" | "duration" | "sourceType" | "sourceOrganizationId" | "createdAt" | "updatedAt", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modules?: boolean | Course$modulesArgs<ExtArgs>
    userCourses?: boolean | Course$userCoursesArgs<ExtArgs>
    userSessions?: boolean | Course$userSessionsArgs<ExtArgs>
    OrganizationTraining?: boolean | Course$OrganizationTrainingArgs<ExtArgs>
    TagTraining?: boolean | Course$TagTrainingArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      modules: Prisma.$ModulePayload<ExtArgs>[]
      userCourses: Prisma.$UserCoursePayload<ExtArgs>[]
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      OrganizationTraining: Prisma.$OrganizationTrainingPayload<ExtArgs>[]
      TagTraining: Prisma.$TagTrainingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      name: string
      description: string
      imageUrl: string | null
      category: string
      difficulty: string
      duration: string
      sourceType: string | null
      sourceOrganizationId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modules<T extends Course$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Course$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCourses<T extends Course$userCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$userCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSessions<T extends Course$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Course$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrganizationTraining<T extends Course$OrganizationTrainingArgs<ExtArgs> = {}>(args?: Subset<T, Course$OrganizationTrainingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TagTraining<T extends Course$TagTrainingArgs<ExtArgs> = {}>(args?: Subset<T, Course$TagTrainingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly courseId: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly imageUrl: FieldRef<"Course", 'String'>
    readonly category: FieldRef<"Course", 'String'>
    readonly difficulty: FieldRef<"Course", 'String'>
    readonly duration: FieldRef<"Course", 'String'>
    readonly sourceType: FieldRef<"Course", 'String'>
    readonly sourceOrganizationId: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.modules
   */
  export type Course$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Course.userCourses
   */
  export type Course$userCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    where?: UserCourseWhereInput
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    cursor?: UserCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCourseScalarFieldEnum | UserCourseScalarFieldEnum[]
  }

  /**
   * Course.userSessions
   */
  export type Course$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * Course.OrganizationTraining
   */
  export type Course$OrganizationTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    where?: OrganizationTrainingWhereInput
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    cursor?: OrganizationTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationTrainingScalarFieldEnum | OrganizationTrainingScalarFieldEnum[]
  }

  /**
   * Course.TagTraining
   */
  export type Course$TagTrainingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    where?: TagTrainingWhereInput
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    cursor?: TagTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagTrainingScalarFieldEnum | TagTrainingScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model UserCourse
   */

  export type AggregateUserCourse = {
    _count: UserCourseCountAggregateOutputType | null
    _avg: UserCourseAvgAggregateOutputType | null
    _sum: UserCourseSumAggregateOutputType | null
    _min: UserCourseMinAggregateOutputType | null
    _max: UserCourseMaxAggregateOutputType | null
  }

  export type UserCourseAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserCourseSumAggregateOutputType = {
    progress: number | null
  }

  export type UserCourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    lastAccessed: Date | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    lastAccessed: Date | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCourseCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    progress: number
    lastAccessed: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserCourseAvgAggregateInputType = {
    progress?: true
  }

  export type UserCourseSumAggregateInputType = {
    progress?: true
  }

  export type UserCourseMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    lastAccessed?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    lastAccessed?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCourseCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    lastAccessed?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourse to aggregate.
     */
    where?: UserCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourses to fetch.
     */
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCourses
    **/
    _count?: true | UserCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCourseMaxAggregateInputType
  }

  export type GetUserCourseAggregateType<T extends UserCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCourse[P]>
      : GetScalarType<T[P], AggregateUserCourse[P]>
  }




  export type UserCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCourseWhereInput
    orderBy?: UserCourseOrderByWithAggregationInput | UserCourseOrderByWithAggregationInput[]
    by: UserCourseScalarFieldEnum[] | UserCourseScalarFieldEnum
    having?: UserCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCourseCountAggregateInputType | true
    _avg?: UserCourseAvgAggregateInputType
    _sum?: UserCourseSumAggregateInputType
    _min?: UserCourseMinAggregateInputType
    _max?: UserCourseMaxAggregateInputType
  }

  export type UserCourseGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    progress: number
    lastAccessed: Date
    startedAt: Date
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCourseCountAggregateOutputType | null
    _avg: UserCourseAvgAggregateOutputType | null
    _sum: UserCourseSumAggregateOutputType | null
    _min: UserCourseMinAggregateOutputType | null
    _max: UserCourseMaxAggregateOutputType | null
  }

  type GetUserCourseGroupByPayload<T extends UserCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCourseGroupByOutputType[P]>
            : GetScalarType<T[P], UserCourseGroupByOutputType[P]>
        }
      >
    >


  export type UserCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    lastAccessed?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    userModules?: boolean | UserCourse$userModulesArgs<ExtArgs>
    _count?: boolean | UserCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourse"]>

  export type UserCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    lastAccessed?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourse"]>

  export type UserCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    lastAccessed?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCourse"]>

  export type UserCourseSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    lastAccessed?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "progress" | "lastAccessed" | "startedAt" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userCourse"]>
  export type UserCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    userModules?: boolean | UserCourse$userModulesArgs<ExtArgs>
    _count?: boolean | UserCourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type UserCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $UserCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCourse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      userModules: Prisma.$UserModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      progress: number
      lastAccessed: Date
      startedAt: Date
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userCourse"]>
    composites: {}
  }

  type UserCourseGetPayload<S extends boolean | null | undefined | UserCourseDefaultArgs> = $Result.GetResult<Prisma.$UserCoursePayload, S>

  type UserCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCourseCountAggregateInputType | true
    }

  export interface UserCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCourse'], meta: { name: 'UserCourse' } }
    /**
     * Find zero or one UserCourse that matches the filter.
     * @param {UserCourseFindUniqueArgs} args - Arguments to find a UserCourse
     * @example
     * // Get one UserCourse
     * const userCourse = await prisma.userCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCourseFindUniqueArgs>(args: SelectSubset<T, UserCourseFindUniqueArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCourseFindUniqueOrThrowArgs} args - Arguments to find a UserCourse
     * @example
     * // Get one UserCourse
     * const userCourse = await prisma.userCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseFindFirstArgs} args - Arguments to find a UserCourse
     * @example
     * // Get one UserCourse
     * const userCourse = await prisma.userCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCourseFindFirstArgs>(args?: SelectSubset<T, UserCourseFindFirstArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseFindFirstOrThrowArgs} args - Arguments to find a UserCourse
     * @example
     * // Get one UserCourse
     * const userCourse = await prisma.userCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCourses
     * const userCourses = await prisma.userCourse.findMany()
     * 
     * // Get first 10 UserCourses
     * const userCourses = await prisma.userCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCourseWithIdOnly = await prisma.userCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCourseFindManyArgs>(args?: SelectSubset<T, UserCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCourse.
     * @param {UserCourseCreateArgs} args - Arguments to create a UserCourse.
     * @example
     * // Create one UserCourse
     * const UserCourse = await prisma.userCourse.create({
     *   data: {
     *     // ... data to create a UserCourse
     *   }
     * })
     * 
     */
    create<T extends UserCourseCreateArgs>(args: SelectSubset<T, UserCourseCreateArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCourses.
     * @param {UserCourseCreateManyArgs} args - Arguments to create many UserCourses.
     * @example
     * // Create many UserCourses
     * const userCourse = await prisma.userCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCourseCreateManyArgs>(args?: SelectSubset<T, UserCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCourses and returns the data saved in the database.
     * @param {UserCourseCreateManyAndReturnArgs} args - Arguments to create many UserCourses.
     * @example
     * // Create many UserCourses
     * const userCourse = await prisma.userCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCourses and only return the `id`
     * const userCourseWithIdOnly = await prisma.userCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCourse.
     * @param {UserCourseDeleteArgs} args - Arguments to delete one UserCourse.
     * @example
     * // Delete one UserCourse
     * const UserCourse = await prisma.userCourse.delete({
     *   where: {
     *     // ... filter to delete one UserCourse
     *   }
     * })
     * 
     */
    delete<T extends UserCourseDeleteArgs>(args: SelectSubset<T, UserCourseDeleteArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCourse.
     * @param {UserCourseUpdateArgs} args - Arguments to update one UserCourse.
     * @example
     * // Update one UserCourse
     * const userCourse = await prisma.userCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCourseUpdateArgs>(args: SelectSubset<T, UserCourseUpdateArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCourses.
     * @param {UserCourseDeleteManyArgs} args - Arguments to filter UserCourses to delete.
     * @example
     * // Delete a few UserCourses
     * const { count } = await prisma.userCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCourseDeleteManyArgs>(args?: SelectSubset<T, UserCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCourses
     * const userCourse = await prisma.userCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCourseUpdateManyArgs>(args: SelectSubset<T, UserCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCourses and returns the data updated in the database.
     * @param {UserCourseUpdateManyAndReturnArgs} args - Arguments to update many UserCourses.
     * @example
     * // Update many UserCourses
     * const userCourse = await prisma.userCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCourses and only return the `id`
     * const userCourseWithIdOnly = await prisma.userCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCourse.
     * @param {UserCourseUpsertArgs} args - Arguments to update or create a UserCourse.
     * @example
     * // Update or create a UserCourse
     * const userCourse = await prisma.userCourse.upsert({
     *   create: {
     *     // ... data to create a UserCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCourse we want to update
     *   }
     * })
     */
    upsert<T extends UserCourseUpsertArgs>(args: SelectSubset<T, UserCourseUpsertArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseCountArgs} args - Arguments to filter UserCourses to count.
     * @example
     * // Count the number of UserCourses
     * const count = await prisma.userCourse.count({
     *   where: {
     *     // ... the filter for the UserCourses we want to count
     *   }
     * })
    **/
    count<T extends UserCourseCountArgs>(
      args?: Subset<T, UserCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCourseAggregateArgs>(args: Subset<T, UserCourseAggregateArgs>): Prisma.PrismaPromise<GetUserCourseAggregateType<T>>

    /**
     * Group by UserCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCourseGroupByArgs['orderBy'] }
        : { orderBy?: UserCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCourse model
   */
  readonly fields: UserCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userModules<T extends UserCourse$userModulesArgs<ExtArgs> = {}>(args?: Subset<T, UserCourse$userModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCourse model
   */
  interface UserCourseFieldRefs {
    readonly id: FieldRef<"UserCourse", 'String'>
    readonly userId: FieldRef<"UserCourse", 'String'>
    readonly courseId: FieldRef<"UserCourse", 'String'>
    readonly progress: FieldRef<"UserCourse", 'Int'>
    readonly lastAccessed: FieldRef<"UserCourse", 'DateTime'>
    readonly startedAt: FieldRef<"UserCourse", 'DateTime'>
    readonly completedAt: FieldRef<"UserCourse", 'DateTime'>
    readonly createdAt: FieldRef<"UserCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"UserCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCourse findUnique
   */
  export type UserCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter, which UserCourse to fetch.
     */
    where: UserCourseWhereUniqueInput
  }

  /**
   * UserCourse findUniqueOrThrow
   */
  export type UserCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter, which UserCourse to fetch.
     */
    where: UserCourseWhereUniqueInput
  }

  /**
   * UserCourse findFirst
   */
  export type UserCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter, which UserCourse to fetch.
     */
    where?: UserCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourses to fetch.
     */
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourses.
     */
    cursor?: UserCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourses.
     */
    distinct?: UserCourseScalarFieldEnum | UserCourseScalarFieldEnum[]
  }

  /**
   * UserCourse findFirstOrThrow
   */
  export type UserCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter, which UserCourse to fetch.
     */
    where?: UserCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourses to fetch.
     */
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCourses.
     */
    cursor?: UserCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCourses.
     */
    distinct?: UserCourseScalarFieldEnum | UserCourseScalarFieldEnum[]
  }

  /**
   * UserCourse findMany
   */
  export type UserCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter, which UserCourses to fetch.
     */
    where?: UserCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCourses to fetch.
     */
    orderBy?: UserCourseOrderByWithRelationInput | UserCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCourses.
     */
    cursor?: UserCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCourses.
     */
    skip?: number
    distinct?: UserCourseScalarFieldEnum | UserCourseScalarFieldEnum[]
  }

  /**
   * UserCourse create
   */
  export type UserCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCourse.
     */
    data: XOR<UserCourseCreateInput, UserCourseUncheckedCreateInput>
  }

  /**
   * UserCourse createMany
   */
  export type UserCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCourses.
     */
    data: UserCourseCreateManyInput | UserCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCourse createManyAndReturn
   */
  export type UserCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * The data used to create many UserCourses.
     */
    data: UserCourseCreateManyInput | UserCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourse update
   */
  export type UserCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCourse.
     */
    data: XOR<UserCourseUpdateInput, UserCourseUncheckedUpdateInput>
    /**
     * Choose, which UserCourse to update.
     */
    where: UserCourseWhereUniqueInput
  }

  /**
   * UserCourse updateMany
   */
  export type UserCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCourses.
     */
    data: XOR<UserCourseUpdateManyMutationInput, UserCourseUncheckedUpdateManyInput>
    /**
     * Filter which UserCourses to update
     */
    where?: UserCourseWhereInput
    /**
     * Limit how many UserCourses to update.
     */
    limit?: number
  }

  /**
   * UserCourse updateManyAndReturn
   */
  export type UserCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * The data used to update UserCourses.
     */
    data: XOR<UserCourseUpdateManyMutationInput, UserCourseUncheckedUpdateManyInput>
    /**
     * Filter which UserCourses to update
     */
    where?: UserCourseWhereInput
    /**
     * Limit how many UserCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCourse upsert
   */
  export type UserCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCourse to update in case it exists.
     */
    where: UserCourseWhereUniqueInput
    /**
     * In case the UserCourse found by the `where` argument doesn't exist, create a new UserCourse with this data.
     */
    create: XOR<UserCourseCreateInput, UserCourseUncheckedCreateInput>
    /**
     * In case the UserCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCourseUpdateInput, UserCourseUncheckedUpdateInput>
  }

  /**
   * UserCourse delete
   */
  export type UserCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
    /**
     * Filter which UserCourse to delete.
     */
    where: UserCourseWhereUniqueInput
  }

  /**
   * UserCourse deleteMany
   */
  export type UserCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCourses to delete
     */
    where?: UserCourseWhereInput
    /**
     * Limit how many UserCourses to delete.
     */
    limit?: number
  }

  /**
   * UserCourse.userModules
   */
  export type UserCourse$userModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    where?: UserModuleWhereInput
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    cursor?: UserModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserModuleScalarFieldEnum | UserModuleScalarFieldEnum[]
  }

  /**
   * UserCourse without action
   */
  export type UserCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCourse
     */
    select?: UserCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCourse
     */
    omit?: UserCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCourseInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    order: number | null
  }

  export type ModuleSumAggregateOutputType = {
    order: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    courseId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    courseId: string | null
    title: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    moduleId: number
    courseId: number
    title: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    order?: true
  }

  export type ModuleSumAggregateInputType = {
    order?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    moduleId?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    moduleId?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    moduleId?: true
    courseId?: true
    title?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    moduleId: string
    courseId: string
    title: string
    description: string
    order: number
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    scenarios?: boolean | Module$scenariosArgs<ExtArgs>
    userModules?: boolean | Module$userModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    moduleId?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "moduleId" | "courseId" | "title" | "description" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    scenarios?: boolean | Module$scenariosArgs<ExtArgs>
    userModules?: boolean | Module$userModulesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      scenarios: Prisma.$ScenarioPayload<ExtArgs>[]
      userModules: Prisma.$UserModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      courseId: string
      title: string
      description: string
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scenarios<T extends Module$scenariosArgs<ExtArgs> = {}>(args?: Subset<T, Module$scenariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userModules<T extends Module$userModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$userModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly moduleId: FieldRef<"Module", 'String'>
    readonly courseId: FieldRef<"Module", 'String'>
    readonly title: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly order: FieldRef<"Module", 'Int'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.scenarios
   */
  export type Module$scenariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    cursor?: ScenarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Module.userModules
   */
  export type Module$userModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    where?: UserModuleWhereInput
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    cursor?: UserModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserModuleScalarFieldEnum | UserModuleScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Scenario
   */

  export type AggregateScenario = {
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  export type ScenarioMinAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    moduleId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioMaxAggregateOutputType = {
    id: string | null
    scenarioId: string | null
    moduleId: string | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScenarioCountAggregateOutputType = {
    id: number
    scenarioId: number
    moduleId: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScenarioMinAggregateInputType = {
    id?: true
    scenarioId?: true
    moduleId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioMaxAggregateInputType = {
    id?: true
    scenarioId?: true
    moduleId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScenarioCountAggregateInputType = {
    id?: true
    scenarioId?: true
    moduleId?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScenarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenario to aggregate.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scenarios
    **/
    _count?: true | ScenarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScenarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScenarioMaxAggregateInputType
  }

  export type GetScenarioAggregateType<T extends ScenarioAggregateArgs> = {
        [P in keyof T & keyof AggregateScenario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScenario[P]>
      : GetScalarType<T[P], AggregateScenario[P]>
  }




  export type ScenarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScenarioWhereInput
    orderBy?: ScenarioOrderByWithAggregationInput | ScenarioOrderByWithAggregationInput[]
    by: ScenarioScalarFieldEnum[] | ScenarioScalarFieldEnum
    having?: ScenarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScenarioCountAggregateInputType | true
    _min?: ScenarioMinAggregateInputType
    _max?: ScenarioMaxAggregateInputType
  }

  export type ScenarioGroupByOutputType = {
    id: string
    scenarioId: string
    moduleId: string
    title: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: ScenarioCountAggregateOutputType | null
    _min: ScenarioMinAggregateOutputType | null
    _max: ScenarioMaxAggregateOutputType | null
  }

  type GetScenarioGroupByPayload<T extends ScenarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScenarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScenarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
            : GetScalarType<T[P], ScenarioGroupByOutputType[P]>
        }
      >
    >


  export type ScenarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    questions?: boolean | Scenario$questionsArgs<ExtArgs>
    userResponses?: boolean | Scenario$userResponsesArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scenarioId?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scenario"]>

  export type ScenarioSelectScalar = {
    id?: boolean
    scenarioId?: boolean
    moduleId?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScenarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scenarioId" | "moduleId" | "title" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["scenario"]>
  export type ScenarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    questions?: boolean | Scenario$questionsArgs<ExtArgs>
    userResponses?: boolean | Scenario$userResponsesArgs<ExtArgs>
    _count?: boolean | ScenarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ScenarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ScenarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Scenario"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      userResponses: Prisma.$UserResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scenarioId: string
      moduleId: string
      title: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scenario"]>
    composites: {}
  }

  type ScenarioGetPayload<S extends boolean | null | undefined | ScenarioDefaultArgs> = $Result.GetResult<Prisma.$ScenarioPayload, S>

  type ScenarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScenarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScenarioCountAggregateInputType | true
    }

  export interface ScenarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Scenario'], meta: { name: 'Scenario' } }
    /**
     * Find zero or one Scenario that matches the filter.
     * @param {ScenarioFindUniqueArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScenarioFindUniqueArgs>(args: SelectSubset<T, ScenarioFindUniqueArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scenario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScenarioFindUniqueOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScenarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ScenarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScenarioFindFirstArgs>(args?: SelectSubset<T, ScenarioFindFirstArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scenario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindFirstOrThrowArgs} args - Arguments to find a Scenario
     * @example
     * // Get one Scenario
     * const scenario = await prisma.scenario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScenarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ScenarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scenarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scenarios
     * const scenarios = await prisma.scenario.findMany()
     * 
     * // Get first 10 Scenarios
     * const scenarios = await prisma.scenario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scenarioWithIdOnly = await prisma.scenario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScenarioFindManyArgs>(args?: SelectSubset<T, ScenarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scenario.
     * @param {ScenarioCreateArgs} args - Arguments to create a Scenario.
     * @example
     * // Create one Scenario
     * const Scenario = await prisma.scenario.create({
     *   data: {
     *     // ... data to create a Scenario
     *   }
     * })
     * 
     */
    create<T extends ScenarioCreateArgs>(args: SelectSubset<T, ScenarioCreateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scenarios.
     * @param {ScenarioCreateManyArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScenarioCreateManyArgs>(args?: SelectSubset<T, ScenarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scenarios and returns the data saved in the database.
     * @param {ScenarioCreateManyAndReturnArgs} args - Arguments to create many Scenarios.
     * @example
     * // Create many Scenarios
     * const scenario = await prisma.scenario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScenarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ScenarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scenario.
     * @param {ScenarioDeleteArgs} args - Arguments to delete one Scenario.
     * @example
     * // Delete one Scenario
     * const Scenario = await prisma.scenario.delete({
     *   where: {
     *     // ... filter to delete one Scenario
     *   }
     * })
     * 
     */
    delete<T extends ScenarioDeleteArgs>(args: SelectSubset<T, ScenarioDeleteArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scenario.
     * @param {ScenarioUpdateArgs} args - Arguments to update one Scenario.
     * @example
     * // Update one Scenario
     * const scenario = await prisma.scenario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScenarioUpdateArgs>(args: SelectSubset<T, ScenarioUpdateArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scenarios.
     * @param {ScenarioDeleteManyArgs} args - Arguments to filter Scenarios to delete.
     * @example
     * // Delete a few Scenarios
     * const { count } = await prisma.scenario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScenarioDeleteManyArgs>(args?: SelectSubset<T, ScenarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScenarioUpdateManyArgs>(args: SelectSubset<T, ScenarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scenarios and returns the data updated in the database.
     * @param {ScenarioUpdateManyAndReturnArgs} args - Arguments to update many Scenarios.
     * @example
     * // Update many Scenarios
     * const scenario = await prisma.scenario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scenarios and only return the `id`
     * const scenarioWithIdOnly = await prisma.scenario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScenarioUpdateManyAndReturnArgs>(args: SelectSubset<T, ScenarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scenario.
     * @param {ScenarioUpsertArgs} args - Arguments to update or create a Scenario.
     * @example
     * // Update or create a Scenario
     * const scenario = await prisma.scenario.upsert({
     *   create: {
     *     // ... data to create a Scenario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scenario we want to update
     *   }
     * })
     */
    upsert<T extends ScenarioUpsertArgs>(args: SelectSubset<T, ScenarioUpsertArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scenarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioCountArgs} args - Arguments to filter Scenarios to count.
     * @example
     * // Count the number of Scenarios
     * const count = await prisma.scenario.count({
     *   where: {
     *     // ... the filter for the Scenarios we want to count
     *   }
     * })
    **/
    count<T extends ScenarioCountArgs>(
      args?: Subset<T, ScenarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScenarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScenarioAggregateArgs>(args: Subset<T, ScenarioAggregateArgs>): Prisma.PrismaPromise<GetScenarioAggregateType<T>>

    /**
     * Group by Scenario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScenarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScenarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScenarioGroupByArgs['orderBy'] }
        : { orderBy?: ScenarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScenarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScenarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Scenario model
   */
  readonly fields: ScenarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Scenario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScenarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends Scenario$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Scenario$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userResponses<T extends Scenario$userResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Scenario$userResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Scenario model
   */
  interface ScenarioFieldRefs {
    readonly id: FieldRef<"Scenario", 'String'>
    readonly scenarioId: FieldRef<"Scenario", 'String'>
    readonly moduleId: FieldRef<"Scenario", 'String'>
    readonly title: FieldRef<"Scenario", 'String'>
    readonly description: FieldRef<"Scenario", 'String'>
    readonly createdAt: FieldRef<"Scenario", 'DateTime'>
    readonly updatedAt: FieldRef<"Scenario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Scenario findUnique
   */
  export type ScenarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findUniqueOrThrow
   */
  export type ScenarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario findFirst
   */
  export type ScenarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findFirstOrThrow
   */
  export type ScenarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenario to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scenarios.
     */
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario findMany
   */
  export type ScenarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter, which Scenarios to fetch.
     */
    where?: ScenarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scenarios to fetch.
     */
    orderBy?: ScenarioOrderByWithRelationInput | ScenarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scenarios.
     */
    cursor?: ScenarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scenarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scenarios.
     */
    skip?: number
    distinct?: ScenarioScalarFieldEnum | ScenarioScalarFieldEnum[]
  }

  /**
   * Scenario create
   */
  export type ScenarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Scenario.
     */
    data: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
  }

  /**
   * Scenario createMany
   */
  export type ScenarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Scenario createManyAndReturn
   */
  export type ScenarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to create many Scenarios.
     */
    data: ScenarioCreateManyInput | ScenarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario update
   */
  export type ScenarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Scenario.
     */
    data: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
    /**
     * Choose, which Scenario to update.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario updateMany
   */
  export type ScenarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
  }

  /**
   * Scenario updateManyAndReturn
   */
  export type ScenarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * The data used to update Scenarios.
     */
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyInput>
    /**
     * Filter which Scenarios to update
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Scenario upsert
   */
  export type ScenarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Scenario to update in case it exists.
     */
    where: ScenarioWhereUniqueInput
    /**
     * In case the Scenario found by the `where` argument doesn't exist, create a new Scenario with this data.
     */
    create: XOR<ScenarioCreateInput, ScenarioUncheckedCreateInput>
    /**
     * In case the Scenario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScenarioUpdateInput, ScenarioUncheckedUpdateInput>
  }

  /**
   * Scenario delete
   */
  export type ScenarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
    /**
     * Filter which Scenario to delete.
     */
    where: ScenarioWhereUniqueInput
  }

  /**
   * Scenario deleteMany
   */
  export type ScenarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scenarios to delete
     */
    where?: ScenarioWhereInput
    /**
     * Limit how many Scenarios to delete.
     */
    limit?: number
  }

  /**
   * Scenario.questions
   */
  export type Scenario$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Scenario.userResponses
   */
  export type Scenario$userResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    where?: UserResponseWhereInput
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    cursor?: UserResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserResponseScalarFieldEnum | UserResponseScalarFieldEnum[]
  }

  /**
   * Scenario without action
   */
  export type ScenarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Scenario
     */
    select?: ScenarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Scenario
     */
    omit?: ScenarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScenarioInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    scenarioId: string | null
    text: string | null
    type: string | null
    explanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    scenarioId: string | null
    text: string | null
    type: string | null
    explanation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    questionId: number
    scenarioId: number
    text: number
    type: number
    explanation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionMinAggregateInputType = {
    id?: true
    questionId?: true
    scenarioId?: true
    text?: true
    type?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    questionId?: true
    scenarioId?: true
    text?: true
    type?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    questionId?: true
    scenarioId?: true
    text?: true
    type?: true
    explanation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    questionId: string
    scenarioId: string
    text: string
    type: string
    explanation: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionCountAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    scenarioId?: boolean
    text?: boolean
    type?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    options?: boolean | Question$optionsArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    scenarioId?: boolean
    text?: boolean
    type?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    scenarioId?: boolean
    text?: boolean
    type?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    questionId?: boolean
    scenarioId?: boolean
    text?: boolean
    type?: boolean
    explanation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "scenarioId" | "text" | "type" | "explanation" | "createdAt" | "updatedAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
    options?: boolean | Question$optionsArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      scenario: Prisma.$ScenarioPayload<ExtArgs>
      options: Prisma.$OptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      scenarioId: string
      text: string
      type: string
      explanation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scenario<T extends ScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScenarioDefaultArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends Question$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Question$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly questionId: FieldRef<"Question", 'String'>
    readonly scenarioId: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly type: FieldRef<"Question", 'String'>
    readonly explanation: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.options
   */
  export type Question$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    cursor?: OptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionMinAggregateOutputType = {
    id: string | null
    optionId: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionMaxAggregateOutputType = {
    id: string | null
    optionId: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    optionId: number
    questionId: number
    text: number
    isCorrect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OptionMinAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Option to aggregate.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithAggregationInput | OptionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: string
    optionId: string
    questionId: string
    text: string
    isCorrect: boolean
    createdAt: Date
    updatedAt: Date
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectScalar = {
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "optionId" | "questionId" | "text" | "isCorrect" | "createdAt" | "updatedAt", ExtArgs["result"]["option"]>
  export type OptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type OptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type OptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $OptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Option"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      optionId: string
      questionId: string
      text: string
      isCorrect: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type OptionGetPayload<S extends boolean | null | undefined | OptionDefaultArgs> = $Result.GetResult<Prisma.$OptionPayload, S>

  type OptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface OptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Option'], meta: { name: 'Option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionFindUniqueArgs>(args: SelectSubset<T, OptionFindUniqueArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionFindFirstArgs>(args?: SelectSubset<T, OptionFindFirstArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionFindManyArgs>(args?: SelectSubset<T, OptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends OptionCreateArgs>(args: SelectSubset<T, OptionCreateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Options.
     * @param {OptionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionCreateManyArgs>(args?: SelectSubset<T, OptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Options and returns the data saved in the database.
     * @param {OptionCreateManyAndReturnArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends OptionDeleteArgs>(args: SelectSubset<T, OptionDeleteArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionUpdateArgs>(args: SelectSubset<T, OptionUpdateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionDeleteManyArgs>(args?: SelectSubset<T, OptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionUpdateManyArgs>(args: SelectSubset<T, OptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options and returns the data updated in the database.
     * @param {OptionUpdateManyAndReturnArgs} args - Arguments to update many Options.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OptionUpdateManyAndReturnArgs>(args: SelectSubset<T, OptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends OptionUpsertArgs>(args: SelectSubset<T, OptionUpsertArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Option model
   */
  readonly fields: OptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Option model
   */
  interface OptionFieldRefs {
    readonly id: FieldRef<"Option", 'String'>
    readonly optionId: FieldRef<"Option", 'String'>
    readonly questionId: FieldRef<"Option", 'String'>
    readonly text: FieldRef<"Option", 'String'>
    readonly isCorrect: FieldRef<"Option", 'Boolean'>
    readonly createdAt: FieldRef<"Option", 'DateTime'>
    readonly updatedAt: FieldRef<"Option", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Option findUnique
   */
  export type OptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findFirst
   */
  export type OptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findMany
   */
  export type OptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Options to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option create
   */
  export type OptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Option.
     */
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }

  /**
   * Option createMany
   */
  export type OptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Option createManyAndReturn
   */
  export type OptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Option update
   */
  export type OptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Option.
     */
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
  }

  /**
   * Option updateManyAndReturn
   */
  export type OptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Option upsert
   */
  export type OptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Option to update in case it exists.
     */
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     */
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }

  /**
   * Option delete
   */
  export type OptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter which Option to delete.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Options to delete
     */
    where?: OptionWhereInput
    /**
     * Limit how many Options to delete.
     */
    limit?: number
  }

  /**
   * Option without action
   */
  export type OptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Option
     */
    omit?: OptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
  }


  /**
   * Model UserModule
   */

  export type AggregateUserModule = {
    _count: UserModuleCountAggregateOutputType | null
    _avg: UserModuleAvgAggregateOutputType | null
    _sum: UserModuleSumAggregateOutputType | null
    _min: UserModuleMinAggregateOutputType | null
    _max: UserModuleMaxAggregateOutputType | null
  }

  export type UserModuleAvgAggregateOutputType = {
    score: number | null
  }

  export type UserModuleSumAggregateOutputType = {
    score: number | null
  }

  export type UserModuleMinAggregateOutputType = {
    id: string | null
    userCourseId: string | null
    moduleId: string | null
    completed: boolean | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserModuleMaxAggregateOutputType = {
    id: string | null
    userCourseId: string | null
    moduleId: string | null
    completed: boolean | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserModuleCountAggregateOutputType = {
    id: number
    userCourseId: number
    moduleId: number
    completed: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserModuleAvgAggregateInputType = {
    score?: true
  }

  export type UserModuleSumAggregateInputType = {
    score?: true
  }

  export type UserModuleMinAggregateInputType = {
    id?: true
    userCourseId?: true
    moduleId?: true
    completed?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserModuleMaxAggregateInputType = {
    id?: true
    userCourseId?: true
    moduleId?: true
    completed?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserModuleCountAggregateInputType = {
    id?: true
    userCourseId?: true
    moduleId?: true
    completed?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModule to aggregate.
     */
    where?: UserModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModules to fetch.
     */
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserModules
    **/
    _count?: true | UserModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserModuleMaxAggregateInputType
  }

  export type GetUserModuleAggregateType<T extends UserModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserModule[P]>
      : GetScalarType<T[P], AggregateUserModule[P]>
  }




  export type UserModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserModuleWhereInput
    orderBy?: UserModuleOrderByWithAggregationInput | UserModuleOrderByWithAggregationInput[]
    by: UserModuleScalarFieldEnum[] | UserModuleScalarFieldEnum
    having?: UserModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserModuleCountAggregateInputType | true
    _avg?: UserModuleAvgAggregateInputType
    _sum?: UserModuleSumAggregateInputType
    _min?: UserModuleMinAggregateInputType
    _max?: UserModuleMaxAggregateInputType
  }

  export type UserModuleGroupByOutputType = {
    id: string
    userCourseId: string
    moduleId: string
    completed: boolean
    score: number
    createdAt: Date
    updatedAt: Date
    _count: UserModuleCountAggregateOutputType | null
    _avg: UserModuleAvgAggregateOutputType | null
    _sum: UserModuleSumAggregateOutputType | null
    _min: UserModuleMinAggregateOutputType | null
    _max: UserModuleMaxAggregateOutputType | null
  }

  type GetUserModuleGroupByPayload<T extends UserModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserModuleGroupByOutputType[P]>
            : GetScalarType<T[P], UserModuleGroupByOutputType[P]>
        }
      >
    >


  export type UserModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCourseId?: boolean
    moduleId?: boolean
    completed?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModule"]>

  export type UserModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCourseId?: boolean
    moduleId?: boolean
    completed?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModule"]>

  export type UserModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userCourseId?: boolean
    moduleId?: boolean
    completed?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userModule"]>

  export type UserModuleSelectScalar = {
    id?: boolean
    userCourseId?: boolean
    moduleId?: boolean
    completed?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userCourseId" | "moduleId" | "completed" | "score" | "createdAt" | "updatedAt", ExtArgs["result"]["userModule"]>
  export type UserModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type UserModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type UserModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userCourse?: boolean | UserCourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $UserModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserModule"
    objects: {
      userCourse: Prisma.$UserCoursePayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userCourseId: string
      moduleId: string
      completed: boolean
      score: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userModule"]>
    composites: {}
  }

  type UserModuleGetPayload<S extends boolean | null | undefined | UserModuleDefaultArgs> = $Result.GetResult<Prisma.$UserModulePayload, S>

  type UserModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserModuleCountAggregateInputType | true
    }

  export interface UserModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserModule'], meta: { name: 'UserModule' } }
    /**
     * Find zero or one UserModule that matches the filter.
     * @param {UserModuleFindUniqueArgs} args - Arguments to find a UserModule
     * @example
     * // Get one UserModule
     * const userModule = await prisma.userModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserModuleFindUniqueArgs>(args: SelectSubset<T, UserModuleFindUniqueArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserModuleFindUniqueOrThrowArgs} args - Arguments to find a UserModule
     * @example
     * // Get one UserModule
     * const userModule = await prisma.userModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleFindFirstArgs} args - Arguments to find a UserModule
     * @example
     * // Get one UserModule
     * const userModule = await prisma.userModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserModuleFindFirstArgs>(args?: SelectSubset<T, UserModuleFindFirstArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleFindFirstOrThrowArgs} args - Arguments to find a UserModule
     * @example
     * // Get one UserModule
     * const userModule = await prisma.userModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserModules
     * const userModules = await prisma.userModule.findMany()
     * 
     * // Get first 10 UserModules
     * const userModules = await prisma.userModule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userModuleWithIdOnly = await prisma.userModule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserModuleFindManyArgs>(args?: SelectSubset<T, UserModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserModule.
     * @param {UserModuleCreateArgs} args - Arguments to create a UserModule.
     * @example
     * // Create one UserModule
     * const UserModule = await prisma.userModule.create({
     *   data: {
     *     // ... data to create a UserModule
     *   }
     * })
     * 
     */
    create<T extends UserModuleCreateArgs>(args: SelectSubset<T, UserModuleCreateArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserModules.
     * @param {UserModuleCreateManyArgs} args - Arguments to create many UserModules.
     * @example
     * // Create many UserModules
     * const userModule = await prisma.userModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserModuleCreateManyArgs>(args?: SelectSubset<T, UserModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserModules and returns the data saved in the database.
     * @param {UserModuleCreateManyAndReturnArgs} args - Arguments to create many UserModules.
     * @example
     * // Create many UserModules
     * const userModule = await prisma.userModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserModules and only return the `id`
     * const userModuleWithIdOnly = await prisma.userModule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserModule.
     * @param {UserModuleDeleteArgs} args - Arguments to delete one UserModule.
     * @example
     * // Delete one UserModule
     * const UserModule = await prisma.userModule.delete({
     *   where: {
     *     // ... filter to delete one UserModule
     *   }
     * })
     * 
     */
    delete<T extends UserModuleDeleteArgs>(args: SelectSubset<T, UserModuleDeleteArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserModule.
     * @param {UserModuleUpdateArgs} args - Arguments to update one UserModule.
     * @example
     * // Update one UserModule
     * const userModule = await prisma.userModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserModuleUpdateArgs>(args: SelectSubset<T, UserModuleUpdateArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserModules.
     * @param {UserModuleDeleteManyArgs} args - Arguments to filter UserModules to delete.
     * @example
     * // Delete a few UserModules
     * const { count } = await prisma.userModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserModuleDeleteManyArgs>(args?: SelectSubset<T, UserModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserModules
     * const userModule = await prisma.userModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserModuleUpdateManyArgs>(args: SelectSubset<T, UserModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserModules and returns the data updated in the database.
     * @param {UserModuleUpdateManyAndReturnArgs} args - Arguments to update many UserModules.
     * @example
     * // Update many UserModules
     * const userModule = await prisma.userModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserModules and only return the `id`
     * const userModuleWithIdOnly = await prisma.userModule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserModule.
     * @param {UserModuleUpsertArgs} args - Arguments to update or create a UserModule.
     * @example
     * // Update or create a UserModule
     * const userModule = await prisma.userModule.upsert({
     *   create: {
     *     // ... data to create a UserModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserModule we want to update
     *   }
     * })
     */
    upsert<T extends UserModuleUpsertArgs>(args: SelectSubset<T, UserModuleUpsertArgs<ExtArgs>>): Prisma__UserModuleClient<$Result.GetResult<Prisma.$UserModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleCountArgs} args - Arguments to filter UserModules to count.
     * @example
     * // Count the number of UserModules
     * const count = await prisma.userModule.count({
     *   where: {
     *     // ... the filter for the UserModules we want to count
     *   }
     * })
    **/
    count<T extends UserModuleCountArgs>(
      args?: Subset<T, UserModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserModuleAggregateArgs>(args: Subset<T, UserModuleAggregateArgs>): Prisma.PrismaPromise<GetUserModuleAggregateType<T>>

    /**
     * Group by UserModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserModuleGroupByArgs['orderBy'] }
        : { orderBy?: UserModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserModule model
   */
  readonly fields: UserModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userCourse<T extends UserCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserCourseDefaultArgs<ExtArgs>>): Prisma__UserCourseClient<$Result.GetResult<Prisma.$UserCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserModule model
   */
  interface UserModuleFieldRefs {
    readonly id: FieldRef<"UserModule", 'String'>
    readonly userCourseId: FieldRef<"UserModule", 'String'>
    readonly moduleId: FieldRef<"UserModule", 'String'>
    readonly completed: FieldRef<"UserModule", 'Boolean'>
    readonly score: FieldRef<"UserModule", 'Int'>
    readonly createdAt: FieldRef<"UserModule", 'DateTime'>
    readonly updatedAt: FieldRef<"UserModule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserModule findUnique
   */
  export type UserModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserModule to fetch.
     */
    where: UserModuleWhereUniqueInput
  }

  /**
   * UserModule findUniqueOrThrow
   */
  export type UserModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserModule to fetch.
     */
    where: UserModuleWhereUniqueInput
  }

  /**
   * UserModule findFirst
   */
  export type UserModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserModule to fetch.
     */
    where?: UserModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModules to fetch.
     */
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModules.
     */
    cursor?: UserModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModules.
     */
    distinct?: UserModuleScalarFieldEnum | UserModuleScalarFieldEnum[]
  }

  /**
   * UserModule findFirstOrThrow
   */
  export type UserModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserModule to fetch.
     */
    where?: UserModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModules to fetch.
     */
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserModules.
     */
    cursor?: UserModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserModules.
     */
    distinct?: UserModuleScalarFieldEnum | UserModuleScalarFieldEnum[]
  }

  /**
   * UserModule findMany
   */
  export type UserModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter, which UserModules to fetch.
     */
    where?: UserModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserModules to fetch.
     */
    orderBy?: UserModuleOrderByWithRelationInput | UserModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserModules.
     */
    cursor?: UserModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserModules.
     */
    skip?: number
    distinct?: UserModuleScalarFieldEnum | UserModuleScalarFieldEnum[]
  }

  /**
   * UserModule create
   */
  export type UserModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserModule.
     */
    data: XOR<UserModuleCreateInput, UserModuleUncheckedCreateInput>
  }

  /**
   * UserModule createMany
   */
  export type UserModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserModules.
     */
    data: UserModuleCreateManyInput | UserModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserModule createManyAndReturn
   */
  export type UserModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * The data used to create many UserModules.
     */
    data: UserModuleCreateManyInput | UserModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserModule update
   */
  export type UserModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserModule.
     */
    data: XOR<UserModuleUpdateInput, UserModuleUncheckedUpdateInput>
    /**
     * Choose, which UserModule to update.
     */
    where: UserModuleWhereUniqueInput
  }

  /**
   * UserModule updateMany
   */
  export type UserModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserModules.
     */
    data: XOR<UserModuleUpdateManyMutationInput, UserModuleUncheckedUpdateManyInput>
    /**
     * Filter which UserModules to update
     */
    where?: UserModuleWhereInput
    /**
     * Limit how many UserModules to update.
     */
    limit?: number
  }

  /**
   * UserModule updateManyAndReturn
   */
  export type UserModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * The data used to update UserModules.
     */
    data: XOR<UserModuleUpdateManyMutationInput, UserModuleUncheckedUpdateManyInput>
    /**
     * Filter which UserModules to update
     */
    where?: UserModuleWhereInput
    /**
     * Limit how many UserModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserModule upsert
   */
  export type UserModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserModule to update in case it exists.
     */
    where: UserModuleWhereUniqueInput
    /**
     * In case the UserModule found by the `where` argument doesn't exist, create a new UserModule with this data.
     */
    create: XOR<UserModuleCreateInput, UserModuleUncheckedCreateInput>
    /**
     * In case the UserModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserModuleUpdateInput, UserModuleUncheckedUpdateInput>
  }

  /**
   * UserModule delete
   */
  export type UserModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
    /**
     * Filter which UserModule to delete.
     */
    where: UserModuleWhereUniqueInput
  }

  /**
   * UserModule deleteMany
   */
  export type UserModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserModules to delete
     */
    where?: UserModuleWhereInput
    /**
     * Limit how many UserModules to delete.
     */
    limit?: number
  }

  /**
   * UserModule without action
   */
  export type UserModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserModule
     */
    select?: UserModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserModule
     */
    omit?: UserModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserModuleInclude<ExtArgs> | null
  }


  /**
   * Model UserResponse
   */

  export type AggregateUserResponse = {
    _count: UserResponseCountAggregateOutputType | null
    _avg: UserResponseAvgAggregateOutputType | null
    _sum: UserResponseSumAggregateOutputType | null
    _min: UserResponseMinAggregateOutputType | null
    _max: UserResponseMaxAggregateOutputType | null
  }

  export type UserResponseAvgAggregateOutputType = {
    score: number | null
  }

  export type UserResponseSumAggregateOutputType = {
    score: number | null
  }

  export type UserResponseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    scenarioId: string | null
    questionId: string | null
    isCorrect: boolean | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserResponseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    scenarioId: string | null
    questionId: string | null
    isCorrect: boolean | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserResponseCountAggregateOutputType = {
    id: number
    userId: number
    scenarioId: number
    questionId: number
    selectedAnswers: number
    isCorrect: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserResponseAvgAggregateInputType = {
    score?: true
  }

  export type UserResponseSumAggregateInputType = {
    score?: true
  }

  export type UserResponseMinAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    questionId?: true
    isCorrect?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserResponseMaxAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    questionId?: true
    isCorrect?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserResponseCountAggregateInputType = {
    id?: true
    userId?: true
    scenarioId?: true
    questionId?: true
    selectedAnswers?: true
    isCorrect?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserResponse to aggregate.
     */
    where?: UserResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserResponses to fetch.
     */
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserResponses
    **/
    _count?: true | UserResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserResponseMaxAggregateInputType
  }

  export type GetUserResponseAggregateType<T extends UserResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateUserResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserResponse[P]>
      : GetScalarType<T[P], AggregateUserResponse[P]>
  }




  export type UserResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserResponseWhereInput
    orderBy?: UserResponseOrderByWithAggregationInput | UserResponseOrderByWithAggregationInput[]
    by: UserResponseScalarFieldEnum[] | UserResponseScalarFieldEnum
    having?: UserResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserResponseCountAggregateInputType | true
    _avg?: UserResponseAvgAggregateInputType
    _sum?: UserResponseSumAggregateInputType
    _min?: UserResponseMinAggregateInputType
    _max?: UserResponseMaxAggregateInputType
  }

  export type UserResponseGroupByOutputType = {
    id: string
    userId: string
    scenarioId: string
    questionId: string
    selectedAnswers: string[]
    isCorrect: boolean
    score: number
    createdAt: Date
    updatedAt: Date
    _count: UserResponseCountAggregateOutputType | null
    _avg: UserResponseAvgAggregateOutputType | null
    _sum: UserResponseSumAggregateOutputType | null
    _min: UserResponseMinAggregateOutputType | null
    _max: UserResponseMaxAggregateOutputType | null
  }

  type GetUserResponseGroupByPayload<T extends UserResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserResponseGroupByOutputType[P]>
            : GetScalarType<T[P], UserResponseGroupByOutputType[P]>
        }
      >
    >


  export type UserResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    questionId?: boolean
    selectedAnswers?: boolean
    isCorrect?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userResponse"]>

  export type UserResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    questionId?: boolean
    selectedAnswers?: boolean
    isCorrect?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userResponse"]>

  export type UserResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    questionId?: boolean
    selectedAnswers?: boolean
    isCorrect?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userResponse"]>

  export type UserResponseSelectScalar = {
    id?: boolean
    userId?: boolean
    scenarioId?: boolean
    questionId?: boolean
    selectedAnswers?: boolean
    isCorrect?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "scenarioId" | "questionId" | "selectedAnswers" | "isCorrect" | "score" | "createdAt" | "updatedAt", ExtArgs["result"]["userResponse"]>
  export type UserResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }
  export type UserResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }
  export type UserResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    scenario?: boolean | ScenarioDefaultArgs<ExtArgs>
  }

  export type $UserResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserResponse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      scenario: Prisma.$ScenarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      scenarioId: string
      questionId: string
      selectedAnswers: string[]
      isCorrect: boolean
      score: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userResponse"]>
    composites: {}
  }

  type UserResponseGetPayload<S extends boolean | null | undefined | UserResponseDefaultArgs> = $Result.GetResult<Prisma.$UserResponsePayload, S>

  type UserResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserResponseCountAggregateInputType | true
    }

  export interface UserResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserResponse'], meta: { name: 'UserResponse' } }
    /**
     * Find zero or one UserResponse that matches the filter.
     * @param {UserResponseFindUniqueArgs} args - Arguments to find a UserResponse
     * @example
     * // Get one UserResponse
     * const userResponse = await prisma.userResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserResponseFindUniqueArgs>(args: SelectSubset<T, UserResponseFindUniqueArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserResponseFindUniqueOrThrowArgs} args - Arguments to find a UserResponse
     * @example
     * // Get one UserResponse
     * const userResponse = await prisma.userResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, UserResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseFindFirstArgs} args - Arguments to find a UserResponse
     * @example
     * // Get one UserResponse
     * const userResponse = await prisma.userResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserResponseFindFirstArgs>(args?: SelectSubset<T, UserResponseFindFirstArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseFindFirstOrThrowArgs} args - Arguments to find a UserResponse
     * @example
     * // Get one UserResponse
     * const userResponse = await prisma.userResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, UserResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserResponses
     * const userResponses = await prisma.userResponse.findMany()
     * 
     * // Get first 10 UserResponses
     * const userResponses = await prisma.userResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userResponseWithIdOnly = await prisma.userResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserResponseFindManyArgs>(args?: SelectSubset<T, UserResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserResponse.
     * @param {UserResponseCreateArgs} args - Arguments to create a UserResponse.
     * @example
     * // Create one UserResponse
     * const UserResponse = await prisma.userResponse.create({
     *   data: {
     *     // ... data to create a UserResponse
     *   }
     * })
     * 
     */
    create<T extends UserResponseCreateArgs>(args: SelectSubset<T, UserResponseCreateArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserResponses.
     * @param {UserResponseCreateManyArgs} args - Arguments to create many UserResponses.
     * @example
     * // Create many UserResponses
     * const userResponse = await prisma.userResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserResponseCreateManyArgs>(args?: SelectSubset<T, UserResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserResponses and returns the data saved in the database.
     * @param {UserResponseCreateManyAndReturnArgs} args - Arguments to create many UserResponses.
     * @example
     * // Create many UserResponses
     * const userResponse = await prisma.userResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserResponses and only return the `id`
     * const userResponseWithIdOnly = await prisma.userResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, UserResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserResponse.
     * @param {UserResponseDeleteArgs} args - Arguments to delete one UserResponse.
     * @example
     * // Delete one UserResponse
     * const UserResponse = await prisma.userResponse.delete({
     *   where: {
     *     // ... filter to delete one UserResponse
     *   }
     * })
     * 
     */
    delete<T extends UserResponseDeleteArgs>(args: SelectSubset<T, UserResponseDeleteArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserResponse.
     * @param {UserResponseUpdateArgs} args - Arguments to update one UserResponse.
     * @example
     * // Update one UserResponse
     * const userResponse = await prisma.userResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserResponseUpdateArgs>(args: SelectSubset<T, UserResponseUpdateArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserResponses.
     * @param {UserResponseDeleteManyArgs} args - Arguments to filter UserResponses to delete.
     * @example
     * // Delete a few UserResponses
     * const { count } = await prisma.userResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserResponseDeleteManyArgs>(args?: SelectSubset<T, UserResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserResponses
     * const userResponse = await prisma.userResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserResponseUpdateManyArgs>(args: SelectSubset<T, UserResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserResponses and returns the data updated in the database.
     * @param {UserResponseUpdateManyAndReturnArgs} args - Arguments to update many UserResponses.
     * @example
     * // Update many UserResponses
     * const userResponse = await prisma.userResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserResponses and only return the `id`
     * const userResponseWithIdOnly = await prisma.userResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, UserResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserResponse.
     * @param {UserResponseUpsertArgs} args - Arguments to update or create a UserResponse.
     * @example
     * // Update or create a UserResponse
     * const userResponse = await prisma.userResponse.upsert({
     *   create: {
     *     // ... data to create a UserResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserResponse we want to update
     *   }
     * })
     */
    upsert<T extends UserResponseUpsertArgs>(args: SelectSubset<T, UserResponseUpsertArgs<ExtArgs>>): Prisma__UserResponseClient<$Result.GetResult<Prisma.$UserResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseCountArgs} args - Arguments to filter UserResponses to count.
     * @example
     * // Count the number of UserResponses
     * const count = await prisma.userResponse.count({
     *   where: {
     *     // ... the filter for the UserResponses we want to count
     *   }
     * })
    **/
    count<T extends UserResponseCountArgs>(
      args?: Subset<T, UserResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserResponseAggregateArgs>(args: Subset<T, UserResponseAggregateArgs>): Prisma.PrismaPromise<GetUserResponseAggregateType<T>>

    /**
     * Group by UserResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserResponseGroupByArgs['orderBy'] }
        : { orderBy?: UserResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserResponse model
   */
  readonly fields: UserResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scenario<T extends ScenarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScenarioDefaultArgs<ExtArgs>>): Prisma__ScenarioClient<$Result.GetResult<Prisma.$ScenarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserResponse model
   */
  interface UserResponseFieldRefs {
    readonly id: FieldRef<"UserResponse", 'String'>
    readonly userId: FieldRef<"UserResponse", 'String'>
    readonly scenarioId: FieldRef<"UserResponse", 'String'>
    readonly questionId: FieldRef<"UserResponse", 'String'>
    readonly selectedAnswers: FieldRef<"UserResponse", 'String[]'>
    readonly isCorrect: FieldRef<"UserResponse", 'Boolean'>
    readonly score: FieldRef<"UserResponse", 'Int'>
    readonly createdAt: FieldRef<"UserResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"UserResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserResponse findUnique
   */
  export type UserResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter, which UserResponse to fetch.
     */
    where: UserResponseWhereUniqueInput
  }

  /**
   * UserResponse findUniqueOrThrow
   */
  export type UserResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter, which UserResponse to fetch.
     */
    where: UserResponseWhereUniqueInput
  }

  /**
   * UserResponse findFirst
   */
  export type UserResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter, which UserResponse to fetch.
     */
    where?: UserResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserResponses to fetch.
     */
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserResponses.
     */
    cursor?: UserResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserResponses.
     */
    distinct?: UserResponseScalarFieldEnum | UserResponseScalarFieldEnum[]
  }

  /**
   * UserResponse findFirstOrThrow
   */
  export type UserResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter, which UserResponse to fetch.
     */
    where?: UserResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserResponses to fetch.
     */
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserResponses.
     */
    cursor?: UserResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserResponses.
     */
    distinct?: UserResponseScalarFieldEnum | UserResponseScalarFieldEnum[]
  }

  /**
   * UserResponse findMany
   */
  export type UserResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter, which UserResponses to fetch.
     */
    where?: UserResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserResponses to fetch.
     */
    orderBy?: UserResponseOrderByWithRelationInput | UserResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserResponses.
     */
    cursor?: UserResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserResponses.
     */
    skip?: number
    distinct?: UserResponseScalarFieldEnum | UserResponseScalarFieldEnum[]
  }

  /**
   * UserResponse create
   */
  export type UserResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a UserResponse.
     */
    data: XOR<UserResponseCreateInput, UserResponseUncheckedCreateInput>
  }

  /**
   * UserResponse createMany
   */
  export type UserResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserResponses.
     */
    data: UserResponseCreateManyInput | UserResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserResponse createManyAndReturn
   */
  export type UserResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * The data used to create many UserResponses.
     */
    data: UserResponseCreateManyInput | UserResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserResponse update
   */
  export type UserResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a UserResponse.
     */
    data: XOR<UserResponseUpdateInput, UserResponseUncheckedUpdateInput>
    /**
     * Choose, which UserResponse to update.
     */
    where: UserResponseWhereUniqueInput
  }

  /**
   * UserResponse updateMany
   */
  export type UserResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserResponses.
     */
    data: XOR<UserResponseUpdateManyMutationInput, UserResponseUncheckedUpdateManyInput>
    /**
     * Filter which UserResponses to update
     */
    where?: UserResponseWhereInput
    /**
     * Limit how many UserResponses to update.
     */
    limit?: number
  }

  /**
   * UserResponse updateManyAndReturn
   */
  export type UserResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * The data used to update UserResponses.
     */
    data: XOR<UserResponseUpdateManyMutationInput, UserResponseUncheckedUpdateManyInput>
    /**
     * Filter which UserResponses to update
     */
    where?: UserResponseWhereInput
    /**
     * Limit how many UserResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserResponse upsert
   */
  export type UserResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the UserResponse to update in case it exists.
     */
    where: UserResponseWhereUniqueInput
    /**
     * In case the UserResponse found by the `where` argument doesn't exist, create a new UserResponse with this data.
     */
    create: XOR<UserResponseCreateInput, UserResponseUncheckedCreateInput>
    /**
     * In case the UserResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserResponseUpdateInput, UserResponseUncheckedUpdateInput>
  }

  /**
   * UserResponse delete
   */
  export type UserResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
    /**
     * Filter which UserResponse to delete.
     */
    where: UserResponseWhereUniqueInput
  }

  /**
   * UserResponse deleteMany
   */
  export type UserResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserResponses to delete
     */
    where?: UserResponseWhereInput
    /**
     * Limit how many UserResponses to delete.
     */
    limit?: number
  }

  /**
   * UserResponse without action
   */
  export type UserResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserResponse
     */
    select?: UserResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserResponse
     */
    omit?: UserResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserResponseInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    achievementId: string | null
    title: string | null
    description: string | null
    iconName: string | null
    criteria: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    achievementId: string | null
    title: string | null
    description: string | null
    iconName: string | null
    criteria: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    achievementId: number
    title: number
    description: number
    iconName: number
    criteria: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementMinAggregateInputType = {
    id?: true
    achievementId?: true
    title?: true
    description?: true
    iconName?: true
    criteria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    achievementId?: true
    title?: true
    description?: true
    iconName?: true
    criteria?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    achievementId?: true
    title?: true
    description?: true
    iconName?: true
    criteria?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    title?: boolean
    description?: boolean
    iconName?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    title?: boolean
    description?: boolean
    iconName?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    achievementId?: boolean
    title?: boolean
    description?: boolean
    iconName?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    achievementId?: boolean
    title?: boolean
    description?: boolean
    iconName?: boolean
    criteria?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "achievementId" | "title" | "description" | "iconName" | "criteria" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      achievementId: string
      title: string
      description: string
      iconName: string
      criteria: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly achievementId: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly iconName: FieldRef<"Achievement", 'String'>
    readonly criteria: FieldRef<"Achievement", 'String'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    unlockedAt: Date | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    unlockedAt: Date | null
    data: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    unlockedAt: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    data?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    unlockedAt: Date
    data: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "unlockedAt" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      unlockedAt: Date
      data: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly data: FieldRef<"UserAchievement", 'String'>
    readonly createdAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsAvgAggregateOutputType = {
    totalTimeSpent: number | null
    sessionsCompleted: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type UserStatsSumAggregateOutputType = {
    totalTimeSpent: number | null
    sessionsCompleted: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalTimeSpent: number | null
    sessionsCompleted: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    lastActivity: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalTimeSpent: number | null
    sessionsCompleted: number | null
    questionsAnswered: number | null
    correctAnswers: number | null
    lastActivity: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    userId: number
    totalTimeSpent: number
    sessionsCompleted: number
    questionsAnswered: number
    correctAnswers: number
    lastActivity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserStatsAvgAggregateInputType = {
    totalTimeSpent?: true
    sessionsCompleted?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type UserStatsSumAggregateInputType = {
    totalTimeSpent?: true
    sessionsCompleted?: true
    questionsAnswered?: true
    correctAnswers?: true
  }

  export type UserStatsMinAggregateInputType = {
    id?: true
    userId?: true
    totalTimeSpent?: true
    sessionsCompleted?: true
    questionsAnswered?: true
    correctAnswers?: true
    lastActivity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalTimeSpent?: true
    sessionsCompleted?: true
    questionsAnswered?: true
    correctAnswers?: true
    lastActivity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    userId?: true
    totalTimeSpent?: true
    sessionsCompleted?: true
    questionsAnswered?: true
    correctAnswers?: true
    lastActivity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _avg?: UserStatsAvgAggregateInputType
    _sum?: UserStatsSumAggregateInputType
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: string
    userId: string
    totalTimeSpent: number
    sessionsCompleted: number
    questionsAnswered: number
    correctAnswers: number
    lastActivity: Date
    createdAt: Date
    updatedAt: Date
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalTimeSpent?: boolean
    sessionsCompleted?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalTimeSpent?: boolean
    sessionsCompleted?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalTimeSpent?: boolean
    sessionsCompleted?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalTimeSpent?: boolean
    sessionsCompleted?: boolean
    questionsAnswered?: boolean
    correctAnswers?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalTimeSpent" | "sessionsCompleted" | "questionsAnswered" | "correctAnswers" | "lastActivity" | "createdAt" | "updatedAt", ExtArgs["result"]["userStats"]>
  export type UserStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalTimeSpent: number
      sessionsCompleted: number
      questionsAnswered: number
      correctAnswers: number
      lastActivity: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }

  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatsFindUniqueArgs>(args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatsFindFirstArgs>(args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatsFindManyArgs>(args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
     */
    create<T extends UserStatsCreateArgs>(args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStats.
     * @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatsCreateManyArgs>(args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStats and returns the data saved in the database.
     * @param {UserStatsCreateManyAndReturnArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
     */
    delete<T extends UserStatsDeleteArgs>(args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatsUpdateArgs>(args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatsDeleteManyArgs>(args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatsUpdateManyArgs>(args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats and returns the data updated in the database.
     * @param {UserStatsUpdateManyAndReturnArgs} args - Arguments to update many UserStats.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
     */
    upsert<T extends UserStatsUpsertArgs>(args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStats model
   */
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'String'>
    readonly userId: FieldRef<"UserStats", 'String'>
    readonly totalTimeSpent: FieldRef<"UserStats", 'Int'>
    readonly sessionsCompleted: FieldRef<"UserStats", 'Int'>
    readonly questionsAnswered: FieldRef<"UserStats", 'Int'>
    readonly correctAnswers: FieldRef<"UserStats", 'Int'>
    readonly lastActivity: FieldRef<"UserStats", 'DateTime'>
    readonly createdAt: FieldRef<"UserStats", 'DateTime'>
    readonly updatedAt: FieldRef<"UserStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }

  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStats createManyAndReturn
   */
  export type UserStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
  }

  /**
   * UserStats updateManyAndReturn
   */
  export type UserStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }

  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
    /**
     * Limit how many UserStats to delete.
     */
    limit?: number
  }

  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStats
     */
    omit?: UserStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type UserSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    courseId: string | null
    modulesViewed: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    courseId: string | null
    modulesViewed: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    startTime: number
    endTime: number
    duration: number
    courseId: number
    modulesViewed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionAvgAggregateInputType = {
    duration?: true
  }

  export type UserSessionSumAggregateInputType = {
    duration?: true
  }

  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    courseId?: true
    modulesViewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    courseId?: true
    modulesViewed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    startTime?: true
    endTime?: true
    duration?: true
    courseId?: true
    modulesViewed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _avg?: UserSessionAvgAggregateInputType
    _sum?: UserSessionSumAggregateInputType
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    startTime: Date
    endTime: Date | null
    duration: number | null
    courseId: string | null
    modulesViewed: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _avg: UserSessionAvgAggregateOutputType | null
    _sum: UserSessionSumAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    courseId?: boolean
    modulesViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    courseId?: boolean
    modulesViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    courseId?: boolean
    modulesViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    courseId?: boolean
    modulesViewed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startTime" | "endTime" | "duration" | "courseId" | "modulesViewed" | "createdAt" | "updatedAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | UserSession$courseArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startTime: Date
      endTime: Date | null
      duration: number | null
      courseId: string | null
      modulesViewed: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends UserSession$courseArgs<ExtArgs> = {}>(args?: Subset<T, UserSession$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly startTime: FieldRef<"UserSession", 'DateTime'>
    readonly endTime: FieldRef<"UserSession", 'DateTime'>
    readonly duration: FieldRef<"UserSession", 'Int'>
    readonly courseId: FieldRef<"UserSession", 'String'>
    readonly modulesViewed: FieldRef<"UserSession", 'String'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession.course
   */
  export type UserSession$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    azureContainer: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    azureContainer: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logoUrl: number
    azureContainer: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    azureContainer?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    azureContainer?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logoUrl?: true
    azureContainer?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    logoUrl: string | null
    azureContainer: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    azureContainer?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    trainings?: boolean | Organization$trainingsArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    tags?: boolean | Organization$tagsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    azureContainer?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    azureContainer?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    azureContainer?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "logoUrl" | "azureContainer" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    trainings?: boolean | Organization$trainingsArgs<ExtArgs>
    invitations?: boolean | Organization$invitationsArgs<ExtArgs>
    tags?: boolean | Organization$tagsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      trainings: Prisma.$OrganizationTrainingPayload<ExtArgs>[]
      invitations: Prisma.$OrganizationInvitationPayload<ExtArgs>[]
      tags: Prisma.$OrganizationTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      logoUrl: string | null
      azureContainer: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings<T extends Organization$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Organization$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Organization$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly description: FieldRef<"Organization", 'String'>
    readonly logoUrl: FieldRef<"Organization", 'String'>
    readonly azureContainer: FieldRef<"Organization", 'String'>
    readonly isActive: FieldRef<"Organization", 'Boolean'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * Organization.trainings
   */
  export type Organization$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    where?: OrganizationTrainingWhereInput
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    cursor?: OrganizationTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationTrainingScalarFieldEnum | OrganizationTrainingScalarFieldEnum[]
  }

  /**
   * Organization.invitations
   */
  export type Organization$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    where?: OrganizationInvitationWhereInput
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    cursor?: OrganizationInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * Organization.tags
   */
  export type Organization$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    where?: OrganizationTagWhereInput
    orderBy?: OrganizationTagOrderByWithRelationInput | OrganizationTagOrderByWithRelationInput[]
    cursor?: OrganizationTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationTagScalarFieldEnum | OrganizationTagScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: string | null
    joinedAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    joinedAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: string
    joinedAt: Date
    updatedAt: Date
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "role" | "joinedAt" | "updatedAt", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: string
      joinedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly organizationId: FieldRef<"OrganizationMember", 'String'>
    readonly userId: FieldRef<"OrganizationMember", 'String'>
    readonly role: FieldRef<"OrganizationMember", 'String'>
    readonly joinedAt: FieldRef<"OrganizationMember", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationTraining
   */

  export type AggregateOrganizationTraining = {
    _count: OrganizationTrainingCountAggregateOutputType | null
    _min: OrganizationTrainingMinAggregateOutputType | null
    _max: OrganizationTrainingMaxAggregateOutputType | null
  }

  export type OrganizationTrainingMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    courseId: string | null
    buildId: string | null
    isCustomBuild: boolean | null
    isActive: boolean | null
    assignedAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationTrainingMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    courseId: string | null
    buildId: string | null
    isCustomBuild: boolean | null
    isActive: boolean | null
    assignedAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationTrainingCountAggregateOutputType = {
    id: number
    organizationId: number
    courseId: number
    buildId: number
    isCustomBuild: number
    isActive: number
    assignedAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationTrainingMinAggregateInputType = {
    id?: true
    organizationId?: true
    courseId?: true
    buildId?: true
    isCustomBuild?: true
    isActive?: true
    assignedAt?: true
    updatedAt?: true
  }

  export type OrganizationTrainingMaxAggregateInputType = {
    id?: true
    organizationId?: true
    courseId?: true
    buildId?: true
    isCustomBuild?: true
    isActive?: true
    assignedAt?: true
    updatedAt?: true
  }

  export type OrganizationTrainingCountAggregateInputType = {
    id?: true
    organizationId?: true
    courseId?: true
    buildId?: true
    isCustomBuild?: true
    isActive?: true
    assignedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTraining to aggregate.
     */
    where?: OrganizationTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTrainings to fetch.
     */
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationTrainings
    **/
    _count?: true | OrganizationTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationTrainingMaxAggregateInputType
  }

  export type GetOrganizationTrainingAggregateType<T extends OrganizationTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationTraining[P]>
      : GetScalarType<T[P], AggregateOrganizationTraining[P]>
  }




  export type OrganizationTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationTrainingWhereInput
    orderBy?: OrganizationTrainingOrderByWithAggregationInput | OrganizationTrainingOrderByWithAggregationInput[]
    by: OrganizationTrainingScalarFieldEnum[] | OrganizationTrainingScalarFieldEnum
    having?: OrganizationTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationTrainingCountAggregateInputType | true
    _min?: OrganizationTrainingMinAggregateInputType
    _max?: OrganizationTrainingMaxAggregateInputType
  }

  export type OrganizationTrainingGroupByOutputType = {
    id: string
    organizationId: string
    courseId: string
    buildId: string | null
    isCustomBuild: boolean
    isActive: boolean
    assignedAt: Date
    updatedAt: Date
    _count: OrganizationTrainingCountAggregateOutputType | null
    _min: OrganizationTrainingMinAggregateOutputType | null
    _max: OrganizationTrainingMaxAggregateOutputType | null
  }

  type GetOrganizationTrainingGroupByPayload<T extends OrganizationTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationTrainingGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    courseId?: boolean
    buildId?: boolean
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTraining"]>

  export type OrganizationTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    courseId?: boolean
    buildId?: boolean
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTraining"]>

  export type OrganizationTrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    courseId?: boolean
    buildId?: boolean
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTraining"]>

  export type OrganizationTrainingSelectScalar = {
    id?: boolean
    organizationId?: boolean
    courseId?: boolean
    buildId?: boolean
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationTrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "courseId" | "buildId" | "isCustomBuild" | "isActive" | "assignedAt" | "updatedAt", ExtArgs["result"]["organizationTraining"]>
  export type OrganizationTrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type OrganizationTrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type OrganizationTrainingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $OrganizationTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationTraining"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      courseId: string
      buildId: string | null
      isCustomBuild: boolean
      isActive: boolean
      assignedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationTraining"]>
    composites: {}
  }

  type OrganizationTrainingGetPayload<S extends boolean | null | undefined | OrganizationTrainingDefaultArgs> = $Result.GetResult<Prisma.$OrganizationTrainingPayload, S>

  type OrganizationTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationTrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationTrainingCountAggregateInputType | true
    }

  export interface OrganizationTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationTraining'], meta: { name: 'OrganizationTraining' } }
    /**
     * Find zero or one OrganizationTraining that matches the filter.
     * @param {OrganizationTrainingFindUniqueArgs} args - Arguments to find a OrganizationTraining
     * @example
     * // Get one OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationTrainingFindUniqueArgs>(args: SelectSubset<T, OrganizationTrainingFindUniqueArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationTraining that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationTrainingFindUniqueOrThrowArgs} args - Arguments to find a OrganizationTraining
     * @example
     * // Get one OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingFindFirstArgs} args - Arguments to find a OrganizationTraining
     * @example
     * // Get one OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationTrainingFindFirstArgs>(args?: SelectSubset<T, OrganizationTrainingFindFirstArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingFindFirstOrThrowArgs} args - Arguments to find a OrganizationTraining
     * @example
     * // Get one OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationTrainings
     * const organizationTrainings = await prisma.organizationTraining.findMany()
     * 
     * // Get first 10 OrganizationTrainings
     * const organizationTrainings = await prisma.organizationTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationTrainingWithIdOnly = await prisma.organizationTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationTrainingFindManyArgs>(args?: SelectSubset<T, OrganizationTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationTraining.
     * @param {OrganizationTrainingCreateArgs} args - Arguments to create a OrganizationTraining.
     * @example
     * // Create one OrganizationTraining
     * const OrganizationTraining = await prisma.organizationTraining.create({
     *   data: {
     *     // ... data to create a OrganizationTraining
     *   }
     * })
     * 
     */
    create<T extends OrganizationTrainingCreateArgs>(args: SelectSubset<T, OrganizationTrainingCreateArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationTrainings.
     * @param {OrganizationTrainingCreateManyArgs} args - Arguments to create many OrganizationTrainings.
     * @example
     * // Create many OrganizationTrainings
     * const organizationTraining = await prisma.organizationTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationTrainingCreateManyArgs>(args?: SelectSubset<T, OrganizationTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationTrainings and returns the data saved in the database.
     * @param {OrganizationTrainingCreateManyAndReturnArgs} args - Arguments to create many OrganizationTrainings.
     * @example
     * // Create many OrganizationTrainings
     * const organizationTraining = await prisma.organizationTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationTrainings and only return the `id`
     * const organizationTrainingWithIdOnly = await prisma.organizationTraining.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationTraining.
     * @param {OrganizationTrainingDeleteArgs} args - Arguments to delete one OrganizationTraining.
     * @example
     * // Delete one OrganizationTraining
     * const OrganizationTraining = await prisma.organizationTraining.delete({
     *   where: {
     *     // ... filter to delete one OrganizationTraining
     *   }
     * })
     * 
     */
    delete<T extends OrganizationTrainingDeleteArgs>(args: SelectSubset<T, OrganizationTrainingDeleteArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationTraining.
     * @param {OrganizationTrainingUpdateArgs} args - Arguments to update one OrganizationTraining.
     * @example
     * // Update one OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationTrainingUpdateArgs>(args: SelectSubset<T, OrganizationTrainingUpdateArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationTrainings.
     * @param {OrganizationTrainingDeleteManyArgs} args - Arguments to filter OrganizationTrainings to delete.
     * @example
     * // Delete a few OrganizationTrainings
     * const { count } = await prisma.organizationTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationTrainingDeleteManyArgs>(args?: SelectSubset<T, OrganizationTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationTrainings
     * const organizationTraining = await prisma.organizationTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationTrainingUpdateManyArgs>(args: SelectSubset<T, OrganizationTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationTrainings and returns the data updated in the database.
     * @param {OrganizationTrainingUpdateManyAndReturnArgs} args - Arguments to update many OrganizationTrainings.
     * @example
     * // Update many OrganizationTrainings
     * const organizationTraining = await prisma.organizationTraining.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationTrainings and only return the `id`
     * const organizationTrainingWithIdOnly = await prisma.organizationTraining.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationTrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationTrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationTraining.
     * @param {OrganizationTrainingUpsertArgs} args - Arguments to update or create a OrganizationTraining.
     * @example
     * // Update or create a OrganizationTraining
     * const organizationTraining = await prisma.organizationTraining.upsert({
     *   create: {
     *     // ... data to create a OrganizationTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationTraining we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationTrainingUpsertArgs>(args: SelectSubset<T, OrganizationTrainingUpsertArgs<ExtArgs>>): Prisma__OrganizationTrainingClient<$Result.GetResult<Prisma.$OrganizationTrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingCountArgs} args - Arguments to filter OrganizationTrainings to count.
     * @example
     * // Count the number of OrganizationTrainings
     * const count = await prisma.organizationTraining.count({
     *   where: {
     *     // ... the filter for the OrganizationTrainings we want to count
     *   }
     * })
    **/
    count<T extends OrganizationTrainingCountArgs>(
      args?: Subset<T, OrganizationTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationTrainingAggregateArgs>(args: Subset<T, OrganizationTrainingAggregateArgs>): Prisma.PrismaPromise<GetOrganizationTrainingAggregateType<T>>

    /**
     * Group by OrganizationTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationTrainingGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationTraining model
   */
  readonly fields: OrganizationTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationTraining model
   */
  interface OrganizationTrainingFieldRefs {
    readonly id: FieldRef<"OrganizationTraining", 'String'>
    readonly organizationId: FieldRef<"OrganizationTraining", 'String'>
    readonly courseId: FieldRef<"OrganizationTraining", 'String'>
    readonly buildId: FieldRef<"OrganizationTraining", 'String'>
    readonly isCustomBuild: FieldRef<"OrganizationTraining", 'Boolean'>
    readonly isActive: FieldRef<"OrganizationTraining", 'Boolean'>
    readonly assignedAt: FieldRef<"OrganizationTraining", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationTraining", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationTraining findUnique
   */
  export type OrganizationTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTraining to fetch.
     */
    where: OrganizationTrainingWhereUniqueInput
  }

  /**
   * OrganizationTraining findUniqueOrThrow
   */
  export type OrganizationTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTraining to fetch.
     */
    where: OrganizationTrainingWhereUniqueInput
  }

  /**
   * OrganizationTraining findFirst
   */
  export type OrganizationTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTraining to fetch.
     */
    where?: OrganizationTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTrainings to fetch.
     */
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTrainings.
     */
    cursor?: OrganizationTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTrainings.
     */
    distinct?: OrganizationTrainingScalarFieldEnum | OrganizationTrainingScalarFieldEnum[]
  }

  /**
   * OrganizationTraining findFirstOrThrow
   */
  export type OrganizationTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTraining to fetch.
     */
    where?: OrganizationTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTrainings to fetch.
     */
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTrainings.
     */
    cursor?: OrganizationTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTrainings.
     */
    distinct?: OrganizationTrainingScalarFieldEnum | OrganizationTrainingScalarFieldEnum[]
  }

  /**
   * OrganizationTraining findMany
   */
  export type OrganizationTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTrainings to fetch.
     */
    where?: OrganizationTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTrainings to fetch.
     */
    orderBy?: OrganizationTrainingOrderByWithRelationInput | OrganizationTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationTrainings.
     */
    cursor?: OrganizationTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTrainings.
     */
    skip?: number
    distinct?: OrganizationTrainingScalarFieldEnum | OrganizationTrainingScalarFieldEnum[]
  }

  /**
   * OrganizationTraining create
   */
  export type OrganizationTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationTraining.
     */
    data: XOR<OrganizationTrainingCreateInput, OrganizationTrainingUncheckedCreateInput>
  }

  /**
   * OrganizationTraining createMany
   */
  export type OrganizationTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationTrainings.
     */
    data: OrganizationTrainingCreateManyInput | OrganizationTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationTraining createManyAndReturn
   */
  export type OrganizationTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationTrainings.
     */
    data: OrganizationTrainingCreateManyInput | OrganizationTrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationTraining update
   */
  export type OrganizationTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationTraining.
     */
    data: XOR<OrganizationTrainingUpdateInput, OrganizationTrainingUncheckedUpdateInput>
    /**
     * Choose, which OrganizationTraining to update.
     */
    where: OrganizationTrainingWhereUniqueInput
  }

  /**
   * OrganizationTraining updateMany
   */
  export type OrganizationTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationTrainings.
     */
    data: XOR<OrganizationTrainingUpdateManyMutationInput, OrganizationTrainingUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationTrainings to update
     */
    where?: OrganizationTrainingWhereInput
    /**
     * Limit how many OrganizationTrainings to update.
     */
    limit?: number
  }

  /**
   * OrganizationTraining updateManyAndReturn
   */
  export type OrganizationTrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationTrainings.
     */
    data: XOR<OrganizationTrainingUpdateManyMutationInput, OrganizationTrainingUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationTrainings to update
     */
    where?: OrganizationTrainingWhereInput
    /**
     * Limit how many OrganizationTrainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationTraining upsert
   */
  export type OrganizationTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationTraining to update in case it exists.
     */
    where: OrganizationTrainingWhereUniqueInput
    /**
     * In case the OrganizationTraining found by the `where` argument doesn't exist, create a new OrganizationTraining with this data.
     */
    create: XOR<OrganizationTrainingCreateInput, OrganizationTrainingUncheckedCreateInput>
    /**
     * In case the OrganizationTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationTrainingUpdateInput, OrganizationTrainingUncheckedUpdateInput>
  }

  /**
   * OrganizationTraining delete
   */
  export type OrganizationTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
    /**
     * Filter which OrganizationTraining to delete.
     */
    where: OrganizationTrainingWhereUniqueInput
  }

  /**
   * OrganizationTraining deleteMany
   */
  export type OrganizationTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTrainings to delete
     */
    where?: OrganizationTrainingWhereInput
    /**
     * Limit how many OrganizationTrainings to delete.
     */
    limit?: number
  }

  /**
   * OrganizationTraining without action
   */
  export type OrganizationTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTraining
     */
    select?: OrganizationTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTraining
     */
    omit?: OrganizationTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTrainingInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationInvitation
   */

  export type AggregateOrganizationInvitation = {
    _count: OrganizationInvitationCountAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  export type OrganizationInvitationMinAggregateOutputType = {
    id: string | null
    email: string | null
    organizationId: string | null
    inviteCode: string | null
    role: string | null
    status: string | null
    invitedBy: string | null
    invitedAt: Date | null
    expiresAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationInvitationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    organizationId: string | null
    inviteCode: string | null
    role: string | null
    status: string | null
    invitedBy: string | null
    invitedAt: Date | null
    expiresAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationInvitationCountAggregateOutputType = {
    id: number
    email: number
    organizationId: number
    inviteCode: number
    role: number
    status: number
    invitedBy: number
    invitedAt: number
    expiresAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationInvitationMinAggregateInputType = {
    id?: true
    email?: true
    organizationId?: true
    inviteCode?: true
    role?: true
    status?: true
    invitedBy?: true
    invitedAt?: true
    expiresAt?: true
    updatedAt?: true
  }

  export type OrganizationInvitationMaxAggregateInputType = {
    id?: true
    email?: true
    organizationId?: true
    inviteCode?: true
    role?: true
    status?: true
    invitedBy?: true
    invitedAt?: true
    expiresAt?: true
    updatedAt?: true
  }

  export type OrganizationInvitationCountAggregateInputType = {
    id?: true
    email?: true
    organizationId?: true
    inviteCode?: true
    role?: true
    status?: true
    invitedBy?: true
    invitedAt?: true
    expiresAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationInvitation to aggregate.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationInvitations
    **/
    _count?: true | OrganizationInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationInvitationMaxAggregateInputType
  }

  export type GetOrganizationInvitationAggregateType<T extends OrganizationInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
      : GetScalarType<T[P], AggregateOrganizationInvitation[P]>
  }




  export type OrganizationInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationInvitationWhereInput
    orderBy?: OrganizationInvitationOrderByWithAggregationInput | OrganizationInvitationOrderByWithAggregationInput[]
    by: OrganizationInvitationScalarFieldEnum[] | OrganizationInvitationScalarFieldEnum
    having?: OrganizationInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationInvitationCountAggregateInputType | true
    _min?: OrganizationInvitationMinAggregateInputType
    _max?: OrganizationInvitationMaxAggregateInputType
  }

  export type OrganizationInvitationGroupByOutputType = {
    id: string
    email: string
    organizationId: string
    inviteCode: string
    role: string
    status: string
    invitedBy: string
    invitedAt: Date
    expiresAt: Date
    updatedAt: Date
    _count: OrganizationInvitationCountAggregateOutputType | null
    _min: OrganizationInvitationMinAggregateOutputType | null
    _max: OrganizationInvitationMaxAggregateOutputType | null
  }

  type GetOrganizationInvitationGroupByPayload<T extends OrganizationInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationInvitationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    organizationId?: boolean
    inviteCode?: boolean
    role?: boolean
    status?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    expiresAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    organizationId?: boolean
    inviteCode?: boolean
    role?: boolean
    status?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    expiresAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    organizationId?: boolean
    inviteCode?: boolean
    role?: boolean
    status?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    expiresAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationInvitation"]>

  export type OrganizationInvitationSelectScalar = {
    id?: boolean
    email?: boolean
    organizationId?: boolean
    inviteCode?: boolean
    role?: boolean
    status?: boolean
    invitedBy?: boolean
    invitedAt?: boolean
    expiresAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "organizationId" | "inviteCode" | "role" | "status" | "invitedBy" | "invitedAt" | "expiresAt" | "updatedAt", ExtArgs["result"]["organizationInvitation"]>
  export type OrganizationInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationInvitation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      organizationId: string
      inviteCode: string
      role: string
      status: string
      invitedBy: string
      invitedAt: Date
      expiresAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationInvitation"]>
    composites: {}
  }

  type OrganizationInvitationGetPayload<S extends boolean | null | undefined | OrganizationInvitationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationInvitationPayload, S>

  type OrganizationInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationInvitationCountAggregateInputType | true
    }

  export interface OrganizationInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationInvitation'], meta: { name: 'OrganizationInvitation' } }
    /**
     * Find zero or one OrganizationInvitation that matches the filter.
     * @param {OrganizationInvitationFindUniqueArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationInvitationFindUniqueArgs>(args: SelectSubset<T, OrganizationInvitationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationInvitationFindUniqueOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationInvitationFindFirstArgs>(args?: SelectSubset<T, OrganizationInvitationFindFirstArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindFirstOrThrowArgs} args - Arguments to find a OrganizationInvitation
     * @example
     * // Get one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany()
     * 
     * // Get first 10 OrganizationInvitations
     * const organizationInvitations = await prisma.organizationInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationInvitationFindManyArgs>(args?: SelectSubset<T, OrganizationInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationInvitation.
     * @param {OrganizationInvitationCreateArgs} args - Arguments to create a OrganizationInvitation.
     * @example
     * // Create one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.create({
     *   data: {
     *     // ... data to create a OrganizationInvitation
     *   }
     * })
     * 
     */
    create<T extends OrganizationInvitationCreateArgs>(args: SelectSubset<T, OrganizationInvitationCreateArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationInvitations.
     * @param {OrganizationInvitationCreateManyArgs} args - Arguments to create many OrganizationInvitations.
     * @example
     * // Create many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationInvitationCreateManyArgs>(args?: SelectSubset<T, OrganizationInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationInvitations and returns the data saved in the database.
     * @param {OrganizationInvitationCreateManyAndReturnArgs} args - Arguments to create many OrganizationInvitations.
     * @example
     * // Create many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationInvitations and only return the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationInvitation.
     * @param {OrganizationInvitationDeleteArgs} args - Arguments to delete one OrganizationInvitation.
     * @example
     * // Delete one OrganizationInvitation
     * const OrganizationInvitation = await prisma.organizationInvitation.delete({
     *   where: {
     *     // ... filter to delete one OrganizationInvitation
     *   }
     * })
     * 
     */
    delete<T extends OrganizationInvitationDeleteArgs>(args: SelectSubset<T, OrganizationInvitationDeleteArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationInvitation.
     * @param {OrganizationInvitationUpdateArgs} args - Arguments to update one OrganizationInvitation.
     * @example
     * // Update one OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationInvitationUpdateArgs>(args: SelectSubset<T, OrganizationInvitationUpdateArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationInvitations.
     * @param {OrganizationInvitationDeleteManyArgs} args - Arguments to filter OrganizationInvitations to delete.
     * @example
     * // Delete a few OrganizationInvitations
     * const { count } = await prisma.organizationInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationInvitationDeleteManyArgs>(args?: SelectSubset<T, OrganizationInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationInvitationUpdateManyArgs>(args: SelectSubset<T, OrganizationInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationInvitations and returns the data updated in the database.
     * @param {OrganizationInvitationUpdateManyAndReturnArgs} args - Arguments to update many OrganizationInvitations.
     * @example
     * // Update many OrganizationInvitations
     * const organizationInvitation = await prisma.organizationInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationInvitations and only return the `id`
     * const organizationInvitationWithIdOnly = await prisma.organizationInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationInvitation.
     * @param {OrganizationInvitationUpsertArgs} args - Arguments to update or create a OrganizationInvitation.
     * @example
     * // Update or create a OrganizationInvitation
     * const organizationInvitation = await prisma.organizationInvitation.upsert({
     *   create: {
     *     // ... data to create a OrganizationInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationInvitation we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationInvitationUpsertArgs>(args: SelectSubset<T, OrganizationInvitationUpsertArgs<ExtArgs>>): Prisma__OrganizationInvitationClient<$Result.GetResult<Prisma.$OrganizationInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationCountArgs} args - Arguments to filter OrganizationInvitations to count.
     * @example
     * // Count the number of OrganizationInvitations
     * const count = await prisma.organizationInvitation.count({
     *   where: {
     *     // ... the filter for the OrganizationInvitations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationInvitationCountArgs>(
      args?: Subset<T, OrganizationInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationInvitationAggregateArgs>(args: Subset<T, OrganizationInvitationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationInvitationAggregateType<T>>

    /**
     * Group by OrganizationInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationInvitationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationInvitation model
   */
  readonly fields: OrganizationInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationInvitation model
   */
  interface OrganizationInvitationFieldRefs {
    readonly id: FieldRef<"OrganizationInvitation", 'String'>
    readonly email: FieldRef<"OrganizationInvitation", 'String'>
    readonly organizationId: FieldRef<"OrganizationInvitation", 'String'>
    readonly inviteCode: FieldRef<"OrganizationInvitation", 'String'>
    readonly role: FieldRef<"OrganizationInvitation", 'String'>
    readonly status: FieldRef<"OrganizationInvitation", 'String'>
    readonly invitedBy: FieldRef<"OrganizationInvitation", 'String'>
    readonly invitedAt: FieldRef<"OrganizationInvitation", 'DateTime'>
    readonly expiresAt: FieldRef<"OrganizationInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationInvitation findUnique
   */
  export type OrganizationInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation findUniqueOrThrow
   */
  export type OrganizationInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation findFirst
   */
  export type OrganizationInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation findFirstOrThrow
   */
  export type OrganizationInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitation to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationInvitations.
     */
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation findMany
   */
  export type OrganizationInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationInvitations to fetch.
     */
    where?: OrganizationInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationInvitations to fetch.
     */
    orderBy?: OrganizationInvitationOrderByWithRelationInput | OrganizationInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationInvitations.
     */
    cursor?: OrganizationInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationInvitations.
     */
    skip?: number
    distinct?: OrganizationInvitationScalarFieldEnum | OrganizationInvitationScalarFieldEnum[]
  }

  /**
   * OrganizationInvitation create
   */
  export type OrganizationInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
  }

  /**
   * OrganizationInvitation createMany
   */
  export type OrganizationInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationInvitations.
     */
    data: OrganizationInvitationCreateManyInput | OrganizationInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationInvitation createManyAndReturn
   */
  export type OrganizationInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationInvitations.
     */
    data: OrganizationInvitationCreateManyInput | OrganizationInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationInvitation update
   */
  export type OrganizationInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationInvitation.
     */
    data: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
    /**
     * Choose, which OrganizationInvitation to update.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation updateMany
   */
  export type OrganizationInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationInvitations.
     */
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationInvitations to update
     */
    where?: OrganizationInvitationWhereInput
    /**
     * Limit how many OrganizationInvitations to update.
     */
    limit?: number
  }

  /**
   * OrganizationInvitation updateManyAndReturn
   */
  export type OrganizationInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationInvitations.
     */
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationInvitations to update
     */
    where?: OrganizationInvitationWhereInput
    /**
     * Limit how many OrganizationInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationInvitation upsert
   */
  export type OrganizationInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationInvitation to update in case it exists.
     */
    where: OrganizationInvitationWhereUniqueInput
    /**
     * In case the OrganizationInvitation found by the `where` argument doesn't exist, create a new OrganizationInvitation with this data.
     */
    create: XOR<OrganizationInvitationCreateInput, OrganizationInvitationUncheckedCreateInput>
    /**
     * In case the OrganizationInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationInvitationUpdateInput, OrganizationInvitationUncheckedUpdateInput>
  }

  /**
   * OrganizationInvitation delete
   */
  export type OrganizationInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
    /**
     * Filter which OrganizationInvitation to delete.
     */
    where: OrganizationInvitationWhereUniqueInput
  }

  /**
   * OrganizationInvitation deleteMany
   */
  export type OrganizationInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationInvitations to delete
     */
    where?: OrganizationInvitationWhereInput
    /**
     * Limit how many OrganizationInvitations to delete.
     */
    limit?: number
  }

  /**
   * OrganizationInvitation without action
   */
  export type OrganizationInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationInvitation
     */
    select?: OrganizationInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationInvitation
     */
    omit?: OrganizationInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInvitationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationTag
   */

  export type AggregateOrganizationTag = {
    _count: OrganizationTagCountAggregateOutputType | null
    _min: OrganizationTagMinAggregateOutputType | null
    _max: OrganizationTagMaxAggregateOutputType | null
  }

  export type OrganizationTagMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationTagMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    color: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationTagCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    color: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationTagMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationTagMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationTagCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    color?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTag to aggregate.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: OrganizationTagOrderByWithRelationInput | OrganizationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationTags
    **/
    _count?: true | OrganizationTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationTagMaxAggregateInputType
  }

  export type GetOrganizationTagAggregateType<T extends OrganizationTagAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationTag[P]>
      : GetScalarType<T[P], AggregateOrganizationTag[P]>
  }




  export type OrganizationTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationTagWhereInput
    orderBy?: OrganizationTagOrderByWithAggregationInput | OrganizationTagOrderByWithAggregationInput[]
    by: OrganizationTagScalarFieldEnum[] | OrganizationTagScalarFieldEnum
    having?: OrganizationTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationTagCountAggregateInputType | true
    _min?: OrganizationTagMinAggregateInputType
    _max?: OrganizationTagMaxAggregateInputType
  }

  export type OrganizationTagGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    color: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationTagCountAggregateOutputType | null
    _min: OrganizationTagMinAggregateOutputType | null
    _max: OrganizationTagMaxAggregateOutputType | null
  }

  type GetOrganizationTagGroupByPayload<T extends OrganizationTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationTagGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationTagGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    users?: boolean | OrganizationTag$usersArgs<ExtArgs>
    trainings?: boolean | OrganizationTag$trainingsArgs<ExtArgs>
    _count?: boolean | OrganizationTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTag"]>

  export type OrganizationTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTag"]>

  export type OrganizationTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationTag"]>

  export type OrganizationTagSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    color?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "name" | "color" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["organizationTag"]>
  export type OrganizationTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    users?: boolean | OrganizationTag$usersArgs<ExtArgs>
    trainings?: boolean | OrganizationTag$trainingsArgs<ExtArgs>
    _count?: boolean | OrganizationTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type OrganizationTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $OrganizationTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationTag"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      users: Prisma.$UserTagPayload<ExtArgs>[]
      trainings: Prisma.$TagTrainingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      color: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organizationTag"]>
    composites: {}
  }

  type OrganizationTagGetPayload<S extends boolean | null | undefined | OrganizationTagDefaultArgs> = $Result.GetResult<Prisma.$OrganizationTagPayload, S>

  type OrganizationTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationTagCountAggregateInputType | true
    }

  export interface OrganizationTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationTag'], meta: { name: 'OrganizationTag' } }
    /**
     * Find zero or one OrganizationTag that matches the filter.
     * @param {OrganizationTagFindUniqueArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationTagFindUniqueArgs>(args: SelectSubset<T, OrganizationTagFindUniqueArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationTagFindUniqueOrThrowArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationTagFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindFirstArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationTagFindFirstArgs>(args?: SelectSubset<T, OrganizationTagFindFirstArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindFirstOrThrowArgs} args - Arguments to find a OrganizationTag
     * @example
     * // Get one OrganizationTag
     * const organizationTag = await prisma.organizationTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationTagFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationTags
     * const organizationTags = await prisma.organizationTag.findMany()
     * 
     * // Get first 10 OrganizationTags
     * const organizationTags = await prisma.organizationTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationTagWithIdOnly = await prisma.organizationTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationTagFindManyArgs>(args?: SelectSubset<T, OrganizationTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationTag.
     * @param {OrganizationTagCreateArgs} args - Arguments to create a OrganizationTag.
     * @example
     * // Create one OrganizationTag
     * const OrganizationTag = await prisma.organizationTag.create({
     *   data: {
     *     // ... data to create a OrganizationTag
     *   }
     * })
     * 
     */
    create<T extends OrganizationTagCreateArgs>(args: SelectSubset<T, OrganizationTagCreateArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationTags.
     * @param {OrganizationTagCreateManyArgs} args - Arguments to create many OrganizationTags.
     * @example
     * // Create many OrganizationTags
     * const organizationTag = await prisma.organizationTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationTagCreateManyArgs>(args?: SelectSubset<T, OrganizationTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationTags and returns the data saved in the database.
     * @param {OrganizationTagCreateManyAndReturnArgs} args - Arguments to create many OrganizationTags.
     * @example
     * // Create many OrganizationTags
     * const organizationTag = await prisma.organizationTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationTags and only return the `id`
     * const organizationTagWithIdOnly = await prisma.organizationTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationTagCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationTag.
     * @param {OrganizationTagDeleteArgs} args - Arguments to delete one OrganizationTag.
     * @example
     * // Delete one OrganizationTag
     * const OrganizationTag = await prisma.organizationTag.delete({
     *   where: {
     *     // ... filter to delete one OrganizationTag
     *   }
     * })
     * 
     */
    delete<T extends OrganizationTagDeleteArgs>(args: SelectSubset<T, OrganizationTagDeleteArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationTag.
     * @param {OrganizationTagUpdateArgs} args - Arguments to update one OrganizationTag.
     * @example
     * // Update one OrganizationTag
     * const organizationTag = await prisma.organizationTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationTagUpdateArgs>(args: SelectSubset<T, OrganizationTagUpdateArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationTags.
     * @param {OrganizationTagDeleteManyArgs} args - Arguments to filter OrganizationTags to delete.
     * @example
     * // Delete a few OrganizationTags
     * const { count } = await prisma.organizationTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationTagDeleteManyArgs>(args?: SelectSubset<T, OrganizationTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationTags
     * const organizationTag = await prisma.organizationTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationTagUpdateManyArgs>(args: SelectSubset<T, OrganizationTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationTags and returns the data updated in the database.
     * @param {OrganizationTagUpdateManyAndReturnArgs} args - Arguments to update many OrganizationTags.
     * @example
     * // Update many OrganizationTags
     * const organizationTag = await prisma.organizationTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationTags and only return the `id`
     * const organizationTagWithIdOnly = await prisma.organizationTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationTagUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationTag.
     * @param {OrganizationTagUpsertArgs} args - Arguments to update or create a OrganizationTag.
     * @example
     * // Update or create a OrganizationTag
     * const organizationTag = await prisma.organizationTag.upsert({
     *   create: {
     *     // ... data to create a OrganizationTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationTag we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationTagUpsertArgs>(args: SelectSubset<T, OrganizationTagUpsertArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagCountArgs} args - Arguments to filter OrganizationTags to count.
     * @example
     * // Count the number of OrganizationTags
     * const count = await prisma.organizationTag.count({
     *   where: {
     *     // ... the filter for the OrganizationTags we want to count
     *   }
     * })
    **/
    count<T extends OrganizationTagCountArgs>(
      args?: Subset<T, OrganizationTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationTagAggregateArgs>(args: Subset<T, OrganizationTagAggregateArgs>): Prisma.PrismaPromise<GetOrganizationTagAggregateType<T>>

    /**
     * Group by OrganizationTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationTagGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationTag model
   */
  readonly fields: OrganizationTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends OrganizationTag$usersArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationTag$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings<T extends OrganizationTag$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationTag$trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationTag model
   */
  interface OrganizationTagFieldRefs {
    readonly id: FieldRef<"OrganizationTag", 'String'>
    readonly organizationId: FieldRef<"OrganizationTag", 'String'>
    readonly name: FieldRef<"OrganizationTag", 'String'>
    readonly color: FieldRef<"OrganizationTag", 'String'>
    readonly description: FieldRef<"OrganizationTag", 'String'>
    readonly createdAt: FieldRef<"OrganizationTag", 'DateTime'>
    readonly updatedAt: FieldRef<"OrganizationTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationTag findUnique
   */
  export type OrganizationTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where: OrganizationTagWhereUniqueInput
  }

  /**
   * OrganizationTag findUniqueOrThrow
   */
  export type OrganizationTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where: OrganizationTagWhereUniqueInput
  }

  /**
   * OrganizationTag findFirst
   */
  export type OrganizationTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: OrganizationTagOrderByWithRelationInput | OrganizationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTags.
     */
    distinct?: OrganizationTagScalarFieldEnum | OrganizationTagScalarFieldEnum[]
  }

  /**
   * OrganizationTag findFirstOrThrow
   */
  export type OrganizationTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTag to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: OrganizationTagOrderByWithRelationInput | OrganizationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationTags.
     */
    distinct?: OrganizationTagScalarFieldEnum | OrganizationTagScalarFieldEnum[]
  }

  /**
   * OrganizationTag findMany
   */
  export type OrganizationTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationTags to fetch.
     */
    where?: OrganizationTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationTags to fetch.
     */
    orderBy?: OrganizationTagOrderByWithRelationInput | OrganizationTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationTags.
     */
    cursor?: OrganizationTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationTags.
     */
    skip?: number
    distinct?: OrganizationTagScalarFieldEnum | OrganizationTagScalarFieldEnum[]
  }

  /**
   * OrganizationTag create
   */
  export type OrganizationTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationTag.
     */
    data: XOR<OrganizationTagCreateInput, OrganizationTagUncheckedCreateInput>
  }

  /**
   * OrganizationTag createMany
   */
  export type OrganizationTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationTags.
     */
    data: OrganizationTagCreateManyInput | OrganizationTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationTag createManyAndReturn
   */
  export type OrganizationTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationTags.
     */
    data: OrganizationTagCreateManyInput | OrganizationTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationTag update
   */
  export type OrganizationTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationTag.
     */
    data: XOR<OrganizationTagUpdateInput, OrganizationTagUncheckedUpdateInput>
    /**
     * Choose, which OrganizationTag to update.
     */
    where: OrganizationTagWhereUniqueInput
  }

  /**
   * OrganizationTag updateMany
   */
  export type OrganizationTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationTags.
     */
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationTags to update
     */
    where?: OrganizationTagWhereInput
    /**
     * Limit how many OrganizationTags to update.
     */
    limit?: number
  }

  /**
   * OrganizationTag updateManyAndReturn
   */
  export type OrganizationTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationTags.
     */
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationTags to update
     */
    where?: OrganizationTagWhereInput
    /**
     * Limit how many OrganizationTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationTag upsert
   */
  export type OrganizationTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationTag to update in case it exists.
     */
    where: OrganizationTagWhereUniqueInput
    /**
     * In case the OrganizationTag found by the `where` argument doesn't exist, create a new OrganizationTag with this data.
     */
    create: XOR<OrganizationTagCreateInput, OrganizationTagUncheckedCreateInput>
    /**
     * In case the OrganizationTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationTagUpdateInput, OrganizationTagUncheckedUpdateInput>
  }

  /**
   * OrganizationTag delete
   */
  export type OrganizationTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
    /**
     * Filter which OrganizationTag to delete.
     */
    where: OrganizationTagWhereUniqueInput
  }

  /**
   * OrganizationTag deleteMany
   */
  export type OrganizationTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationTags to delete
     */
    where?: OrganizationTagWhereInput
    /**
     * Limit how many OrganizationTags to delete.
     */
    limit?: number
  }

  /**
   * OrganizationTag.users
   */
  export type OrganizationTag$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    cursor?: UserTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * OrganizationTag.trainings
   */
  export type OrganizationTag$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    where?: TagTrainingWhereInput
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    cursor?: TagTrainingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagTrainingScalarFieldEnum | TagTrainingScalarFieldEnum[]
  }

  /**
   * OrganizationTag without action
   */
  export type OrganizationTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationTag
     */
    select?: OrganizationTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationTag
     */
    omit?: OrganizationTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationTagInclude<ExtArgs> | null
  }


  /**
   * Model UserTag
   */

  export type AggregateUserTag = {
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  export type UserTagMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tagId: string | null
    assignedAt: Date | null
  }

  export type UserTagMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tagId: string | null
    assignedAt: Date | null
  }

  export type UserTagCountAggregateOutputType = {
    id: number
    userId: number
    tagId: number
    assignedAt: number
    _all: number
  }


  export type UserTagMinAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    assignedAt?: true
  }

  export type UserTagMaxAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    assignedAt?: true
  }

  export type UserTagCountAggregateInputType = {
    id?: true
    userId?: true
    tagId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTag to aggregate.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTags
    **/
    _count?: true | UserTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTagMaxAggregateInputType
  }

  export type GetUserTagAggregateType<T extends UserTagAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTag[P]>
      : GetScalarType<T[P], AggregateUserTag[P]>
  }




  export type UserTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTagWhereInput
    orderBy?: UserTagOrderByWithAggregationInput | UserTagOrderByWithAggregationInput[]
    by: UserTagScalarFieldEnum[] | UserTagScalarFieldEnum
    having?: UserTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTagCountAggregateInputType | true
    _min?: UserTagMinAggregateInputType
    _max?: UserTagMaxAggregateInputType
  }

  export type UserTagGroupByOutputType = {
    id: string
    userId: string
    tagId: string
    assignedAt: Date
    _count: UserTagCountAggregateOutputType | null
    _min: UserTagMinAggregateOutputType | null
    _max: UserTagMaxAggregateOutputType | null
  }

  type GetUserTagGroupByPayload<T extends UserTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTagGroupByOutputType[P]>
            : GetScalarType<T[P], UserTagGroupByOutputType[P]>
        }
      >
    >


  export type UserTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tagId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTag"]>

  export type UserTagSelectScalar = {
    id?: boolean
    userId?: boolean
    tagId?: boolean
    assignedAt?: boolean
  }

  export type UserTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tagId" | "assignedAt", ExtArgs["result"]["userTag"]>
  export type UserTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }
  export type UserTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }
  export type UserTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
  }

  export type $UserTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTag"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tag: Prisma.$OrganizationTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tagId: string
      assignedAt: Date
    }, ExtArgs["result"]["userTag"]>
    composites: {}
  }

  type UserTagGetPayload<S extends boolean | null | undefined | UserTagDefaultArgs> = $Result.GetResult<Prisma.$UserTagPayload, S>

  type UserTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTagCountAggregateInputType | true
    }

  export interface UserTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTag'], meta: { name: 'UserTag' } }
    /**
     * Find zero or one UserTag that matches the filter.
     * @param {UserTagFindUniqueArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTagFindUniqueArgs>(args: SelectSubset<T, UserTagFindUniqueArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTagFindUniqueOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTagFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTagFindFirstArgs>(args?: SelectSubset<T, UserTagFindFirstArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindFirstOrThrowArgs} args - Arguments to find a UserTag
     * @example
     * // Get one UserTag
     * const userTag = await prisma.userTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTagFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTags
     * const userTags = await prisma.userTag.findMany()
     * 
     * // Get first 10 UserTags
     * const userTags = await prisma.userTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTagWithIdOnly = await prisma.userTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTagFindManyArgs>(args?: SelectSubset<T, UserTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTag.
     * @param {UserTagCreateArgs} args - Arguments to create a UserTag.
     * @example
     * // Create one UserTag
     * const UserTag = await prisma.userTag.create({
     *   data: {
     *     // ... data to create a UserTag
     *   }
     * })
     * 
     */
    create<T extends UserTagCreateArgs>(args: SelectSubset<T, UserTagCreateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTags.
     * @param {UserTagCreateManyArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTagCreateManyArgs>(args?: SelectSubset<T, UserTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTags and returns the data saved in the database.
     * @param {UserTagCreateManyAndReturnArgs} args - Arguments to create many UserTags.
     * @example
     * // Create many UserTags
     * const userTag = await prisma.userTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTags and only return the `id`
     * const userTagWithIdOnly = await prisma.userTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTagCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTag.
     * @param {UserTagDeleteArgs} args - Arguments to delete one UserTag.
     * @example
     * // Delete one UserTag
     * const UserTag = await prisma.userTag.delete({
     *   where: {
     *     // ... filter to delete one UserTag
     *   }
     * })
     * 
     */
    delete<T extends UserTagDeleteArgs>(args: SelectSubset<T, UserTagDeleteArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTag.
     * @param {UserTagUpdateArgs} args - Arguments to update one UserTag.
     * @example
     * // Update one UserTag
     * const userTag = await prisma.userTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTagUpdateArgs>(args: SelectSubset<T, UserTagUpdateArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTags.
     * @param {UserTagDeleteManyArgs} args - Arguments to filter UserTags to delete.
     * @example
     * // Delete a few UserTags
     * const { count } = await prisma.userTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTagDeleteManyArgs>(args?: SelectSubset<T, UserTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTagUpdateManyArgs>(args: SelectSubset<T, UserTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTags and returns the data updated in the database.
     * @param {UserTagUpdateManyAndReturnArgs} args - Arguments to update many UserTags.
     * @example
     * // Update many UserTags
     * const userTag = await prisma.userTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTags and only return the `id`
     * const userTagWithIdOnly = await prisma.userTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTagUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTag.
     * @param {UserTagUpsertArgs} args - Arguments to update or create a UserTag.
     * @example
     * // Update or create a UserTag
     * const userTag = await prisma.userTag.upsert({
     *   create: {
     *     // ... data to create a UserTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTag we want to update
     *   }
     * })
     */
    upsert<T extends UserTagUpsertArgs>(args: SelectSubset<T, UserTagUpsertArgs<ExtArgs>>): Prisma__UserTagClient<$Result.GetResult<Prisma.$UserTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagCountArgs} args - Arguments to filter UserTags to count.
     * @example
     * // Count the number of UserTags
     * const count = await prisma.userTag.count({
     *   where: {
     *     // ... the filter for the UserTags we want to count
     *   }
     * })
    **/
    count<T extends UserTagCountArgs>(
      args?: Subset<T, UserTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTagAggregateArgs>(args: Subset<T, UserTagAggregateArgs>): Prisma.PrismaPromise<GetUserTagAggregateType<T>>

    /**
     * Group by UserTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTagGroupByArgs['orderBy'] }
        : { orderBy?: UserTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTag model
   */
  readonly fields: UserTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends OrganizationTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationTagDefaultArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTag model
   */
  interface UserTagFieldRefs {
    readonly id: FieldRef<"UserTag", 'String'>
    readonly userId: FieldRef<"UserTag", 'String'>
    readonly tagId: FieldRef<"UserTag", 'String'>
    readonly assignedAt: FieldRef<"UserTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTag findUnique
   */
  export type UserTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findUniqueOrThrow
   */
  export type UserTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag findFirst
   */
  export type UserTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findFirstOrThrow
   */
  export type UserTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTag to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTags.
     */
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag findMany
   */
  export type UserTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter, which UserTags to fetch.
     */
    where?: UserTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTags to fetch.
     */
    orderBy?: UserTagOrderByWithRelationInput | UserTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTags.
     */
    cursor?: UserTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTags.
     */
    skip?: number
    distinct?: UserTagScalarFieldEnum | UserTagScalarFieldEnum[]
  }

  /**
   * UserTag create
   */
  export type UserTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTag.
     */
    data: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
  }

  /**
   * UserTag createMany
   */
  export type UserTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTag createManyAndReturn
   */
  export type UserTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * The data used to create many UserTags.
     */
    data: UserTagCreateManyInput | UserTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTag update
   */
  export type UserTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTag.
     */
    data: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
    /**
     * Choose, which UserTag to update.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag updateMany
   */
  export type UserTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
  }

  /**
   * UserTag updateManyAndReturn
   */
  export type UserTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * The data used to update UserTags.
     */
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyInput>
    /**
     * Filter which UserTags to update
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTag upsert
   */
  export type UserTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTag to update in case it exists.
     */
    where: UserTagWhereUniqueInput
    /**
     * In case the UserTag found by the `where` argument doesn't exist, create a new UserTag with this data.
     */
    create: XOR<UserTagCreateInput, UserTagUncheckedCreateInput>
    /**
     * In case the UserTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTagUpdateInput, UserTagUncheckedUpdateInput>
  }

  /**
   * UserTag delete
   */
  export type UserTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
    /**
     * Filter which UserTag to delete.
     */
    where: UserTagWhereUniqueInput
  }

  /**
   * UserTag deleteMany
   */
  export type UserTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTags to delete
     */
    where?: UserTagWhereInput
    /**
     * Limit how many UserTags to delete.
     */
    limit?: number
  }

  /**
   * UserTag without action
   */
  export type UserTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTag
     */
    select?: UserTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTag
     */
    omit?: UserTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTagInclude<ExtArgs> | null
  }


  /**
   * Model TagTraining
   */

  export type AggregateTagTraining = {
    _count: TagTrainingCountAggregateOutputType | null
    _min: TagTrainingMinAggregateOutputType | null
    _max: TagTrainingMaxAggregateOutputType | null
  }

  export type TagTrainingMinAggregateOutputType = {
    id: string | null
    tagId: string | null
    courseId: string | null
    assignedAt: Date | null
  }

  export type TagTrainingMaxAggregateOutputType = {
    id: string | null
    tagId: string | null
    courseId: string | null
    assignedAt: Date | null
  }

  export type TagTrainingCountAggregateOutputType = {
    id: number
    tagId: number
    courseId: number
    assignedAt: number
    _all: number
  }


  export type TagTrainingMinAggregateInputType = {
    id?: true
    tagId?: true
    courseId?: true
    assignedAt?: true
  }

  export type TagTrainingMaxAggregateInputType = {
    id?: true
    tagId?: true
    courseId?: true
    assignedAt?: true
  }

  export type TagTrainingCountAggregateInputType = {
    id?: true
    tagId?: true
    courseId?: true
    assignedAt?: true
    _all?: true
  }

  export type TagTrainingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTraining to aggregate.
     */
    where?: TagTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTrainings to fetch.
     */
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagTrainings
    **/
    _count?: true | TagTrainingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagTrainingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagTrainingMaxAggregateInputType
  }

  export type GetTagTrainingAggregateType<T extends TagTrainingAggregateArgs> = {
        [P in keyof T & keyof AggregateTagTraining]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagTraining[P]>
      : GetScalarType<T[P], AggregateTagTraining[P]>
  }




  export type TagTrainingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagTrainingWhereInput
    orderBy?: TagTrainingOrderByWithAggregationInput | TagTrainingOrderByWithAggregationInput[]
    by: TagTrainingScalarFieldEnum[] | TagTrainingScalarFieldEnum
    having?: TagTrainingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagTrainingCountAggregateInputType | true
    _min?: TagTrainingMinAggregateInputType
    _max?: TagTrainingMaxAggregateInputType
  }

  export type TagTrainingGroupByOutputType = {
    id: string
    tagId: string
    courseId: string
    assignedAt: Date
    _count: TagTrainingCountAggregateOutputType | null
    _min: TagTrainingMinAggregateOutputType | null
    _max: TagTrainingMaxAggregateOutputType | null
  }

  type GetTagTrainingGroupByPayload<T extends TagTrainingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagTrainingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagTrainingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagTrainingGroupByOutputType[P]>
            : GetScalarType<T[P], TagTrainingGroupByOutputType[P]>
        }
      >
    >


  export type TagTrainingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    courseId?: boolean
    assignedAt?: boolean
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTraining"]>

  export type TagTrainingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    courseId?: boolean
    assignedAt?: boolean
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTraining"]>

  export type TagTrainingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    courseId?: boolean
    assignedAt?: boolean
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagTraining"]>

  export type TagTrainingSelectScalar = {
    id?: boolean
    tagId?: boolean
    courseId?: boolean
    assignedAt?: boolean
  }

  export type TagTrainingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagId" | "courseId" | "assignedAt", ExtArgs["result"]["tagTraining"]>
  export type TagTrainingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type TagTrainingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type TagTrainingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | OrganizationTagDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $TagTrainingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagTraining"
    objects: {
      tag: Prisma.$OrganizationTagPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagId: string
      courseId: string
      assignedAt: Date
    }, ExtArgs["result"]["tagTraining"]>
    composites: {}
  }

  type TagTrainingGetPayload<S extends boolean | null | undefined | TagTrainingDefaultArgs> = $Result.GetResult<Prisma.$TagTrainingPayload, S>

  type TagTrainingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagTrainingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagTrainingCountAggregateInputType | true
    }

  export interface TagTrainingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagTraining'], meta: { name: 'TagTraining' } }
    /**
     * Find zero or one TagTraining that matches the filter.
     * @param {TagTrainingFindUniqueArgs} args - Arguments to find a TagTraining
     * @example
     * // Get one TagTraining
     * const tagTraining = await prisma.tagTraining.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagTrainingFindUniqueArgs>(args: SelectSubset<T, TagTrainingFindUniqueArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagTraining that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagTrainingFindUniqueOrThrowArgs} args - Arguments to find a TagTraining
     * @example
     * // Get one TagTraining
     * const tagTraining = await prisma.tagTraining.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagTrainingFindUniqueOrThrowArgs>(args: SelectSubset<T, TagTrainingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagTraining that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingFindFirstArgs} args - Arguments to find a TagTraining
     * @example
     * // Get one TagTraining
     * const tagTraining = await prisma.tagTraining.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagTrainingFindFirstArgs>(args?: SelectSubset<T, TagTrainingFindFirstArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagTraining that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingFindFirstOrThrowArgs} args - Arguments to find a TagTraining
     * @example
     * // Get one TagTraining
     * const tagTraining = await prisma.tagTraining.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagTrainingFindFirstOrThrowArgs>(args?: SelectSubset<T, TagTrainingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagTrainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagTrainings
     * const tagTrainings = await prisma.tagTraining.findMany()
     * 
     * // Get first 10 TagTrainings
     * const tagTrainings = await prisma.tagTraining.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagTrainingWithIdOnly = await prisma.tagTraining.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagTrainingFindManyArgs>(args?: SelectSubset<T, TagTrainingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagTraining.
     * @param {TagTrainingCreateArgs} args - Arguments to create a TagTraining.
     * @example
     * // Create one TagTraining
     * const TagTraining = await prisma.tagTraining.create({
     *   data: {
     *     // ... data to create a TagTraining
     *   }
     * })
     * 
     */
    create<T extends TagTrainingCreateArgs>(args: SelectSubset<T, TagTrainingCreateArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagTrainings.
     * @param {TagTrainingCreateManyArgs} args - Arguments to create many TagTrainings.
     * @example
     * // Create many TagTrainings
     * const tagTraining = await prisma.tagTraining.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagTrainingCreateManyArgs>(args?: SelectSubset<T, TagTrainingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagTrainings and returns the data saved in the database.
     * @param {TagTrainingCreateManyAndReturnArgs} args - Arguments to create many TagTrainings.
     * @example
     * // Create many TagTrainings
     * const tagTraining = await prisma.tagTraining.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagTrainings and only return the `id`
     * const tagTrainingWithIdOnly = await prisma.tagTraining.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagTrainingCreateManyAndReturnArgs>(args?: SelectSubset<T, TagTrainingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagTraining.
     * @param {TagTrainingDeleteArgs} args - Arguments to delete one TagTraining.
     * @example
     * // Delete one TagTraining
     * const TagTraining = await prisma.tagTraining.delete({
     *   where: {
     *     // ... filter to delete one TagTraining
     *   }
     * })
     * 
     */
    delete<T extends TagTrainingDeleteArgs>(args: SelectSubset<T, TagTrainingDeleteArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagTraining.
     * @param {TagTrainingUpdateArgs} args - Arguments to update one TagTraining.
     * @example
     * // Update one TagTraining
     * const tagTraining = await prisma.tagTraining.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagTrainingUpdateArgs>(args: SelectSubset<T, TagTrainingUpdateArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagTrainings.
     * @param {TagTrainingDeleteManyArgs} args - Arguments to filter TagTrainings to delete.
     * @example
     * // Delete a few TagTrainings
     * const { count } = await prisma.tagTraining.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagTrainingDeleteManyArgs>(args?: SelectSubset<T, TagTrainingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagTrainings
     * const tagTraining = await prisma.tagTraining.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagTrainingUpdateManyArgs>(args: SelectSubset<T, TagTrainingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagTrainings and returns the data updated in the database.
     * @param {TagTrainingUpdateManyAndReturnArgs} args - Arguments to update many TagTrainings.
     * @example
     * // Update many TagTrainings
     * const tagTraining = await prisma.tagTraining.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagTrainings and only return the `id`
     * const tagTrainingWithIdOnly = await prisma.tagTraining.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagTrainingUpdateManyAndReturnArgs>(args: SelectSubset<T, TagTrainingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagTraining.
     * @param {TagTrainingUpsertArgs} args - Arguments to update or create a TagTraining.
     * @example
     * // Update or create a TagTraining
     * const tagTraining = await prisma.tagTraining.upsert({
     *   create: {
     *     // ... data to create a TagTraining
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagTraining we want to update
     *   }
     * })
     */
    upsert<T extends TagTrainingUpsertArgs>(args: SelectSubset<T, TagTrainingUpsertArgs<ExtArgs>>): Prisma__TagTrainingClient<$Result.GetResult<Prisma.$TagTrainingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagTrainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingCountArgs} args - Arguments to filter TagTrainings to count.
     * @example
     * // Count the number of TagTrainings
     * const count = await prisma.tagTraining.count({
     *   where: {
     *     // ... the filter for the TagTrainings we want to count
     *   }
     * })
    **/
    count<T extends TagTrainingCountArgs>(
      args?: Subset<T, TagTrainingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagTrainingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagTrainingAggregateArgs>(args: Subset<T, TagTrainingAggregateArgs>): Prisma.PrismaPromise<GetTagTrainingAggregateType<T>>

    /**
     * Group by TagTraining.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagTrainingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagTrainingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagTrainingGroupByArgs['orderBy'] }
        : { orderBy?: TagTrainingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagTrainingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagTrainingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagTraining model
   */
  readonly fields: TagTrainingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagTraining.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagTrainingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tag<T extends OrganizationTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationTagDefaultArgs<ExtArgs>>): Prisma__OrganizationTagClient<$Result.GetResult<Prisma.$OrganizationTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagTraining model
   */
  interface TagTrainingFieldRefs {
    readonly id: FieldRef<"TagTraining", 'String'>
    readonly tagId: FieldRef<"TagTraining", 'String'>
    readonly courseId: FieldRef<"TagTraining", 'String'>
    readonly assignedAt: FieldRef<"TagTraining", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagTraining findUnique
   */
  export type TagTrainingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter, which TagTraining to fetch.
     */
    where: TagTrainingWhereUniqueInput
  }

  /**
   * TagTraining findUniqueOrThrow
   */
  export type TagTrainingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter, which TagTraining to fetch.
     */
    where: TagTrainingWhereUniqueInput
  }

  /**
   * TagTraining findFirst
   */
  export type TagTrainingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter, which TagTraining to fetch.
     */
    where?: TagTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTrainings to fetch.
     */
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTrainings.
     */
    cursor?: TagTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTrainings.
     */
    distinct?: TagTrainingScalarFieldEnum | TagTrainingScalarFieldEnum[]
  }

  /**
   * TagTraining findFirstOrThrow
   */
  export type TagTrainingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter, which TagTraining to fetch.
     */
    where?: TagTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTrainings to fetch.
     */
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagTrainings.
     */
    cursor?: TagTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTrainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagTrainings.
     */
    distinct?: TagTrainingScalarFieldEnum | TagTrainingScalarFieldEnum[]
  }

  /**
   * TagTraining findMany
   */
  export type TagTrainingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter, which TagTrainings to fetch.
     */
    where?: TagTrainingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagTrainings to fetch.
     */
    orderBy?: TagTrainingOrderByWithRelationInput | TagTrainingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagTrainings.
     */
    cursor?: TagTrainingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagTrainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagTrainings.
     */
    skip?: number
    distinct?: TagTrainingScalarFieldEnum | TagTrainingScalarFieldEnum[]
  }

  /**
   * TagTraining create
   */
  export type TagTrainingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * The data needed to create a TagTraining.
     */
    data: XOR<TagTrainingCreateInput, TagTrainingUncheckedCreateInput>
  }

  /**
   * TagTraining createMany
   */
  export type TagTrainingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagTrainings.
     */
    data: TagTrainingCreateManyInput | TagTrainingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagTraining createManyAndReturn
   */
  export type TagTrainingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * The data used to create many TagTrainings.
     */
    data: TagTrainingCreateManyInput | TagTrainingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagTraining update
   */
  export type TagTrainingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * The data needed to update a TagTraining.
     */
    data: XOR<TagTrainingUpdateInput, TagTrainingUncheckedUpdateInput>
    /**
     * Choose, which TagTraining to update.
     */
    where: TagTrainingWhereUniqueInput
  }

  /**
   * TagTraining updateMany
   */
  export type TagTrainingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagTrainings.
     */
    data: XOR<TagTrainingUpdateManyMutationInput, TagTrainingUncheckedUpdateManyInput>
    /**
     * Filter which TagTrainings to update
     */
    where?: TagTrainingWhereInput
    /**
     * Limit how many TagTrainings to update.
     */
    limit?: number
  }

  /**
   * TagTraining updateManyAndReturn
   */
  export type TagTrainingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * The data used to update TagTrainings.
     */
    data: XOR<TagTrainingUpdateManyMutationInput, TagTrainingUncheckedUpdateManyInput>
    /**
     * Filter which TagTrainings to update
     */
    where?: TagTrainingWhereInput
    /**
     * Limit how many TagTrainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagTraining upsert
   */
  export type TagTrainingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * The filter to search for the TagTraining to update in case it exists.
     */
    where: TagTrainingWhereUniqueInput
    /**
     * In case the TagTraining found by the `where` argument doesn't exist, create a new TagTraining with this data.
     */
    create: XOR<TagTrainingCreateInput, TagTrainingUncheckedCreateInput>
    /**
     * In case the TagTraining was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagTrainingUpdateInput, TagTrainingUncheckedUpdateInput>
  }

  /**
   * TagTraining delete
   */
  export type TagTrainingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
    /**
     * Filter which TagTraining to delete.
     */
    where: TagTrainingWhereUniqueInput
  }

  /**
   * TagTraining deleteMany
   */
  export type TagTrainingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagTrainings to delete
     */
    where?: TagTrainingWhereInput
    /**
     * Limit how many TagTrainings to delete.
     */
    limit?: number
  }

  /**
   * TagTraining without action
   */
  export type TagTrainingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagTraining
     */
    select?: TagTrainingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagTraining
     */
    omit?: TagTrainingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagTrainingInclude<ExtArgs> | null
  }


  /**
   * Model FormationContent
   */

  export type AggregateFormationContent = {
    _count: FormationContentCountAggregateOutputType | null
    _avg: FormationContentAvgAggregateOutputType | null
    _sum: FormationContentSumAggregateOutputType | null
    _min: FormationContentMinAggregateOutputType | null
    _max: FormationContentMaxAggregateOutputType | null
  }

  export type FormationContentAvgAggregateOutputType = {
    order: number | null
  }

  export type FormationContentSumAggregateOutputType = {
    order: number | null
  }

  export type FormationContentMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    formationId: string | null
    title: string | null
    description: string | null
    type: string | null
    order: number | null
    educationalTitle: string | null
    educationalText: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationContentMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    formationId: string | null
    title: string | null
    description: string | null
    type: string | null
    order: number | null
    educationalTitle: string | null
    educationalText: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationContentCountAggregateOutputType = {
    id: number
    contentId: number
    formationId: number
    title: number
    description: number
    type: number
    order: number
    educationalTitle: number
    educationalText: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormationContentAvgAggregateInputType = {
    order?: true
  }

  export type FormationContentSumAggregateInputType = {
    order?: true
  }

  export type FormationContentMinAggregateInputType = {
    id?: true
    contentId?: true
    formationId?: true
    title?: true
    description?: true
    type?: true
    order?: true
    educationalTitle?: true
    educationalText?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationContentMaxAggregateInputType = {
    id?: true
    contentId?: true
    formationId?: true
    title?: true
    description?: true
    type?: true
    order?: true
    educationalTitle?: true
    educationalText?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationContentCountAggregateInputType = {
    id?: true
    contentId?: true
    formationId?: true
    title?: true
    description?: true
    type?: true
    order?: true
    educationalTitle?: true
    educationalText?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormationContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationContent to aggregate.
     */
    where?: FormationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationContents to fetch.
     */
    orderBy?: FormationContentOrderByWithRelationInput | FormationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormationContents
    **/
    _count?: true | FormationContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormationContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormationContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormationContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormationContentMaxAggregateInputType
  }

  export type GetFormationContentAggregateType<T extends FormationContentAggregateArgs> = {
        [P in keyof T & keyof AggregateFormationContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormationContent[P]>
      : GetScalarType<T[P], AggregateFormationContent[P]>
  }




  export type FormationContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationContentWhereInput
    orderBy?: FormationContentOrderByWithAggregationInput | FormationContentOrderByWithAggregationInput[]
    by: FormationContentScalarFieldEnum[] | FormationContentScalarFieldEnum
    having?: FormationContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormationContentCountAggregateInputType | true
    _avg?: FormationContentAvgAggregateInputType
    _sum?: FormationContentSumAggregateInputType
    _min?: FormationContentMinAggregateInputType
    _max?: FormationContentMaxAggregateInputType
  }

  export type FormationContentGroupByOutputType = {
    id: string
    contentId: string
    formationId: string
    title: string
    description: string
    type: string
    order: number
    educationalTitle: string | null
    educationalText: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: FormationContentCountAggregateOutputType | null
    _avg: FormationContentAvgAggregateOutputType | null
    _sum: FormationContentSumAggregateOutputType | null
    _min: FormationContentMinAggregateOutputType | null
    _max: FormationContentMaxAggregateOutputType | null
  }

  type GetFormationContentGroupByPayload<T extends FormationContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormationContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormationContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormationContentGroupByOutputType[P]>
            : GetScalarType<T[P], FormationContentGroupByOutputType[P]>
        }
      >
    >


  export type FormationContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    formationId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    educationalTitle?: boolean
    educationalText?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formation?: boolean | FormationDefaultArgs<ExtArgs>
    steps?: boolean | FormationContent$stepsArgs<ExtArgs>
    questions?: boolean | FormationContent$questionsArgs<ExtArgs>
    _count?: boolean | FormationContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationContent"]>

  export type FormationContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    formationId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    educationalTitle?: boolean
    educationalText?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formation?: boolean | FormationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationContent"]>

  export type FormationContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    formationId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    educationalTitle?: boolean
    educationalText?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    formation?: boolean | FormationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationContent"]>

  export type FormationContentSelectScalar = {
    id?: boolean
    contentId?: boolean
    formationId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    order?: boolean
    educationalTitle?: boolean
    educationalText?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormationContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "formationId" | "title" | "description" | "type" | "order" | "educationalTitle" | "educationalText" | "imageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["formationContent"]>
  export type FormationContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formation?: boolean | FormationDefaultArgs<ExtArgs>
    steps?: boolean | FormationContent$stepsArgs<ExtArgs>
    questions?: boolean | FormationContent$questionsArgs<ExtArgs>
    _count?: boolean | FormationContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormationContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formation?: boolean | FormationDefaultArgs<ExtArgs>
  }
  export type FormationContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formation?: boolean | FormationDefaultArgs<ExtArgs>
  }

  export type $FormationContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormationContent"
    objects: {
      formation: Prisma.$FormationPayload<ExtArgs>
      steps: Prisma.$FormationStepPayload<ExtArgs>[]
      questions: Prisma.$FormationQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      formationId: string
      title: string
      description: string
      type: string
      order: number
      educationalTitle: string | null
      educationalText: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formationContent"]>
    composites: {}
  }

  type FormationContentGetPayload<S extends boolean | null | undefined | FormationContentDefaultArgs> = $Result.GetResult<Prisma.$FormationContentPayload, S>

  type FormationContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormationContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormationContentCountAggregateInputType | true
    }

  export interface FormationContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormationContent'], meta: { name: 'FormationContent' } }
    /**
     * Find zero or one FormationContent that matches the filter.
     * @param {FormationContentFindUniqueArgs} args - Arguments to find a FormationContent
     * @example
     * // Get one FormationContent
     * const formationContent = await prisma.formationContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormationContentFindUniqueArgs>(args: SelectSubset<T, FormationContentFindUniqueArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormationContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormationContentFindUniqueOrThrowArgs} args - Arguments to find a FormationContent
     * @example
     * // Get one FormationContent
     * const formationContent = await prisma.formationContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormationContentFindUniqueOrThrowArgs>(args: SelectSubset<T, FormationContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentFindFirstArgs} args - Arguments to find a FormationContent
     * @example
     * // Get one FormationContent
     * const formationContent = await prisma.formationContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormationContentFindFirstArgs>(args?: SelectSubset<T, FormationContentFindFirstArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentFindFirstOrThrowArgs} args - Arguments to find a FormationContent
     * @example
     * // Get one FormationContent
     * const formationContent = await prisma.formationContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormationContentFindFirstOrThrowArgs>(args?: SelectSubset<T, FormationContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormationContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormationContents
     * const formationContents = await prisma.formationContent.findMany()
     * 
     * // Get first 10 FormationContents
     * const formationContents = await prisma.formationContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formationContentWithIdOnly = await prisma.formationContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormationContentFindManyArgs>(args?: SelectSubset<T, FormationContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormationContent.
     * @param {FormationContentCreateArgs} args - Arguments to create a FormationContent.
     * @example
     * // Create one FormationContent
     * const FormationContent = await prisma.formationContent.create({
     *   data: {
     *     // ... data to create a FormationContent
     *   }
     * })
     * 
     */
    create<T extends FormationContentCreateArgs>(args: SelectSubset<T, FormationContentCreateArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormationContents.
     * @param {FormationContentCreateManyArgs} args - Arguments to create many FormationContents.
     * @example
     * // Create many FormationContents
     * const formationContent = await prisma.formationContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormationContentCreateManyArgs>(args?: SelectSubset<T, FormationContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormationContents and returns the data saved in the database.
     * @param {FormationContentCreateManyAndReturnArgs} args - Arguments to create many FormationContents.
     * @example
     * // Create many FormationContents
     * const formationContent = await prisma.formationContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormationContents and only return the `id`
     * const formationContentWithIdOnly = await prisma.formationContent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormationContentCreateManyAndReturnArgs>(args?: SelectSubset<T, FormationContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormationContent.
     * @param {FormationContentDeleteArgs} args - Arguments to delete one FormationContent.
     * @example
     * // Delete one FormationContent
     * const FormationContent = await prisma.formationContent.delete({
     *   where: {
     *     // ... filter to delete one FormationContent
     *   }
     * })
     * 
     */
    delete<T extends FormationContentDeleteArgs>(args: SelectSubset<T, FormationContentDeleteArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormationContent.
     * @param {FormationContentUpdateArgs} args - Arguments to update one FormationContent.
     * @example
     * // Update one FormationContent
     * const formationContent = await prisma.formationContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormationContentUpdateArgs>(args: SelectSubset<T, FormationContentUpdateArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormationContents.
     * @param {FormationContentDeleteManyArgs} args - Arguments to filter FormationContents to delete.
     * @example
     * // Delete a few FormationContents
     * const { count } = await prisma.formationContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormationContentDeleteManyArgs>(args?: SelectSubset<T, FormationContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormationContents
     * const formationContent = await prisma.formationContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormationContentUpdateManyArgs>(args: SelectSubset<T, FormationContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationContents and returns the data updated in the database.
     * @param {FormationContentUpdateManyAndReturnArgs} args - Arguments to update many FormationContents.
     * @example
     * // Update many FormationContents
     * const formationContent = await prisma.formationContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormationContents and only return the `id`
     * const formationContentWithIdOnly = await prisma.formationContent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormationContentUpdateManyAndReturnArgs>(args: SelectSubset<T, FormationContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormationContent.
     * @param {FormationContentUpsertArgs} args - Arguments to update or create a FormationContent.
     * @example
     * // Update or create a FormationContent
     * const formationContent = await prisma.formationContent.upsert({
     *   create: {
     *     // ... data to create a FormationContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormationContent we want to update
     *   }
     * })
     */
    upsert<T extends FormationContentUpsertArgs>(args: SelectSubset<T, FormationContentUpsertArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormationContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentCountArgs} args - Arguments to filter FormationContents to count.
     * @example
     * // Count the number of FormationContents
     * const count = await prisma.formationContent.count({
     *   where: {
     *     // ... the filter for the FormationContents we want to count
     *   }
     * })
    **/
    count<T extends FormationContentCountArgs>(
      args?: Subset<T, FormationContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormationContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormationContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormationContentAggregateArgs>(args: Subset<T, FormationContentAggregateArgs>): Prisma.PrismaPromise<GetFormationContentAggregateType<T>>

    /**
     * Group by FormationContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormationContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormationContentGroupByArgs['orderBy'] }
        : { orderBy?: FormationContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormationContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormationContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormationContent model
   */
  readonly fields: FormationContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormationContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormationContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    formation<T extends FormationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormationDefaultArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends FormationContent$stepsArgs<ExtArgs> = {}>(args?: Subset<T, FormationContent$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends FormationContent$questionsArgs<ExtArgs> = {}>(args?: Subset<T, FormationContent$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormationContent model
   */
  interface FormationContentFieldRefs {
    readonly id: FieldRef<"FormationContent", 'String'>
    readonly contentId: FieldRef<"FormationContent", 'String'>
    readonly formationId: FieldRef<"FormationContent", 'String'>
    readonly title: FieldRef<"FormationContent", 'String'>
    readonly description: FieldRef<"FormationContent", 'String'>
    readonly type: FieldRef<"FormationContent", 'String'>
    readonly order: FieldRef<"FormationContent", 'Int'>
    readonly educationalTitle: FieldRef<"FormationContent", 'String'>
    readonly educationalText: FieldRef<"FormationContent", 'String'>
    readonly imageUrl: FieldRef<"FormationContent", 'String'>
    readonly createdAt: FieldRef<"FormationContent", 'DateTime'>
    readonly updatedAt: FieldRef<"FormationContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormationContent findUnique
   */
  export type FormationContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter, which FormationContent to fetch.
     */
    where: FormationContentWhereUniqueInput
  }

  /**
   * FormationContent findUniqueOrThrow
   */
  export type FormationContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter, which FormationContent to fetch.
     */
    where: FormationContentWhereUniqueInput
  }

  /**
   * FormationContent findFirst
   */
  export type FormationContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter, which FormationContent to fetch.
     */
    where?: FormationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationContents to fetch.
     */
    orderBy?: FormationContentOrderByWithRelationInput | FormationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationContents.
     */
    cursor?: FormationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationContents.
     */
    distinct?: FormationContentScalarFieldEnum | FormationContentScalarFieldEnum[]
  }

  /**
   * FormationContent findFirstOrThrow
   */
  export type FormationContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter, which FormationContent to fetch.
     */
    where?: FormationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationContents to fetch.
     */
    orderBy?: FormationContentOrderByWithRelationInput | FormationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationContents.
     */
    cursor?: FormationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationContents.
     */
    distinct?: FormationContentScalarFieldEnum | FormationContentScalarFieldEnum[]
  }

  /**
   * FormationContent findMany
   */
  export type FormationContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter, which FormationContents to fetch.
     */
    where?: FormationContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationContents to fetch.
     */
    orderBy?: FormationContentOrderByWithRelationInput | FormationContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormationContents.
     */
    cursor?: FormationContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationContents.
     */
    skip?: number
    distinct?: FormationContentScalarFieldEnum | FormationContentScalarFieldEnum[]
  }

  /**
   * FormationContent create
   */
  export type FormationContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * The data needed to create a FormationContent.
     */
    data: XOR<FormationContentCreateInput, FormationContentUncheckedCreateInput>
  }

  /**
   * FormationContent createMany
   */
  export type FormationContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormationContents.
     */
    data: FormationContentCreateManyInput | FormationContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormationContent createManyAndReturn
   */
  export type FormationContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * The data used to create many FormationContents.
     */
    data: FormationContentCreateManyInput | FormationContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationContent update
   */
  export type FormationContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * The data needed to update a FormationContent.
     */
    data: XOR<FormationContentUpdateInput, FormationContentUncheckedUpdateInput>
    /**
     * Choose, which FormationContent to update.
     */
    where: FormationContentWhereUniqueInput
  }

  /**
   * FormationContent updateMany
   */
  export type FormationContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormationContents.
     */
    data: XOR<FormationContentUpdateManyMutationInput, FormationContentUncheckedUpdateManyInput>
    /**
     * Filter which FormationContents to update
     */
    where?: FormationContentWhereInput
    /**
     * Limit how many FormationContents to update.
     */
    limit?: number
  }

  /**
   * FormationContent updateManyAndReturn
   */
  export type FormationContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * The data used to update FormationContents.
     */
    data: XOR<FormationContentUpdateManyMutationInput, FormationContentUncheckedUpdateManyInput>
    /**
     * Filter which FormationContents to update
     */
    where?: FormationContentWhereInput
    /**
     * Limit how many FormationContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationContent upsert
   */
  export type FormationContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * The filter to search for the FormationContent to update in case it exists.
     */
    where: FormationContentWhereUniqueInput
    /**
     * In case the FormationContent found by the `where` argument doesn't exist, create a new FormationContent with this data.
     */
    create: XOR<FormationContentCreateInput, FormationContentUncheckedCreateInput>
    /**
     * In case the FormationContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormationContentUpdateInput, FormationContentUncheckedUpdateInput>
  }

  /**
   * FormationContent delete
   */
  export type FormationContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    /**
     * Filter which FormationContent to delete.
     */
    where: FormationContentWhereUniqueInput
  }

  /**
   * FormationContent deleteMany
   */
  export type FormationContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationContents to delete
     */
    where?: FormationContentWhereInput
    /**
     * Limit how many FormationContents to delete.
     */
    limit?: number
  }

  /**
   * FormationContent.steps
   */
  export type FormationContent$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    where?: FormationStepWhereInput
    orderBy?: FormationStepOrderByWithRelationInput | FormationStepOrderByWithRelationInput[]
    cursor?: FormationStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormationStepScalarFieldEnum | FormationStepScalarFieldEnum[]
  }

  /**
   * FormationContent.questions
   */
  export type FormationContent$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    where?: FormationQuestionWhereInput
    orderBy?: FormationQuestionOrderByWithRelationInput | FormationQuestionOrderByWithRelationInput[]
    cursor?: FormationQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormationQuestionScalarFieldEnum | FormationQuestionScalarFieldEnum[]
  }

  /**
   * FormationContent without action
   */
  export type FormationContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
  }


  /**
   * Model FormationStep
   */

  export type AggregateFormationStep = {
    _count: FormationStepCountAggregateOutputType | null
    _min: FormationStepMinAggregateOutputType | null
    _max: FormationStepMaxAggregateOutputType | null
  }

  export type FormationStepMinAggregateOutputType = {
    id: string | null
    stepId: string | null
    contentId: string | null
    title: string | null
    instruction: string | null
    validationEvent: string | null
    validationType: string | null
    hint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationStepMaxAggregateOutputType = {
    id: string | null
    stepId: string | null
    contentId: string | null
    title: string | null
    instruction: string | null
    validationEvent: string | null
    validationType: string | null
    hint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationStepCountAggregateOutputType = {
    id: number
    stepId: number
    contentId: number
    title: number
    instruction: number
    validationEvent: number
    validationType: number
    hint: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormationStepMinAggregateInputType = {
    id?: true
    stepId?: true
    contentId?: true
    title?: true
    instruction?: true
    validationEvent?: true
    validationType?: true
    hint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationStepMaxAggregateInputType = {
    id?: true
    stepId?: true
    contentId?: true
    title?: true
    instruction?: true
    validationEvent?: true
    validationType?: true
    hint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationStepCountAggregateInputType = {
    id?: true
    stepId?: true
    contentId?: true
    title?: true
    instruction?: true
    validationEvent?: true
    validationType?: true
    hint?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormationStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationStep to aggregate.
     */
    where?: FormationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationSteps to fetch.
     */
    orderBy?: FormationStepOrderByWithRelationInput | FormationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormationSteps
    **/
    _count?: true | FormationStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormationStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormationStepMaxAggregateInputType
  }

  export type GetFormationStepAggregateType<T extends FormationStepAggregateArgs> = {
        [P in keyof T & keyof AggregateFormationStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormationStep[P]>
      : GetScalarType<T[P], AggregateFormationStep[P]>
  }




  export type FormationStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationStepWhereInput
    orderBy?: FormationStepOrderByWithAggregationInput | FormationStepOrderByWithAggregationInput[]
    by: FormationStepScalarFieldEnum[] | FormationStepScalarFieldEnum
    having?: FormationStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormationStepCountAggregateInputType | true
    _min?: FormationStepMinAggregateInputType
    _max?: FormationStepMaxAggregateInputType
  }

  export type FormationStepGroupByOutputType = {
    id: string
    stepId: string
    contentId: string
    title: string
    instruction: string
    validationEvent: string
    validationType: string
    hint: string | null
    createdAt: Date
    updatedAt: Date
    _count: FormationStepCountAggregateOutputType | null
    _min: FormationStepMinAggregateOutputType | null
    _max: FormationStepMaxAggregateOutputType | null
  }

  type GetFormationStepGroupByPayload<T extends FormationStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormationStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormationStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormationStepGroupByOutputType[P]>
            : GetScalarType<T[P], FormationStepGroupByOutputType[P]>
        }
      >
    >


  export type FormationStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    contentId?: boolean
    title?: boolean
    instruction?: boolean
    validationEvent?: boolean
    validationType?: boolean
    hint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationStep"]>

  export type FormationStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    contentId?: boolean
    title?: boolean
    instruction?: boolean
    validationEvent?: boolean
    validationType?: boolean
    hint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationStep"]>

  export type FormationStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stepId?: boolean
    contentId?: boolean
    title?: boolean
    instruction?: boolean
    validationEvent?: boolean
    validationType?: boolean
    hint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationStep"]>

  export type FormationStepSelectScalar = {
    id?: boolean
    stepId?: boolean
    contentId?: boolean
    title?: boolean
    instruction?: boolean
    validationEvent?: boolean
    validationType?: boolean
    hint?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormationStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stepId" | "contentId" | "title" | "instruction" | "validationEvent" | "validationType" | "hint" | "createdAt" | "updatedAt", ExtArgs["result"]["formationStep"]>
  export type FormationStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }
  export type FormationStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }
  export type FormationStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }

  export type $FormationStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormationStep"
    objects: {
      content: Prisma.$FormationContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stepId: string
      contentId: string
      title: string
      instruction: string
      validationEvent: string
      validationType: string
      hint: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formationStep"]>
    composites: {}
  }

  type FormationStepGetPayload<S extends boolean | null | undefined | FormationStepDefaultArgs> = $Result.GetResult<Prisma.$FormationStepPayload, S>

  type FormationStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormationStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormationStepCountAggregateInputType | true
    }

  export interface FormationStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormationStep'], meta: { name: 'FormationStep' } }
    /**
     * Find zero or one FormationStep that matches the filter.
     * @param {FormationStepFindUniqueArgs} args - Arguments to find a FormationStep
     * @example
     * // Get one FormationStep
     * const formationStep = await prisma.formationStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormationStepFindUniqueArgs>(args: SelectSubset<T, FormationStepFindUniqueArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormationStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormationStepFindUniqueOrThrowArgs} args - Arguments to find a FormationStep
     * @example
     * // Get one FormationStep
     * const formationStep = await prisma.formationStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormationStepFindUniqueOrThrowArgs>(args: SelectSubset<T, FormationStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepFindFirstArgs} args - Arguments to find a FormationStep
     * @example
     * // Get one FormationStep
     * const formationStep = await prisma.formationStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormationStepFindFirstArgs>(args?: SelectSubset<T, FormationStepFindFirstArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepFindFirstOrThrowArgs} args - Arguments to find a FormationStep
     * @example
     * // Get one FormationStep
     * const formationStep = await prisma.formationStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormationStepFindFirstOrThrowArgs>(args?: SelectSubset<T, FormationStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormationSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormationSteps
     * const formationSteps = await prisma.formationStep.findMany()
     * 
     * // Get first 10 FormationSteps
     * const formationSteps = await prisma.formationStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formationStepWithIdOnly = await prisma.formationStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormationStepFindManyArgs>(args?: SelectSubset<T, FormationStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormationStep.
     * @param {FormationStepCreateArgs} args - Arguments to create a FormationStep.
     * @example
     * // Create one FormationStep
     * const FormationStep = await prisma.formationStep.create({
     *   data: {
     *     // ... data to create a FormationStep
     *   }
     * })
     * 
     */
    create<T extends FormationStepCreateArgs>(args: SelectSubset<T, FormationStepCreateArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormationSteps.
     * @param {FormationStepCreateManyArgs} args - Arguments to create many FormationSteps.
     * @example
     * // Create many FormationSteps
     * const formationStep = await prisma.formationStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormationStepCreateManyArgs>(args?: SelectSubset<T, FormationStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormationSteps and returns the data saved in the database.
     * @param {FormationStepCreateManyAndReturnArgs} args - Arguments to create many FormationSteps.
     * @example
     * // Create many FormationSteps
     * const formationStep = await prisma.formationStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormationSteps and only return the `id`
     * const formationStepWithIdOnly = await prisma.formationStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormationStepCreateManyAndReturnArgs>(args?: SelectSubset<T, FormationStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormationStep.
     * @param {FormationStepDeleteArgs} args - Arguments to delete one FormationStep.
     * @example
     * // Delete one FormationStep
     * const FormationStep = await prisma.formationStep.delete({
     *   where: {
     *     // ... filter to delete one FormationStep
     *   }
     * })
     * 
     */
    delete<T extends FormationStepDeleteArgs>(args: SelectSubset<T, FormationStepDeleteArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormationStep.
     * @param {FormationStepUpdateArgs} args - Arguments to update one FormationStep.
     * @example
     * // Update one FormationStep
     * const formationStep = await prisma.formationStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormationStepUpdateArgs>(args: SelectSubset<T, FormationStepUpdateArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormationSteps.
     * @param {FormationStepDeleteManyArgs} args - Arguments to filter FormationSteps to delete.
     * @example
     * // Delete a few FormationSteps
     * const { count } = await prisma.formationStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormationStepDeleteManyArgs>(args?: SelectSubset<T, FormationStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormationSteps
     * const formationStep = await prisma.formationStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormationStepUpdateManyArgs>(args: SelectSubset<T, FormationStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationSteps and returns the data updated in the database.
     * @param {FormationStepUpdateManyAndReturnArgs} args - Arguments to update many FormationSteps.
     * @example
     * // Update many FormationSteps
     * const formationStep = await prisma.formationStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormationSteps and only return the `id`
     * const formationStepWithIdOnly = await prisma.formationStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormationStepUpdateManyAndReturnArgs>(args: SelectSubset<T, FormationStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormationStep.
     * @param {FormationStepUpsertArgs} args - Arguments to update or create a FormationStep.
     * @example
     * // Update or create a FormationStep
     * const formationStep = await prisma.formationStep.upsert({
     *   create: {
     *     // ... data to create a FormationStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormationStep we want to update
     *   }
     * })
     */
    upsert<T extends FormationStepUpsertArgs>(args: SelectSubset<T, FormationStepUpsertArgs<ExtArgs>>): Prisma__FormationStepClient<$Result.GetResult<Prisma.$FormationStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormationSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepCountArgs} args - Arguments to filter FormationSteps to count.
     * @example
     * // Count the number of FormationSteps
     * const count = await prisma.formationStep.count({
     *   where: {
     *     // ... the filter for the FormationSteps we want to count
     *   }
     * })
    **/
    count<T extends FormationStepCountArgs>(
      args?: Subset<T, FormationStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormationStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormationStepAggregateArgs>(args: Subset<T, FormationStepAggregateArgs>): Prisma.PrismaPromise<GetFormationStepAggregateType<T>>

    /**
     * Group by FormationStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormationStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormationStepGroupByArgs['orderBy'] }
        : { orderBy?: FormationStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormationStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormationStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormationStep model
   */
  readonly fields: FormationStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormationStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormationStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends FormationContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormationContentDefaultArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormationStep model
   */
  interface FormationStepFieldRefs {
    readonly id: FieldRef<"FormationStep", 'String'>
    readonly stepId: FieldRef<"FormationStep", 'String'>
    readonly contentId: FieldRef<"FormationStep", 'String'>
    readonly title: FieldRef<"FormationStep", 'String'>
    readonly instruction: FieldRef<"FormationStep", 'String'>
    readonly validationEvent: FieldRef<"FormationStep", 'String'>
    readonly validationType: FieldRef<"FormationStep", 'String'>
    readonly hint: FieldRef<"FormationStep", 'String'>
    readonly createdAt: FieldRef<"FormationStep", 'DateTime'>
    readonly updatedAt: FieldRef<"FormationStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormationStep findUnique
   */
  export type FormationStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter, which FormationStep to fetch.
     */
    where: FormationStepWhereUniqueInput
  }

  /**
   * FormationStep findUniqueOrThrow
   */
  export type FormationStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter, which FormationStep to fetch.
     */
    where: FormationStepWhereUniqueInput
  }

  /**
   * FormationStep findFirst
   */
  export type FormationStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter, which FormationStep to fetch.
     */
    where?: FormationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationSteps to fetch.
     */
    orderBy?: FormationStepOrderByWithRelationInput | FormationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationSteps.
     */
    cursor?: FormationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationSteps.
     */
    distinct?: FormationStepScalarFieldEnum | FormationStepScalarFieldEnum[]
  }

  /**
   * FormationStep findFirstOrThrow
   */
  export type FormationStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter, which FormationStep to fetch.
     */
    where?: FormationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationSteps to fetch.
     */
    orderBy?: FormationStepOrderByWithRelationInput | FormationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationSteps.
     */
    cursor?: FormationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationSteps.
     */
    distinct?: FormationStepScalarFieldEnum | FormationStepScalarFieldEnum[]
  }

  /**
   * FormationStep findMany
   */
  export type FormationStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter, which FormationSteps to fetch.
     */
    where?: FormationStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationSteps to fetch.
     */
    orderBy?: FormationStepOrderByWithRelationInput | FormationStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormationSteps.
     */
    cursor?: FormationStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationSteps.
     */
    skip?: number
    distinct?: FormationStepScalarFieldEnum | FormationStepScalarFieldEnum[]
  }

  /**
   * FormationStep create
   */
  export type FormationStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * The data needed to create a FormationStep.
     */
    data: XOR<FormationStepCreateInput, FormationStepUncheckedCreateInput>
  }

  /**
   * FormationStep createMany
   */
  export type FormationStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormationSteps.
     */
    data: FormationStepCreateManyInput | FormationStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormationStep createManyAndReturn
   */
  export type FormationStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * The data used to create many FormationSteps.
     */
    data: FormationStepCreateManyInput | FormationStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationStep update
   */
  export type FormationStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * The data needed to update a FormationStep.
     */
    data: XOR<FormationStepUpdateInput, FormationStepUncheckedUpdateInput>
    /**
     * Choose, which FormationStep to update.
     */
    where: FormationStepWhereUniqueInput
  }

  /**
   * FormationStep updateMany
   */
  export type FormationStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormationSteps.
     */
    data: XOR<FormationStepUpdateManyMutationInput, FormationStepUncheckedUpdateManyInput>
    /**
     * Filter which FormationSteps to update
     */
    where?: FormationStepWhereInput
    /**
     * Limit how many FormationSteps to update.
     */
    limit?: number
  }

  /**
   * FormationStep updateManyAndReturn
   */
  export type FormationStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * The data used to update FormationSteps.
     */
    data: XOR<FormationStepUpdateManyMutationInput, FormationStepUncheckedUpdateManyInput>
    /**
     * Filter which FormationSteps to update
     */
    where?: FormationStepWhereInput
    /**
     * Limit how many FormationSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationStep upsert
   */
  export type FormationStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * The filter to search for the FormationStep to update in case it exists.
     */
    where: FormationStepWhereUniqueInput
    /**
     * In case the FormationStep found by the `where` argument doesn't exist, create a new FormationStep with this data.
     */
    create: XOR<FormationStepCreateInput, FormationStepUncheckedCreateInput>
    /**
     * In case the FormationStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormationStepUpdateInput, FormationStepUncheckedUpdateInput>
  }

  /**
   * FormationStep delete
   */
  export type FormationStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
    /**
     * Filter which FormationStep to delete.
     */
    where: FormationStepWhereUniqueInput
  }

  /**
   * FormationStep deleteMany
   */
  export type FormationStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationSteps to delete
     */
    where?: FormationStepWhereInput
    /**
     * Limit how many FormationSteps to delete.
     */
    limit?: number
  }

  /**
   * FormationStep without action
   */
  export type FormationStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationStep
     */
    select?: FormationStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationStep
     */
    omit?: FormationStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationStepInclude<ExtArgs> | null
  }


  /**
   * Model FormationQuestion
   */

  export type AggregateFormationQuestion = {
    _count: FormationQuestionCountAggregateOutputType | null
    _min: FormationQuestionMinAggregateOutputType | null
    _max: FormationQuestionMaxAggregateOutputType | null
  }

  export type FormationQuestionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    contentId: string | null
    text: string | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationQuestionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    contentId: string | null
    text: string | null
    type: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationQuestionCountAggregateOutputType = {
    id: number
    questionId: number
    contentId: number
    text: number
    type: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormationQuestionMinAggregateInputType = {
    id?: true
    questionId?: true
    contentId?: true
    text?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationQuestionMaxAggregateInputType = {
    id?: true
    questionId?: true
    contentId?: true
    text?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationQuestionCountAggregateInputType = {
    id?: true
    questionId?: true
    contentId?: true
    text?: true
    type?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormationQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationQuestion to aggregate.
     */
    where?: FormationQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationQuestions to fetch.
     */
    orderBy?: FormationQuestionOrderByWithRelationInput | FormationQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormationQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormationQuestions
    **/
    _count?: true | FormationQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormationQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormationQuestionMaxAggregateInputType
  }

  export type GetFormationQuestionAggregateType<T extends FormationQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormationQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormationQuestion[P]>
      : GetScalarType<T[P], AggregateFormationQuestion[P]>
  }




  export type FormationQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationQuestionWhereInput
    orderBy?: FormationQuestionOrderByWithAggregationInput | FormationQuestionOrderByWithAggregationInput[]
    by: FormationQuestionScalarFieldEnum[] | FormationQuestionScalarFieldEnum
    having?: FormationQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormationQuestionCountAggregateInputType | true
    _min?: FormationQuestionMinAggregateInputType
    _max?: FormationQuestionMaxAggregateInputType
  }

  export type FormationQuestionGroupByOutputType = {
    id: string
    questionId: string
    contentId: string
    text: string
    type: string
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: FormationQuestionCountAggregateOutputType | null
    _min: FormationQuestionMinAggregateOutputType | null
    _max: FormationQuestionMaxAggregateOutputType | null
  }

  type GetFormationQuestionGroupByPayload<T extends FormationQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormationQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormationQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormationQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], FormationQuestionGroupByOutputType[P]>
        }
      >
    >


  export type FormationQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    contentId?: boolean
    text?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
    options?: boolean | FormationQuestion$optionsArgs<ExtArgs>
    _count?: boolean | FormationQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationQuestion"]>

  export type FormationQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    contentId?: boolean
    text?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationQuestion"]>

  export type FormationQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    contentId?: boolean
    text?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationQuestion"]>

  export type FormationQuestionSelectScalar = {
    id?: boolean
    questionId?: boolean
    contentId?: boolean
    text?: boolean
    type?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormationQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "contentId" | "text" | "type" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["formationQuestion"]>
  export type FormationQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
    options?: boolean | FormationQuestion$optionsArgs<ExtArgs>
    _count?: boolean | FormationQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormationQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }
  export type FormationQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | FormationContentDefaultArgs<ExtArgs>
  }

  export type $FormationQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormationQuestion"
    objects: {
      content: Prisma.$FormationContentPayload<ExtArgs>
      options: Prisma.$FormationOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      contentId: string
      text: string
      type: string
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formationQuestion"]>
    composites: {}
  }

  type FormationQuestionGetPayload<S extends boolean | null | undefined | FormationQuestionDefaultArgs> = $Result.GetResult<Prisma.$FormationQuestionPayload, S>

  type FormationQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormationQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormationQuestionCountAggregateInputType | true
    }

  export interface FormationQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormationQuestion'], meta: { name: 'FormationQuestion' } }
    /**
     * Find zero or one FormationQuestion that matches the filter.
     * @param {FormationQuestionFindUniqueArgs} args - Arguments to find a FormationQuestion
     * @example
     * // Get one FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormationQuestionFindUniqueArgs>(args: SelectSubset<T, FormationQuestionFindUniqueArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormationQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormationQuestionFindUniqueOrThrowArgs} args - Arguments to find a FormationQuestion
     * @example
     * // Get one FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormationQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormationQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionFindFirstArgs} args - Arguments to find a FormationQuestion
     * @example
     * // Get one FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormationQuestionFindFirstArgs>(args?: SelectSubset<T, FormationQuestionFindFirstArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionFindFirstOrThrowArgs} args - Arguments to find a FormationQuestion
     * @example
     * // Get one FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormationQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormationQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormationQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormationQuestions
     * const formationQuestions = await prisma.formationQuestion.findMany()
     * 
     * // Get first 10 FormationQuestions
     * const formationQuestions = await prisma.formationQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formationQuestionWithIdOnly = await prisma.formationQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormationQuestionFindManyArgs>(args?: SelectSubset<T, FormationQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormationQuestion.
     * @param {FormationQuestionCreateArgs} args - Arguments to create a FormationQuestion.
     * @example
     * // Create one FormationQuestion
     * const FormationQuestion = await prisma.formationQuestion.create({
     *   data: {
     *     // ... data to create a FormationQuestion
     *   }
     * })
     * 
     */
    create<T extends FormationQuestionCreateArgs>(args: SelectSubset<T, FormationQuestionCreateArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormationQuestions.
     * @param {FormationQuestionCreateManyArgs} args - Arguments to create many FormationQuestions.
     * @example
     * // Create many FormationQuestions
     * const formationQuestion = await prisma.formationQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormationQuestionCreateManyArgs>(args?: SelectSubset<T, FormationQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormationQuestions and returns the data saved in the database.
     * @param {FormationQuestionCreateManyAndReturnArgs} args - Arguments to create many FormationQuestions.
     * @example
     * // Create many FormationQuestions
     * const formationQuestion = await prisma.formationQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormationQuestions and only return the `id`
     * const formationQuestionWithIdOnly = await prisma.formationQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormationQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormationQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormationQuestion.
     * @param {FormationQuestionDeleteArgs} args - Arguments to delete one FormationQuestion.
     * @example
     * // Delete one FormationQuestion
     * const FormationQuestion = await prisma.formationQuestion.delete({
     *   where: {
     *     // ... filter to delete one FormationQuestion
     *   }
     * })
     * 
     */
    delete<T extends FormationQuestionDeleteArgs>(args: SelectSubset<T, FormationQuestionDeleteArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormationQuestion.
     * @param {FormationQuestionUpdateArgs} args - Arguments to update one FormationQuestion.
     * @example
     * // Update one FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormationQuestionUpdateArgs>(args: SelectSubset<T, FormationQuestionUpdateArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormationQuestions.
     * @param {FormationQuestionDeleteManyArgs} args - Arguments to filter FormationQuestions to delete.
     * @example
     * // Delete a few FormationQuestions
     * const { count } = await prisma.formationQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormationQuestionDeleteManyArgs>(args?: SelectSubset<T, FormationQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormationQuestions
     * const formationQuestion = await prisma.formationQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormationQuestionUpdateManyArgs>(args: SelectSubset<T, FormationQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationQuestions and returns the data updated in the database.
     * @param {FormationQuestionUpdateManyAndReturnArgs} args - Arguments to update many FormationQuestions.
     * @example
     * // Update many FormationQuestions
     * const formationQuestion = await prisma.formationQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormationQuestions and only return the `id`
     * const formationQuestionWithIdOnly = await prisma.formationQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormationQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, FormationQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormationQuestion.
     * @param {FormationQuestionUpsertArgs} args - Arguments to update or create a FormationQuestion.
     * @example
     * // Update or create a FormationQuestion
     * const formationQuestion = await prisma.formationQuestion.upsert({
     *   create: {
     *     // ... data to create a FormationQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormationQuestion we want to update
     *   }
     * })
     */
    upsert<T extends FormationQuestionUpsertArgs>(args: SelectSubset<T, FormationQuestionUpsertArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormationQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionCountArgs} args - Arguments to filter FormationQuestions to count.
     * @example
     * // Count the number of FormationQuestions
     * const count = await prisma.formationQuestion.count({
     *   where: {
     *     // ... the filter for the FormationQuestions we want to count
     *   }
     * })
    **/
    count<T extends FormationQuestionCountArgs>(
      args?: Subset<T, FormationQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormationQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormationQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormationQuestionAggregateArgs>(args: Subset<T, FormationQuestionAggregateArgs>): Prisma.PrismaPromise<GetFormationQuestionAggregateType<T>>

    /**
     * Group by FormationQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormationQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormationQuestionGroupByArgs['orderBy'] }
        : { orderBy?: FormationQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormationQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormationQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormationQuestion model
   */
  readonly fields: FormationQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormationQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormationQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends FormationContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormationContentDefaultArgs<ExtArgs>>): Prisma__FormationContentClient<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends FormationQuestion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, FormationQuestion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormationQuestion model
   */
  interface FormationQuestionFieldRefs {
    readonly id: FieldRef<"FormationQuestion", 'String'>
    readonly questionId: FieldRef<"FormationQuestion", 'String'>
    readonly contentId: FieldRef<"FormationQuestion", 'String'>
    readonly text: FieldRef<"FormationQuestion", 'String'>
    readonly type: FieldRef<"FormationQuestion", 'String'>
    readonly image: FieldRef<"FormationQuestion", 'String'>
    readonly createdAt: FieldRef<"FormationQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"FormationQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormationQuestion findUnique
   */
  export type FormationQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FormationQuestion to fetch.
     */
    where: FormationQuestionWhereUniqueInput
  }

  /**
   * FormationQuestion findUniqueOrThrow
   */
  export type FormationQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FormationQuestion to fetch.
     */
    where: FormationQuestionWhereUniqueInput
  }

  /**
   * FormationQuestion findFirst
   */
  export type FormationQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FormationQuestion to fetch.
     */
    where?: FormationQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationQuestions to fetch.
     */
    orderBy?: FormationQuestionOrderByWithRelationInput | FormationQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationQuestions.
     */
    cursor?: FormationQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationQuestions.
     */
    distinct?: FormationQuestionScalarFieldEnum | FormationQuestionScalarFieldEnum[]
  }

  /**
   * FormationQuestion findFirstOrThrow
   */
  export type FormationQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FormationQuestion to fetch.
     */
    where?: FormationQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationQuestions to fetch.
     */
    orderBy?: FormationQuestionOrderByWithRelationInput | FormationQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationQuestions.
     */
    cursor?: FormationQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationQuestions.
     */
    distinct?: FormationQuestionScalarFieldEnum | FormationQuestionScalarFieldEnum[]
  }

  /**
   * FormationQuestion findMany
   */
  export type FormationQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter, which FormationQuestions to fetch.
     */
    where?: FormationQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationQuestions to fetch.
     */
    orderBy?: FormationQuestionOrderByWithRelationInput | FormationQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormationQuestions.
     */
    cursor?: FormationQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationQuestions.
     */
    skip?: number
    distinct?: FormationQuestionScalarFieldEnum | FormationQuestionScalarFieldEnum[]
  }

  /**
   * FormationQuestion create
   */
  export type FormationQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormationQuestion.
     */
    data: XOR<FormationQuestionCreateInput, FormationQuestionUncheckedCreateInput>
  }

  /**
   * FormationQuestion createMany
   */
  export type FormationQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormationQuestions.
     */
    data: FormationQuestionCreateManyInput | FormationQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormationQuestion createManyAndReturn
   */
  export type FormationQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many FormationQuestions.
     */
    data: FormationQuestionCreateManyInput | FormationQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationQuestion update
   */
  export type FormationQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormationQuestion.
     */
    data: XOR<FormationQuestionUpdateInput, FormationQuestionUncheckedUpdateInput>
    /**
     * Choose, which FormationQuestion to update.
     */
    where: FormationQuestionWhereUniqueInput
  }

  /**
   * FormationQuestion updateMany
   */
  export type FormationQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormationQuestions.
     */
    data: XOR<FormationQuestionUpdateManyMutationInput, FormationQuestionUncheckedUpdateManyInput>
    /**
     * Filter which FormationQuestions to update
     */
    where?: FormationQuestionWhereInput
    /**
     * Limit how many FormationQuestions to update.
     */
    limit?: number
  }

  /**
   * FormationQuestion updateManyAndReturn
   */
  export type FormationQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * The data used to update FormationQuestions.
     */
    data: XOR<FormationQuestionUpdateManyMutationInput, FormationQuestionUncheckedUpdateManyInput>
    /**
     * Filter which FormationQuestions to update
     */
    where?: FormationQuestionWhereInput
    /**
     * Limit how many FormationQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationQuestion upsert
   */
  export type FormationQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormationQuestion to update in case it exists.
     */
    where: FormationQuestionWhereUniqueInput
    /**
     * In case the FormationQuestion found by the `where` argument doesn't exist, create a new FormationQuestion with this data.
     */
    create: XOR<FormationQuestionCreateInput, FormationQuestionUncheckedCreateInput>
    /**
     * In case the FormationQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormationQuestionUpdateInput, FormationQuestionUncheckedUpdateInput>
  }

  /**
   * FormationQuestion delete
   */
  export type FormationQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
    /**
     * Filter which FormationQuestion to delete.
     */
    where: FormationQuestionWhereUniqueInput
  }

  /**
   * FormationQuestion deleteMany
   */
  export type FormationQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationQuestions to delete
     */
    where?: FormationQuestionWhereInput
    /**
     * Limit how many FormationQuestions to delete.
     */
    limit?: number
  }

  /**
   * FormationQuestion.options
   */
  export type FormationQuestion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    where?: FormationOptionWhereInput
    orderBy?: FormationOptionOrderByWithRelationInput | FormationOptionOrderByWithRelationInput[]
    cursor?: FormationOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormationOptionScalarFieldEnum | FormationOptionScalarFieldEnum[]
  }

  /**
   * FormationQuestion without action
   */
  export type FormationQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationQuestion
     */
    select?: FormationQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationQuestion
     */
    omit?: FormationQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationQuestionInclude<ExtArgs> | null
  }


  /**
   * Model FormationOption
   */

  export type AggregateFormationOption = {
    _count: FormationOptionCountAggregateOutputType | null
    _min: FormationOptionMinAggregateOutputType | null
    _max: FormationOptionMaxAggregateOutputType | null
  }

  export type FormationOptionMinAggregateOutputType = {
    id: string | null
    optionId: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationOptionMaxAggregateOutputType = {
    id: string | null
    optionId: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationOptionCountAggregateOutputType = {
    id: number
    optionId: number
    questionId: number
    text: number
    isCorrect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormationOptionMinAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationOptionMaxAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationOptionCountAggregateInputType = {
    id?: true
    optionId?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormationOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationOption to aggregate.
     */
    where?: FormationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationOptions to fetch.
     */
    orderBy?: FormationOptionOrderByWithRelationInput | FormationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormationOptions
    **/
    _count?: true | FormationOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormationOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormationOptionMaxAggregateInputType
  }

  export type GetFormationOptionAggregateType<T extends FormationOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormationOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormationOption[P]>
      : GetScalarType<T[P], AggregateFormationOption[P]>
  }




  export type FormationOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationOptionWhereInput
    orderBy?: FormationOptionOrderByWithAggregationInput | FormationOptionOrderByWithAggregationInput[]
    by: FormationOptionScalarFieldEnum[] | FormationOptionScalarFieldEnum
    having?: FormationOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormationOptionCountAggregateInputType | true
    _min?: FormationOptionMinAggregateInputType
    _max?: FormationOptionMaxAggregateInputType
  }

  export type FormationOptionGroupByOutputType = {
    id: string
    optionId: string
    questionId: string
    text: string
    isCorrect: boolean
    createdAt: Date
    updatedAt: Date
    _count: FormationOptionCountAggregateOutputType | null
    _min: FormationOptionMinAggregateOutputType | null
    _max: FormationOptionMaxAggregateOutputType | null
  }

  type GetFormationOptionGroupByPayload<T extends FormationOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormationOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormationOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormationOptionGroupByOutputType[P]>
            : GetScalarType<T[P], FormationOptionGroupByOutputType[P]>
        }
      >
    >


  export type FormationOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationOption"]>

  export type FormationOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationOption"]>

  export type FormationOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formationOption"]>

  export type FormationOptionSelectScalar = {
    id?: boolean
    optionId?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormationOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "optionId" | "questionId" | "text" | "isCorrect" | "createdAt" | "updatedAt", ExtArgs["result"]["formationOption"]>
  export type FormationOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }
  export type FormationOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }
  export type FormationOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | FormationQuestionDefaultArgs<ExtArgs>
  }

  export type $FormationOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormationOption"
    objects: {
      question: Prisma.$FormationQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      optionId: string
      questionId: string
      text: string
      isCorrect: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formationOption"]>
    composites: {}
  }

  type FormationOptionGetPayload<S extends boolean | null | undefined | FormationOptionDefaultArgs> = $Result.GetResult<Prisma.$FormationOptionPayload, S>

  type FormationOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormationOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormationOptionCountAggregateInputType | true
    }

  export interface FormationOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormationOption'], meta: { name: 'FormationOption' } }
    /**
     * Find zero or one FormationOption that matches the filter.
     * @param {FormationOptionFindUniqueArgs} args - Arguments to find a FormationOption
     * @example
     * // Get one FormationOption
     * const formationOption = await prisma.formationOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormationOptionFindUniqueArgs>(args: SelectSubset<T, FormationOptionFindUniqueArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormationOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormationOptionFindUniqueOrThrowArgs} args - Arguments to find a FormationOption
     * @example
     * // Get one FormationOption
     * const formationOption = await prisma.formationOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormationOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormationOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionFindFirstArgs} args - Arguments to find a FormationOption
     * @example
     * // Get one FormationOption
     * const formationOption = await prisma.formationOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormationOptionFindFirstArgs>(args?: SelectSubset<T, FormationOptionFindFirstArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormationOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionFindFirstOrThrowArgs} args - Arguments to find a FormationOption
     * @example
     * // Get one FormationOption
     * const formationOption = await prisma.formationOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormationOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormationOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormationOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormationOptions
     * const formationOptions = await prisma.formationOption.findMany()
     * 
     * // Get first 10 FormationOptions
     * const formationOptions = await prisma.formationOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formationOptionWithIdOnly = await prisma.formationOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormationOptionFindManyArgs>(args?: SelectSubset<T, FormationOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormationOption.
     * @param {FormationOptionCreateArgs} args - Arguments to create a FormationOption.
     * @example
     * // Create one FormationOption
     * const FormationOption = await prisma.formationOption.create({
     *   data: {
     *     // ... data to create a FormationOption
     *   }
     * })
     * 
     */
    create<T extends FormationOptionCreateArgs>(args: SelectSubset<T, FormationOptionCreateArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormationOptions.
     * @param {FormationOptionCreateManyArgs} args - Arguments to create many FormationOptions.
     * @example
     * // Create many FormationOptions
     * const formationOption = await prisma.formationOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormationOptionCreateManyArgs>(args?: SelectSubset<T, FormationOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormationOptions and returns the data saved in the database.
     * @param {FormationOptionCreateManyAndReturnArgs} args - Arguments to create many FormationOptions.
     * @example
     * // Create many FormationOptions
     * const formationOption = await prisma.formationOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormationOptions and only return the `id`
     * const formationOptionWithIdOnly = await prisma.formationOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormationOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormationOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormationOption.
     * @param {FormationOptionDeleteArgs} args - Arguments to delete one FormationOption.
     * @example
     * // Delete one FormationOption
     * const FormationOption = await prisma.formationOption.delete({
     *   where: {
     *     // ... filter to delete one FormationOption
     *   }
     * })
     * 
     */
    delete<T extends FormationOptionDeleteArgs>(args: SelectSubset<T, FormationOptionDeleteArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormationOption.
     * @param {FormationOptionUpdateArgs} args - Arguments to update one FormationOption.
     * @example
     * // Update one FormationOption
     * const formationOption = await prisma.formationOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormationOptionUpdateArgs>(args: SelectSubset<T, FormationOptionUpdateArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormationOptions.
     * @param {FormationOptionDeleteManyArgs} args - Arguments to filter FormationOptions to delete.
     * @example
     * // Delete a few FormationOptions
     * const { count } = await prisma.formationOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormationOptionDeleteManyArgs>(args?: SelectSubset<T, FormationOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormationOptions
     * const formationOption = await prisma.formationOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormationOptionUpdateManyArgs>(args: SelectSubset<T, FormationOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormationOptions and returns the data updated in the database.
     * @param {FormationOptionUpdateManyAndReturnArgs} args - Arguments to update many FormationOptions.
     * @example
     * // Update many FormationOptions
     * const formationOption = await prisma.formationOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormationOptions and only return the `id`
     * const formationOptionWithIdOnly = await prisma.formationOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormationOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, FormationOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormationOption.
     * @param {FormationOptionUpsertArgs} args - Arguments to update or create a FormationOption.
     * @example
     * // Update or create a FormationOption
     * const formationOption = await prisma.formationOption.upsert({
     *   create: {
     *     // ... data to create a FormationOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormationOption we want to update
     *   }
     * })
     */
    upsert<T extends FormationOptionUpsertArgs>(args: SelectSubset<T, FormationOptionUpsertArgs<ExtArgs>>): Prisma__FormationOptionClient<$Result.GetResult<Prisma.$FormationOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormationOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionCountArgs} args - Arguments to filter FormationOptions to count.
     * @example
     * // Count the number of FormationOptions
     * const count = await prisma.formationOption.count({
     *   where: {
     *     // ... the filter for the FormationOptions we want to count
     *   }
     * })
    **/
    count<T extends FormationOptionCountArgs>(
      args?: Subset<T, FormationOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormationOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormationOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormationOptionAggregateArgs>(args: Subset<T, FormationOptionAggregateArgs>): Prisma.PrismaPromise<GetFormationOptionAggregateType<T>>

    /**
     * Group by FormationOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormationOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormationOptionGroupByArgs['orderBy'] }
        : { orderBy?: FormationOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormationOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormationOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormationOption model
   */
  readonly fields: FormationOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormationOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormationOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends FormationQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormationQuestionDefaultArgs<ExtArgs>>): Prisma__FormationQuestionClient<$Result.GetResult<Prisma.$FormationQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormationOption model
   */
  interface FormationOptionFieldRefs {
    readonly id: FieldRef<"FormationOption", 'String'>
    readonly optionId: FieldRef<"FormationOption", 'String'>
    readonly questionId: FieldRef<"FormationOption", 'String'>
    readonly text: FieldRef<"FormationOption", 'String'>
    readonly isCorrect: FieldRef<"FormationOption", 'Boolean'>
    readonly createdAt: FieldRef<"FormationOption", 'DateTime'>
    readonly updatedAt: FieldRef<"FormationOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormationOption findUnique
   */
  export type FormationOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormationOption to fetch.
     */
    where: FormationOptionWhereUniqueInput
  }

  /**
   * FormationOption findUniqueOrThrow
   */
  export type FormationOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormationOption to fetch.
     */
    where: FormationOptionWhereUniqueInput
  }

  /**
   * FormationOption findFirst
   */
  export type FormationOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormationOption to fetch.
     */
    where?: FormationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationOptions to fetch.
     */
    orderBy?: FormationOptionOrderByWithRelationInput | FormationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationOptions.
     */
    cursor?: FormationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationOptions.
     */
    distinct?: FormationOptionScalarFieldEnum | FormationOptionScalarFieldEnum[]
  }

  /**
   * FormationOption findFirstOrThrow
   */
  export type FormationOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormationOption to fetch.
     */
    where?: FormationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationOptions to fetch.
     */
    orderBy?: FormationOptionOrderByWithRelationInput | FormationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormationOptions.
     */
    cursor?: FormationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormationOptions.
     */
    distinct?: FormationOptionScalarFieldEnum | FormationOptionScalarFieldEnum[]
  }

  /**
   * FormationOption findMany
   */
  export type FormationOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormationOptions to fetch.
     */
    where?: FormationOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormationOptions to fetch.
     */
    orderBy?: FormationOptionOrderByWithRelationInput | FormationOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormationOptions.
     */
    cursor?: FormationOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormationOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormationOptions.
     */
    skip?: number
    distinct?: FormationOptionScalarFieldEnum | FormationOptionScalarFieldEnum[]
  }

  /**
   * FormationOption create
   */
  export type FormationOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormationOption.
     */
    data: XOR<FormationOptionCreateInput, FormationOptionUncheckedCreateInput>
  }

  /**
   * FormationOption createMany
   */
  export type FormationOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormationOptions.
     */
    data: FormationOptionCreateManyInput | FormationOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormationOption createManyAndReturn
   */
  export type FormationOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * The data used to create many FormationOptions.
     */
    data: FormationOptionCreateManyInput | FormationOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationOption update
   */
  export type FormationOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormationOption.
     */
    data: XOR<FormationOptionUpdateInput, FormationOptionUncheckedUpdateInput>
    /**
     * Choose, which FormationOption to update.
     */
    where: FormationOptionWhereUniqueInput
  }

  /**
   * FormationOption updateMany
   */
  export type FormationOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormationOptions.
     */
    data: XOR<FormationOptionUpdateManyMutationInput, FormationOptionUncheckedUpdateManyInput>
    /**
     * Filter which FormationOptions to update
     */
    where?: FormationOptionWhereInput
    /**
     * Limit how many FormationOptions to update.
     */
    limit?: number
  }

  /**
   * FormationOption updateManyAndReturn
   */
  export type FormationOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * The data used to update FormationOptions.
     */
    data: XOR<FormationOptionUpdateManyMutationInput, FormationOptionUncheckedUpdateManyInput>
    /**
     * Filter which FormationOptions to update
     */
    where?: FormationOptionWhereInput
    /**
     * Limit how many FormationOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormationOption upsert
   */
  export type FormationOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormationOption to update in case it exists.
     */
    where: FormationOptionWhereUniqueInput
    /**
     * In case the FormationOption found by the `where` argument doesn't exist, create a new FormationOption with this data.
     */
    create: XOR<FormationOptionCreateInput, FormationOptionUncheckedCreateInput>
    /**
     * In case the FormationOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormationOptionUpdateInput, FormationOptionUncheckedUpdateInput>
  }

  /**
   * FormationOption delete
   */
  export type FormationOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
    /**
     * Filter which FormationOption to delete.
     */
    where: FormationOptionWhereUniqueInput
  }

  /**
   * FormationOption deleteMany
   */
  export type FormationOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormationOptions to delete
     */
    where?: FormationOptionWhereInput
    /**
     * Limit how many FormationOptions to delete.
     */
    limit?: number
  }

  /**
   * FormationOption without action
   */
  export type FormationOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationOption
     */
    select?: FormationOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationOption
     */
    omit?: FormationOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationOptionInclude<ExtArgs> | null
  }


  /**
   * Model Formation
   */

  export type AggregateFormation = {
    _count: FormationCountAggregateOutputType | null
    _min: FormationMinAggregateOutputType | null
    _max: FormationMaxAggregateOutputType | null
  }

  export type FormationMinAggregateOutputType = {
    id: string | null
    formationId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    difficulty: string | null
    duration: string | null
    buildId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationMaxAggregateOutputType = {
    id: string | null
    formationId: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    difficulty: string | null
    duration: string | null
    buildId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormationCountAggregateOutputType = {
    id: number
    formationId: number
    name: number
    description: number
    imageUrl: number
    category: number
    difficulty: number
    duration: number
    objectMapping: number
    buildId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormationMinAggregateInputType = {
    id?: true
    formationId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    buildId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationMaxAggregateInputType = {
    id?: true
    formationId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    buildId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormationCountAggregateInputType = {
    id?: true
    formationId?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    difficulty?: true
    duration?: true
    objectMapping?: true
    buildId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Formation to aggregate.
     */
    where?: FormationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formations to fetch.
     */
    orderBy?: FormationOrderByWithRelationInput | FormationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Formations
    **/
    _count?: true | FormationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormationMaxAggregateInputType
  }

  export type GetFormationAggregateType<T extends FormationAggregateArgs> = {
        [P in keyof T & keyof AggregateFormation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormation[P]>
      : GetScalarType<T[P], AggregateFormation[P]>
  }




  export type FormationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormationWhereInput
    orderBy?: FormationOrderByWithAggregationInput | FormationOrderByWithAggregationInput[]
    by: FormationScalarFieldEnum[] | FormationScalarFieldEnum
    having?: FormationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormationCountAggregateInputType | true
    _min?: FormationMinAggregateInputType
    _max?: FormationMaxAggregateInputType
  }

  export type FormationGroupByOutputType = {
    id: string
    formationId: string
    name: string
    description: string
    imageUrl: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping: JsonValue | null
    buildId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FormationCountAggregateOutputType | null
    _min: FormationMinAggregateOutputType | null
    _max: FormationMaxAggregateOutputType | null
  }

  type GetFormationGroupByPayload<T extends FormationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormationGroupByOutputType[P]>
            : GetScalarType<T[P], FormationGroupByOutputType[P]>
        }
      >
    >


  export type FormationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formationId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    objectMapping?: boolean
    buildId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contents?: boolean | Formation$contentsArgs<ExtArgs>
    _count?: boolean | FormationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formation"]>

  export type FormationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formationId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    objectMapping?: boolean
    buildId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["formation"]>

  export type FormationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formationId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    objectMapping?: boolean
    buildId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["formation"]>

  export type FormationSelectScalar = {
    id?: boolean
    formationId?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    difficulty?: boolean
    duration?: boolean
    objectMapping?: boolean
    buildId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FormationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formationId" | "name" | "description" | "imageUrl" | "category" | "difficulty" | "duration" | "objectMapping" | "buildId" | "createdAt" | "updatedAt", ExtArgs["result"]["formation"]>
  export type FormationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contents?: boolean | Formation$contentsArgs<ExtArgs>
    _count?: boolean | FormationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FormationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Formation"
    objects: {
      contents: Prisma.$FormationContentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formationId: string
      name: string
      description: string
      imageUrl: string | null
      category: string
      difficulty: string
      duration: string
      objectMapping: Prisma.JsonValue | null
      buildId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formation"]>
    composites: {}
  }

  type FormationGetPayload<S extends boolean | null | undefined | FormationDefaultArgs> = $Result.GetResult<Prisma.$FormationPayload, S>

  type FormationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormationCountAggregateInputType | true
    }

  export interface FormationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Formation'], meta: { name: 'Formation' } }
    /**
     * Find zero or one Formation that matches the filter.
     * @param {FormationFindUniqueArgs} args - Arguments to find a Formation
     * @example
     * // Get one Formation
     * const formation = await prisma.formation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormationFindUniqueArgs>(args: SelectSubset<T, FormationFindUniqueArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Formation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormationFindUniqueOrThrowArgs} args - Arguments to find a Formation
     * @example
     * // Get one Formation
     * const formation = await prisma.formation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormationFindUniqueOrThrowArgs>(args: SelectSubset<T, FormationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationFindFirstArgs} args - Arguments to find a Formation
     * @example
     * // Get one Formation
     * const formation = await prisma.formation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormationFindFirstArgs>(args?: SelectSubset<T, FormationFindFirstArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationFindFirstOrThrowArgs} args - Arguments to find a Formation
     * @example
     * // Get one Formation
     * const formation = await prisma.formation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormationFindFirstOrThrowArgs>(args?: SelectSubset<T, FormationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formations
     * const formations = await prisma.formation.findMany()
     * 
     * // Get first 10 Formations
     * const formations = await prisma.formation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formationWithIdOnly = await prisma.formation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormationFindManyArgs>(args?: SelectSubset<T, FormationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Formation.
     * @param {FormationCreateArgs} args - Arguments to create a Formation.
     * @example
     * // Create one Formation
     * const Formation = await prisma.formation.create({
     *   data: {
     *     // ... data to create a Formation
     *   }
     * })
     * 
     */
    create<T extends FormationCreateArgs>(args: SelectSubset<T, FormationCreateArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formations.
     * @param {FormationCreateManyArgs} args - Arguments to create many Formations.
     * @example
     * // Create many Formations
     * const formation = await prisma.formation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormationCreateManyArgs>(args?: SelectSubset<T, FormationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Formations and returns the data saved in the database.
     * @param {FormationCreateManyAndReturnArgs} args - Arguments to create many Formations.
     * @example
     * // Create many Formations
     * const formation = await prisma.formation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Formations and only return the `id`
     * const formationWithIdOnly = await prisma.formation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormationCreateManyAndReturnArgs>(args?: SelectSubset<T, FormationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Formation.
     * @param {FormationDeleteArgs} args - Arguments to delete one Formation.
     * @example
     * // Delete one Formation
     * const Formation = await prisma.formation.delete({
     *   where: {
     *     // ... filter to delete one Formation
     *   }
     * })
     * 
     */
    delete<T extends FormationDeleteArgs>(args: SelectSubset<T, FormationDeleteArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Formation.
     * @param {FormationUpdateArgs} args - Arguments to update one Formation.
     * @example
     * // Update one Formation
     * const formation = await prisma.formation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormationUpdateArgs>(args: SelectSubset<T, FormationUpdateArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formations.
     * @param {FormationDeleteManyArgs} args - Arguments to filter Formations to delete.
     * @example
     * // Delete a few Formations
     * const { count } = await prisma.formation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormationDeleteManyArgs>(args?: SelectSubset<T, FormationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formations
     * const formation = await prisma.formation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormationUpdateManyArgs>(args: SelectSubset<T, FormationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formations and returns the data updated in the database.
     * @param {FormationUpdateManyAndReturnArgs} args - Arguments to update many Formations.
     * @example
     * // Update many Formations
     * const formation = await prisma.formation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Formations and only return the `id`
     * const formationWithIdOnly = await prisma.formation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormationUpdateManyAndReturnArgs>(args: SelectSubset<T, FormationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Formation.
     * @param {FormationUpsertArgs} args - Arguments to update or create a Formation.
     * @example
     * // Update or create a Formation
     * const formation = await prisma.formation.upsert({
     *   create: {
     *     // ... data to create a Formation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formation we want to update
     *   }
     * })
     */
    upsert<T extends FormationUpsertArgs>(args: SelectSubset<T, FormationUpsertArgs<ExtArgs>>): Prisma__FormationClient<$Result.GetResult<Prisma.$FormationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationCountArgs} args - Arguments to filter Formations to count.
     * @example
     * // Count the number of Formations
     * const count = await prisma.formation.count({
     *   where: {
     *     // ... the filter for the Formations we want to count
     *   }
     * })
    **/
    count<T extends FormationCountArgs>(
      args?: Subset<T, FormationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormationAggregateArgs>(args: Subset<T, FormationAggregateArgs>): Prisma.PrismaPromise<GetFormationAggregateType<T>>

    /**
     * Group by Formation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormationGroupByArgs['orderBy'] }
        : { orderBy?: FormationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Formation model
   */
  readonly fields: FormationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Formation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contents<T extends Formation$contentsArgs<ExtArgs> = {}>(args?: Subset<T, Formation$contentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormationContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Formation model
   */
  interface FormationFieldRefs {
    readonly id: FieldRef<"Formation", 'String'>
    readonly formationId: FieldRef<"Formation", 'String'>
    readonly name: FieldRef<"Formation", 'String'>
    readonly description: FieldRef<"Formation", 'String'>
    readonly imageUrl: FieldRef<"Formation", 'String'>
    readonly category: FieldRef<"Formation", 'String'>
    readonly difficulty: FieldRef<"Formation", 'String'>
    readonly duration: FieldRef<"Formation", 'String'>
    readonly objectMapping: FieldRef<"Formation", 'Json'>
    readonly buildId: FieldRef<"Formation", 'String'>
    readonly createdAt: FieldRef<"Formation", 'DateTime'>
    readonly updatedAt: FieldRef<"Formation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Formation findUnique
   */
  export type FormationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter, which Formation to fetch.
     */
    where: FormationWhereUniqueInput
  }

  /**
   * Formation findUniqueOrThrow
   */
  export type FormationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter, which Formation to fetch.
     */
    where: FormationWhereUniqueInput
  }

  /**
   * Formation findFirst
   */
  export type FormationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter, which Formation to fetch.
     */
    where?: FormationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formations to fetch.
     */
    orderBy?: FormationOrderByWithRelationInput | FormationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formations.
     */
    cursor?: FormationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formations.
     */
    distinct?: FormationScalarFieldEnum | FormationScalarFieldEnum[]
  }

  /**
   * Formation findFirstOrThrow
   */
  export type FormationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter, which Formation to fetch.
     */
    where?: FormationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formations to fetch.
     */
    orderBy?: FormationOrderByWithRelationInput | FormationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Formations.
     */
    cursor?: FormationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Formations.
     */
    distinct?: FormationScalarFieldEnum | FormationScalarFieldEnum[]
  }

  /**
   * Formation findMany
   */
  export type FormationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter, which Formations to fetch.
     */
    where?: FormationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Formations to fetch.
     */
    orderBy?: FormationOrderByWithRelationInput | FormationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Formations.
     */
    cursor?: FormationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Formations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Formations.
     */
    skip?: number
    distinct?: FormationScalarFieldEnum | FormationScalarFieldEnum[]
  }

  /**
   * Formation create
   */
  export type FormationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * The data needed to create a Formation.
     */
    data: XOR<FormationCreateInput, FormationUncheckedCreateInput>
  }

  /**
   * Formation createMany
   */
  export type FormationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Formations.
     */
    data: FormationCreateManyInput | FormationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Formation createManyAndReturn
   */
  export type FormationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * The data used to create many Formations.
     */
    data: FormationCreateManyInput | FormationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Formation update
   */
  export type FormationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * The data needed to update a Formation.
     */
    data: XOR<FormationUpdateInput, FormationUncheckedUpdateInput>
    /**
     * Choose, which Formation to update.
     */
    where: FormationWhereUniqueInput
  }

  /**
   * Formation updateMany
   */
  export type FormationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Formations.
     */
    data: XOR<FormationUpdateManyMutationInput, FormationUncheckedUpdateManyInput>
    /**
     * Filter which Formations to update
     */
    where?: FormationWhereInput
    /**
     * Limit how many Formations to update.
     */
    limit?: number
  }

  /**
   * Formation updateManyAndReturn
   */
  export type FormationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * The data used to update Formations.
     */
    data: XOR<FormationUpdateManyMutationInput, FormationUncheckedUpdateManyInput>
    /**
     * Filter which Formations to update
     */
    where?: FormationWhereInput
    /**
     * Limit how many Formations to update.
     */
    limit?: number
  }

  /**
   * Formation upsert
   */
  export type FormationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * The filter to search for the Formation to update in case it exists.
     */
    where: FormationWhereUniqueInput
    /**
     * In case the Formation found by the `where` argument doesn't exist, create a new Formation with this data.
     */
    create: XOR<FormationCreateInput, FormationUncheckedCreateInput>
    /**
     * In case the Formation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormationUpdateInput, FormationUncheckedUpdateInput>
  }

  /**
   * Formation delete
   */
  export type FormationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
    /**
     * Filter which Formation to delete.
     */
    where: FormationWhereUniqueInput
  }

  /**
   * Formation deleteMany
   */
  export type FormationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Formations to delete
     */
    where?: FormationWhereInput
    /**
     * Limit how many Formations to delete.
     */
    limit?: number
  }

  /**
   * Formation.contents
   */
  export type Formation$contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormationContent
     */
    select?: FormationContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormationContent
     */
    omit?: FormationContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationContentInclude<ExtArgs> | null
    where?: FormationContentWhereInput
    orderBy?: FormationContentOrderByWithRelationInput | FormationContentOrderByWithRelationInput[]
    cursor?: FormationContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormationContentScalarFieldEnum | FormationContentScalarFieldEnum[]
  }

  /**
   * Formation without action
   */
  export type FormationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Formation
     */
    select?: FormationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Formation
     */
    omit?: FormationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    auth0Id: 'auth0Id',
    email: 'email',
    name: 'name',
    azureContainer: 'azureContainer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    sourceType: 'sourceType',
    sourceOrganizationId: 'sourceOrganizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const UserCourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    progress: 'progress',
    lastAccessed: 'lastAccessed',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserCourseScalarFieldEnum = (typeof UserCourseScalarFieldEnum)[keyof typeof UserCourseScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const ScenarioScalarFieldEnum: {
    id: 'id',
    scenarioId: 'scenarioId',
    moduleId: 'moduleId',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScenarioScalarFieldEnum = (typeof ScenarioScalarFieldEnum)[keyof typeof ScenarioScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    scenarioId: 'scenarioId',
    text: 'text',
    type: 'type',
    explanation: 'explanation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    optionId: 'optionId',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const UserModuleScalarFieldEnum: {
    id: 'id',
    userCourseId: 'userCourseId',
    moduleId: 'moduleId',
    completed: 'completed',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserModuleScalarFieldEnum = (typeof UserModuleScalarFieldEnum)[keyof typeof UserModuleScalarFieldEnum]


  export const UserResponseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scenarioId: 'scenarioId',
    questionId: 'questionId',
    selectedAnswers: 'selectedAnswers',
    isCorrect: 'isCorrect',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserResponseScalarFieldEnum = (typeof UserResponseScalarFieldEnum)[keyof typeof UserResponseScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    achievementId: 'achievementId',
    title: 'title',
    description: 'description',
    iconName: 'iconName',
    criteria: 'criteria',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    unlockedAt: 'unlockedAt',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalTimeSpent: 'totalTimeSpent',
    sessionsCompleted: 'sessionsCompleted',
    questionsAnswered: 'questionsAnswered',
    correctAnswers: 'correctAnswers',
    lastActivity: 'lastActivity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    courseId: 'courseId',
    modulesViewed: 'modulesViewed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    azureContainer: 'azureContainer',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const OrganizationTrainingScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    courseId: 'courseId',
    buildId: 'buildId',
    isCustomBuild: 'isCustomBuild',
    isActive: 'isActive',
    assignedAt: 'assignedAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationTrainingScalarFieldEnum = (typeof OrganizationTrainingScalarFieldEnum)[keyof typeof OrganizationTrainingScalarFieldEnum]


  export const OrganizationInvitationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    organizationId: 'organizationId',
    inviteCode: 'inviteCode',
    role: 'role',
    status: 'status',
    invitedBy: 'invitedBy',
    invitedAt: 'invitedAt',
    expiresAt: 'expiresAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationInvitationScalarFieldEnum = (typeof OrganizationInvitationScalarFieldEnum)[keyof typeof OrganizationInvitationScalarFieldEnum]


  export const OrganizationTagScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    color: 'color',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationTagScalarFieldEnum = (typeof OrganizationTagScalarFieldEnum)[keyof typeof OrganizationTagScalarFieldEnum]


  export const UserTagScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tagId: 'tagId',
    assignedAt: 'assignedAt'
  };

  export type UserTagScalarFieldEnum = (typeof UserTagScalarFieldEnum)[keyof typeof UserTagScalarFieldEnum]


  export const TagTrainingScalarFieldEnum: {
    id: 'id',
    tagId: 'tagId',
    courseId: 'courseId',
    assignedAt: 'assignedAt'
  };

  export type TagTrainingScalarFieldEnum = (typeof TagTrainingScalarFieldEnum)[keyof typeof TagTrainingScalarFieldEnum]


  export const FormationContentScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    formationId: 'formationId',
    title: 'title',
    description: 'description',
    type: 'type',
    order: 'order',
    educationalTitle: 'educationalTitle',
    educationalText: 'educationalText',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormationContentScalarFieldEnum = (typeof FormationContentScalarFieldEnum)[keyof typeof FormationContentScalarFieldEnum]


  export const FormationStepScalarFieldEnum: {
    id: 'id',
    stepId: 'stepId',
    contentId: 'contentId',
    title: 'title',
    instruction: 'instruction',
    validationEvent: 'validationEvent',
    validationType: 'validationType',
    hint: 'hint',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormationStepScalarFieldEnum = (typeof FormationStepScalarFieldEnum)[keyof typeof FormationStepScalarFieldEnum]


  export const FormationQuestionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    contentId: 'contentId',
    text: 'text',
    type: 'type',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormationQuestionScalarFieldEnum = (typeof FormationQuestionScalarFieldEnum)[keyof typeof FormationQuestionScalarFieldEnum]


  export const FormationOptionScalarFieldEnum: {
    id: 'id',
    optionId: 'optionId',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormationOptionScalarFieldEnum = (typeof FormationOptionScalarFieldEnum)[keyof typeof FormationOptionScalarFieldEnum]


  export const FormationScalarFieldEnum: {
    id: 'id',
    formationId: 'formationId',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    difficulty: 'difficulty',
    duration: 'duration',
    objectMapping: 'objectMapping',
    buildId: 'buildId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormationScalarFieldEnum = (typeof FormationScalarFieldEnum)[keyof typeof FormationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    auth0Id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    azureContainer?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userCourses?: UserCourseListRelationFilter
    userResponses?: UserResponseListRelationFilter
    userAchievements?: UserAchievementListRelationFilter
    userStats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
    UserSession?: UserSessionListRelationFilter
    organizations?: OrganizationMemberListRelationFilter
    tags?: UserTagListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    azureContainer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userCourses?: UserCourseOrderByRelationAggregateInput
    userResponses?: UserResponseOrderByRelationAggregateInput
    userAchievements?: UserAchievementOrderByRelationAggregateInput
    userStats?: UserStatsOrderByWithRelationInput
    UserSession?: UserSessionOrderByRelationAggregateInput
    organizations?: OrganizationMemberOrderByRelationAggregateInput
    tags?: UserTagOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    auth0Id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    azureContainer?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    userCourses?: UserCourseListRelationFilter
    userResponses?: UserResponseListRelationFilter
    userAchievements?: UserAchievementListRelationFilter
    userStats?: XOR<UserStatsNullableScalarRelationFilter, UserStatsWhereInput> | null
    UserSession?: UserSessionListRelationFilter
    organizations?: OrganizationMemberListRelationFilter
    tags?: UserTagListRelationFilter
  }, "id" | "auth0Id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    azureContainer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    auth0Id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    azureContainer?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    courseId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    imageUrl?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    difficulty?: StringFilter<"Course"> | string
    duration?: StringFilter<"Course"> | string
    sourceType?: StringNullableFilter<"Course"> | string | null
    sourceOrganizationId?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    modules?: ModuleListRelationFilter
    userCourses?: UserCourseListRelationFilter
    userSessions?: UserSessionListRelationFilter
    OrganizationTraining?: OrganizationTrainingListRelationFilter
    TagTraining?: TagTrainingListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceOrganizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleOrderByRelationAggregateInput
    userCourses?: UserCourseOrderByRelationAggregateInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    OrganizationTraining?: OrganizationTrainingOrderByRelationAggregateInput
    TagTraining?: TagTrainingOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_sourceType_sourceOrganizationId?: CourseCourseIdSourceTypeSourceOrganizationIdCompoundUniqueInput
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    courseId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    imageUrl?: StringNullableFilter<"Course"> | string | null
    category?: StringFilter<"Course"> | string
    difficulty?: StringFilter<"Course"> | string
    duration?: StringFilter<"Course"> | string
    sourceType?: StringNullableFilter<"Course"> | string | null
    sourceOrganizationId?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    modules?: ModuleListRelationFilter
    userCourses?: UserCourseListRelationFilter
    userSessions?: UserSessionListRelationFilter
    OrganizationTraining?: OrganizationTrainingListRelationFilter
    TagTraining?: TagTrainingListRelationFilter
  }, "id" | "courseId_sourceType_sourceOrganizationId">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    sourceType?: SortOrderInput | SortOrder
    sourceOrganizationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    courseId?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    category?: StringWithAggregatesFilter<"Course"> | string
    difficulty?: StringWithAggregatesFilter<"Course"> | string
    duration?: StringWithAggregatesFilter<"Course"> | string
    sourceType?: StringNullableWithAggregatesFilter<"Course"> | string | null
    sourceOrganizationId?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type UserCourseWhereInput = {
    AND?: UserCourseWhereInput | UserCourseWhereInput[]
    OR?: UserCourseWhereInput[]
    NOT?: UserCourseWhereInput | UserCourseWhereInput[]
    id?: StringFilter<"UserCourse"> | string
    userId?: StringFilter<"UserCourse"> | string
    courseId?: StringFilter<"UserCourse"> | string
    progress?: IntFilter<"UserCourse"> | number
    lastAccessed?: DateTimeFilter<"UserCourse"> | Date | string
    startedAt?: DateTimeFilter<"UserCourse"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserCourse"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCourse"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    userModules?: UserModuleListRelationFilter
  }

  export type UserCourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    userModules?: UserModuleOrderByRelationAggregateInput
  }

  export type UserCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: UserCourseUserIdCourseIdCompoundUniqueInput
    AND?: UserCourseWhereInput | UserCourseWhereInput[]
    OR?: UserCourseWhereInput[]
    NOT?: UserCourseWhereInput | UserCourseWhereInput[]
    userId?: StringFilter<"UserCourse"> | string
    courseId?: StringFilter<"UserCourse"> | string
    progress?: IntFilter<"UserCourse"> | number
    lastAccessed?: DateTimeFilter<"UserCourse"> | Date | string
    startedAt?: DateTimeFilter<"UserCourse"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserCourse"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCourse"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    userModules?: UserModuleListRelationFilter
  }, "id" | "userId_courseId">

  export type UserCourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCourseCountOrderByAggregateInput
    _avg?: UserCourseAvgOrderByAggregateInput
    _max?: UserCourseMaxOrderByAggregateInput
    _min?: UserCourseMinOrderByAggregateInput
    _sum?: UserCourseSumOrderByAggregateInput
  }

  export type UserCourseScalarWhereWithAggregatesInput = {
    AND?: UserCourseScalarWhereWithAggregatesInput | UserCourseScalarWhereWithAggregatesInput[]
    OR?: UserCourseScalarWhereWithAggregatesInput[]
    NOT?: UserCourseScalarWhereWithAggregatesInput | UserCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCourse"> | string
    userId?: StringWithAggregatesFilter<"UserCourse"> | string
    courseId?: StringWithAggregatesFilter<"UserCourse"> | string
    progress?: IntWithAggregatesFilter<"UserCourse"> | number
    lastAccessed?: DateTimeWithAggregatesFilter<"UserCourse"> | Date | string
    startedAt?: DateTimeWithAggregatesFilter<"UserCourse"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserCourse"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserCourse"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    moduleId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    scenarios?: ScenarioListRelationFilter
    userModules?: UserModuleListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    scenarios?: ScenarioOrderByRelationAggregateInput
    userModules?: UserModuleOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseId_moduleId?: ModuleCourseIdModuleIdCompoundUniqueInput
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    moduleId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    scenarios?: ScenarioListRelationFilter
    userModules?: UserModuleListRelationFilter
  }, "id" | "courseId_moduleId">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    moduleId?: StringWithAggregatesFilter<"Module"> | string
    courseId?: StringWithAggregatesFilter<"Module"> | string
    title?: StringWithAggregatesFilter<"Module"> | string
    description?: StringWithAggregatesFilter<"Module"> | string
    order?: IntWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type ScenarioWhereInput = {
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    id?: StringFilter<"Scenario"> | string
    scenarioId?: StringFilter<"Scenario"> | string
    moduleId?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    questions?: QuestionListRelationFilter
    userResponses?: UserResponseListRelationFilter
  }

  export type ScenarioOrderByWithRelationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
    questions?: QuestionOrderByRelationAggregateInput
    userResponses?: UserResponseOrderByRelationAggregateInput
  }

  export type ScenarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduleId_scenarioId?: ScenarioModuleIdScenarioIdCompoundUniqueInput
    AND?: ScenarioWhereInput | ScenarioWhereInput[]
    OR?: ScenarioWhereInput[]
    NOT?: ScenarioWhereInput | ScenarioWhereInput[]
    scenarioId?: StringFilter<"Scenario"> | string
    moduleId?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    questions?: QuestionListRelationFilter
    userResponses?: UserResponseListRelationFilter
  }, "id" | "moduleId_scenarioId">

  export type ScenarioOrderByWithAggregationInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScenarioCountOrderByAggregateInput
    _max?: ScenarioMaxOrderByAggregateInput
    _min?: ScenarioMinOrderByAggregateInput
  }

  export type ScenarioScalarWhereWithAggregatesInput = {
    AND?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    OR?: ScenarioScalarWhereWithAggregatesInput[]
    NOT?: ScenarioScalarWhereWithAggregatesInput | ScenarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Scenario"> | string
    scenarioId?: StringWithAggregatesFilter<"Scenario"> | string
    moduleId?: StringWithAggregatesFilter<"Scenario"> | string
    title?: StringWithAggregatesFilter<"Scenario"> | string
    description?: StringWithAggregatesFilter<"Scenario"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Scenario"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    questionId?: StringFilter<"Question"> | string
    scenarioId?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
    options?: OptionListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    scenarioId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scenario?: ScenarioOrderByWithRelationInput
    options?: OptionOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    scenarioId_questionId?: QuestionScenarioIdQuestionIdCompoundUniqueInput
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    questionId?: StringFilter<"Question"> | string
    scenarioId?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
    options?: OptionListRelationFilter
  }, "id" | "scenarioId_questionId">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    scenarioId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    explanation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    questionId?: StringWithAggregatesFilter<"Question"> | string
    scenarioId?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    type?: StringWithAggregatesFilter<"Question"> | string
    explanation?: StringNullableWithAggregatesFilter<"Question"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type OptionWhereInput = {
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    id?: StringFilter<"Option"> | string
    optionId?: StringFilter<"Option"> | string
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type OptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionId_optionId?: OptionQuestionIdOptionIdCompoundUniqueInput
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    optionId?: StringFilter<"Option"> | string
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id" | "questionId_optionId">

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    OR?: OptionScalarWhereWithAggregatesInput[]
    NOT?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Option"> | string
    optionId?: StringWithAggregatesFilter<"Option"> | string
    questionId?: StringWithAggregatesFilter<"Option"> | string
    text?: StringWithAggregatesFilter<"Option"> | string
    isCorrect?: BoolWithAggregatesFilter<"Option"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
  }

  export type UserModuleWhereInput = {
    AND?: UserModuleWhereInput | UserModuleWhereInput[]
    OR?: UserModuleWhereInput[]
    NOT?: UserModuleWhereInput | UserModuleWhereInput[]
    id?: StringFilter<"UserModule"> | string
    userCourseId?: StringFilter<"UserModule"> | string
    moduleId?: StringFilter<"UserModule"> | string
    completed?: BoolFilter<"UserModule"> | boolean
    score?: IntFilter<"UserModule"> | number
    createdAt?: DateTimeFilter<"UserModule"> | Date | string
    updatedAt?: DateTimeFilter<"UserModule"> | Date | string
    userCourse?: XOR<UserCourseScalarRelationFilter, UserCourseWhereInput>
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }

  export type UserModuleOrderByWithRelationInput = {
    id?: SortOrder
    userCourseId?: SortOrder
    moduleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userCourse?: UserCourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type UserModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userCourseId_moduleId?: UserModuleUserCourseIdModuleIdCompoundUniqueInput
    AND?: UserModuleWhereInput | UserModuleWhereInput[]
    OR?: UserModuleWhereInput[]
    NOT?: UserModuleWhereInput | UserModuleWhereInput[]
    userCourseId?: StringFilter<"UserModule"> | string
    moduleId?: StringFilter<"UserModule"> | string
    completed?: BoolFilter<"UserModule"> | boolean
    score?: IntFilter<"UserModule"> | number
    createdAt?: DateTimeFilter<"UserModule"> | Date | string
    updatedAt?: DateTimeFilter<"UserModule"> | Date | string
    userCourse?: XOR<UserCourseScalarRelationFilter, UserCourseWhereInput>
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }, "id" | "userCourseId_moduleId">

  export type UserModuleOrderByWithAggregationInput = {
    id?: SortOrder
    userCourseId?: SortOrder
    moduleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserModuleCountOrderByAggregateInput
    _avg?: UserModuleAvgOrderByAggregateInput
    _max?: UserModuleMaxOrderByAggregateInput
    _min?: UserModuleMinOrderByAggregateInput
    _sum?: UserModuleSumOrderByAggregateInput
  }

  export type UserModuleScalarWhereWithAggregatesInput = {
    AND?: UserModuleScalarWhereWithAggregatesInput | UserModuleScalarWhereWithAggregatesInput[]
    OR?: UserModuleScalarWhereWithAggregatesInput[]
    NOT?: UserModuleScalarWhereWithAggregatesInput | UserModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserModule"> | string
    userCourseId?: StringWithAggregatesFilter<"UserModule"> | string
    moduleId?: StringWithAggregatesFilter<"UserModule"> | string
    completed?: BoolWithAggregatesFilter<"UserModule"> | boolean
    score?: IntWithAggregatesFilter<"UserModule"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserModule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserModule"> | Date | string
  }

  export type UserResponseWhereInput = {
    AND?: UserResponseWhereInput | UserResponseWhereInput[]
    OR?: UserResponseWhereInput[]
    NOT?: UserResponseWhereInput | UserResponseWhereInput[]
    id?: StringFilter<"UserResponse"> | string
    userId?: StringFilter<"UserResponse"> | string
    scenarioId?: StringFilter<"UserResponse"> | string
    questionId?: StringFilter<"UserResponse"> | string
    selectedAnswers?: StringNullableListFilter<"UserResponse">
    isCorrect?: BoolFilter<"UserResponse"> | boolean
    score?: IntFilter<"UserResponse"> | number
    createdAt?: DateTimeFilter<"UserResponse"> | Date | string
    updatedAt?: DateTimeFilter<"UserResponse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
  }

  export type UserResponseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    questionId?: SortOrder
    selectedAnswers?: SortOrder
    isCorrect?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    scenario?: ScenarioOrderByWithRelationInput
  }

  export type UserResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserResponseWhereInput | UserResponseWhereInput[]
    OR?: UserResponseWhereInput[]
    NOT?: UserResponseWhereInput | UserResponseWhereInput[]
    userId?: StringFilter<"UserResponse"> | string
    scenarioId?: StringFilter<"UserResponse"> | string
    questionId?: StringFilter<"UserResponse"> | string
    selectedAnswers?: StringNullableListFilter<"UserResponse">
    isCorrect?: BoolFilter<"UserResponse"> | boolean
    score?: IntFilter<"UserResponse"> | number
    createdAt?: DateTimeFilter<"UserResponse"> | Date | string
    updatedAt?: DateTimeFilter<"UserResponse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    scenario?: XOR<ScenarioScalarRelationFilter, ScenarioWhereInput>
  }, "id">

  export type UserResponseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    questionId?: SortOrder
    selectedAnswers?: SortOrder
    isCorrect?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserResponseCountOrderByAggregateInput
    _avg?: UserResponseAvgOrderByAggregateInput
    _max?: UserResponseMaxOrderByAggregateInput
    _min?: UserResponseMinOrderByAggregateInput
    _sum?: UserResponseSumOrderByAggregateInput
  }

  export type UserResponseScalarWhereWithAggregatesInput = {
    AND?: UserResponseScalarWhereWithAggregatesInput | UserResponseScalarWhereWithAggregatesInput[]
    OR?: UserResponseScalarWhereWithAggregatesInput[]
    NOT?: UserResponseScalarWhereWithAggregatesInput | UserResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserResponse"> | string
    userId?: StringWithAggregatesFilter<"UserResponse"> | string
    scenarioId?: StringWithAggregatesFilter<"UserResponse"> | string
    questionId?: StringWithAggregatesFilter<"UserResponse"> | string
    selectedAnswers?: StringNullableListFilter<"UserResponse">
    isCorrect?: BoolWithAggregatesFilter<"UserResponse"> | boolean
    score?: IntWithAggregatesFilter<"UserResponse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserResponse"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    achievementId?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    iconName?: StringFilter<"Achievement"> | string
    criteria?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    achievementId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    achievementId?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    iconName?: StringFilter<"Achievement"> | string
    criteria?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }, "id" | "achievementId">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    achievementId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    achievementId?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    iconName?: StringWithAggregatesFilter<"Achievement"> | string
    criteria?: StringWithAggregatesFilter<"Achievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    data?: StringNullableFilter<"UserAchievement"> | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    data?: StringNullableFilter<"UserAchievement"> | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    data?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: StringFilter<"UserStats"> | string
    userId?: StringFilter<"UserStats"> | string
    totalTimeSpent?: IntFilter<"UserStats"> | number
    sessionsCompleted?: IntFilter<"UserStats"> | number
    questionsAnswered?: IntFilter<"UserStats"> | number
    correctAnswers?: IntFilter<"UserStats"> | number
    lastActivity?: DateTimeFilter<"UserStats"> | Date | string
    createdAt?: DateTimeFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeFilter<"UserStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    totalTimeSpent?: IntFilter<"UserStats"> | number
    sessionsCompleted?: IntFilter<"UserStats"> | number
    questionsAnswered?: IntFilter<"UserStats"> | number
    correctAnswers?: IntFilter<"UserStats"> | number
    lastActivity?: DateTimeFilter<"UserStats"> | Date | string
    createdAt?: DateTimeFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeFilter<"UserStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _avg?: UserStatsAvgOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
    _sum?: UserStatsSumOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStats"> | string
    userId?: StringWithAggregatesFilter<"UserStats"> | string
    totalTimeSpent?: IntWithAggregatesFilter<"UserStats"> | number
    sessionsCompleted?: IntWithAggregatesFilter<"UserStats"> | number
    questionsAnswered?: IntWithAggregatesFilter<"UserStats"> | number
    correctAnswers?: IntWithAggregatesFilter<"UserStats"> | number
    lastActivity?: DateTimeWithAggregatesFilter<"UserStats"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserStats"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    startTime?: DateTimeFilter<"UserSession"> | Date | string
    endTime?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    duration?: IntNullableFilter<"UserSession"> | number | null
    courseId?: StringNullableFilter<"UserSession"> | string | null
    modulesViewed?: StringNullableFilter<"UserSession"> | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    modulesViewed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    startTime?: DateTimeFilter<"UserSession"> | Date | string
    endTime?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    duration?: IntNullableFilter<"UserSession"> | number | null
    courseId?: StringNullableFilter<"UserSession"> | string | null
    modulesViewed?: StringNullableFilter<"UserSession"> | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }, "id">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    modulesViewed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _avg?: UserSessionAvgOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
    _sum?: UserSessionSumOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    startTime?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"UserSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"UserSession"> | number | null
    courseId?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    modulesViewed?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    azureContainer?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    trainings?: OrganizationTrainingListRelationFilter
    invitations?: OrganizationInvitationListRelationFilter
    tags?: OrganizationTagListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    azureContainer?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: OrganizationMemberOrderByRelationAggregateInput
    trainings?: OrganizationTrainingOrderByRelationAggregateInput
    invitations?: OrganizationInvitationOrderByRelationAggregateInput
    tags?: OrganizationTagOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    azureContainer?: StringNullableFilter<"Organization"> | string | null
    isActive?: BoolFilter<"Organization"> | boolean
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    trainings?: OrganizationTrainingListRelationFilter
    invitations?: OrganizationInvitationListRelationFilter
    tags?: OrganizationTagListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    azureContainer?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    description?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    azureContainer?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    isActive?: BoolWithAggregatesFilter<"Organization"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_userId?: OrganizationMemberOrganizationIdUserIdCompoundUniqueInput
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "organizationId_userId">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMember"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    role?: StringWithAggregatesFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
  }

  export type OrganizationTrainingWhereInput = {
    AND?: OrganizationTrainingWhereInput | OrganizationTrainingWhereInput[]
    OR?: OrganizationTrainingWhereInput[]
    NOT?: OrganizationTrainingWhereInput | OrganizationTrainingWhereInput[]
    id?: StringFilter<"OrganizationTraining"> | string
    organizationId?: StringFilter<"OrganizationTraining"> | string
    courseId?: StringFilter<"OrganizationTraining"> | string
    buildId?: StringNullableFilter<"OrganizationTraining"> | string | null
    isCustomBuild?: BoolFilter<"OrganizationTraining"> | boolean
    isActive?: BoolFilter<"OrganizationTraining"> | boolean
    assignedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type OrganizationTrainingOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    courseId?: SortOrder
    buildId?: SortOrderInput | SortOrder
    isCustomBuild?: SortOrder
    isActive?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type OrganizationTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_courseId?: OrganizationTrainingOrganizationIdCourseIdCompoundUniqueInput
    AND?: OrganizationTrainingWhereInput | OrganizationTrainingWhereInput[]
    OR?: OrganizationTrainingWhereInput[]
    NOT?: OrganizationTrainingWhereInput | OrganizationTrainingWhereInput[]
    organizationId?: StringFilter<"OrganizationTraining"> | string
    courseId?: StringFilter<"OrganizationTraining"> | string
    buildId?: StringNullableFilter<"OrganizationTraining"> | string | null
    isCustomBuild?: BoolFilter<"OrganizationTraining"> | boolean
    isActive?: BoolFilter<"OrganizationTraining"> | boolean
    assignedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "organizationId_courseId">

  export type OrganizationTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    courseId?: SortOrder
    buildId?: SortOrderInput | SortOrder
    isCustomBuild?: SortOrder
    isActive?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationTrainingCountOrderByAggregateInput
    _max?: OrganizationTrainingMaxOrderByAggregateInput
    _min?: OrganizationTrainingMinOrderByAggregateInput
  }

  export type OrganizationTrainingScalarWhereWithAggregatesInput = {
    AND?: OrganizationTrainingScalarWhereWithAggregatesInput | OrganizationTrainingScalarWhereWithAggregatesInput[]
    OR?: OrganizationTrainingScalarWhereWithAggregatesInput[]
    NOT?: OrganizationTrainingScalarWhereWithAggregatesInput | OrganizationTrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationTraining"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationTraining"> | string
    courseId?: StringWithAggregatesFilter<"OrganizationTraining"> | string
    buildId?: StringNullableWithAggregatesFilter<"OrganizationTraining"> | string | null
    isCustomBuild?: BoolWithAggregatesFilter<"OrganizationTraining"> | boolean
    isActive?: BoolWithAggregatesFilter<"OrganizationTraining"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"OrganizationTraining"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationTraining"> | Date | string
  }

  export type OrganizationInvitationWhereInput = {
    AND?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    OR?: OrganizationInvitationWhereInput[]
    NOT?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    id?: StringFilter<"OrganizationInvitation"> | string
    email?: StringFilter<"OrganizationInvitation"> | string
    organizationId?: StringFilter<"OrganizationInvitation"> | string
    inviteCode?: StringFilter<"OrganizationInvitation"> | string
    role?: StringFilter<"OrganizationInvitation"> | string
    status?: StringFilter<"OrganizationInvitation"> | string
    invitedBy?: StringFilter<"OrganizationInvitation"> | string
    invitedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type OrganizationInvitationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    organizationId?: SortOrder
    inviteCode?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    expiresAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type OrganizationInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteCode?: string
    email_organizationId?: OrganizationInvitationEmailOrganizationIdCompoundUniqueInput
    AND?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    OR?: OrganizationInvitationWhereInput[]
    NOT?: OrganizationInvitationWhereInput | OrganizationInvitationWhereInput[]
    email?: StringFilter<"OrganizationInvitation"> | string
    organizationId?: StringFilter<"OrganizationInvitation"> | string
    role?: StringFilter<"OrganizationInvitation"> | string
    status?: StringFilter<"OrganizationInvitation"> | string
    invitedBy?: StringFilter<"OrganizationInvitation"> | string
    invitedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "inviteCode" | "email_organizationId">

  export type OrganizationInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    organizationId?: SortOrder
    inviteCode?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    expiresAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationInvitationCountOrderByAggregateInput
    _max?: OrganizationInvitationMaxOrderByAggregateInput
    _min?: OrganizationInvitationMinOrderByAggregateInput
  }

  export type OrganizationInvitationScalarWhereWithAggregatesInput = {
    AND?: OrganizationInvitationScalarWhereWithAggregatesInput | OrganizationInvitationScalarWhereWithAggregatesInput[]
    OR?: OrganizationInvitationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationInvitationScalarWhereWithAggregatesInput | OrganizationInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    email?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    inviteCode?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    role?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    status?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"OrganizationInvitation"> | string
    invitedAt?: DateTimeWithAggregatesFilter<"OrganizationInvitation"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OrganizationInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationInvitation"> | Date | string
  }

  export type OrganizationTagWhereInput = {
    AND?: OrganizationTagWhereInput | OrganizationTagWhereInput[]
    OR?: OrganizationTagWhereInput[]
    NOT?: OrganizationTagWhereInput | OrganizationTagWhereInput[]
    id?: StringFilter<"OrganizationTag"> | string
    organizationId?: StringFilter<"OrganizationTag"> | string
    name?: StringFilter<"OrganizationTag"> | string
    color?: StringNullableFilter<"OrganizationTag"> | string | null
    description?: StringNullableFilter<"OrganizationTag"> | string | null
    createdAt?: DateTimeFilter<"OrganizationTag"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTag"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    users?: UserTagListRelationFilter
    trainings?: TagTrainingListRelationFilter
  }

  export type OrganizationTagOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    users?: UserTagOrderByRelationAggregateInput
    trainings?: TagTrainingOrderByRelationAggregateInput
  }

  export type OrganizationTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_name?: OrganizationTagOrganizationIdNameCompoundUniqueInput
    AND?: OrganizationTagWhereInput | OrganizationTagWhereInput[]
    OR?: OrganizationTagWhereInput[]
    NOT?: OrganizationTagWhereInput | OrganizationTagWhereInput[]
    organizationId?: StringFilter<"OrganizationTag"> | string
    name?: StringFilter<"OrganizationTag"> | string
    color?: StringNullableFilter<"OrganizationTag"> | string | null
    description?: StringNullableFilter<"OrganizationTag"> | string | null
    createdAt?: DateTimeFilter<"OrganizationTag"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTag"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    users?: UserTagListRelationFilter
    trainings?: TagTrainingListRelationFilter
  }, "id" | "organizationId_name">

  export type OrganizationTagOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationTagCountOrderByAggregateInput
    _max?: OrganizationTagMaxOrderByAggregateInput
    _min?: OrganizationTagMinOrderByAggregateInput
  }

  export type OrganizationTagScalarWhereWithAggregatesInput = {
    AND?: OrganizationTagScalarWhereWithAggregatesInput | OrganizationTagScalarWhereWithAggregatesInput[]
    OR?: OrganizationTagScalarWhereWithAggregatesInput[]
    NOT?: OrganizationTagScalarWhereWithAggregatesInput | OrganizationTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationTag"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationTag"> | string
    name?: StringWithAggregatesFilter<"OrganizationTag"> | string
    color?: StringNullableWithAggregatesFilter<"OrganizationTag"> | string | null
    description?: StringNullableWithAggregatesFilter<"OrganizationTag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrganizationTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrganizationTag"> | Date | string
  }

  export type UserTagWhereInput = {
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    id?: StringFilter<"UserTag"> | string
    userId?: StringFilter<"UserTag"> | string
    tagId?: StringFilter<"UserTag"> | string
    assignedAt?: DateTimeFilter<"UserTag"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tag?: XOR<OrganizationTagScalarRelationFilter, OrganizationTagWhereInput>
  }

  export type UserTagOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tag?: OrganizationTagOrderByWithRelationInput
  }

  export type UserTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tagId?: UserTagUserIdTagIdCompoundUniqueInput
    AND?: UserTagWhereInput | UserTagWhereInput[]
    OR?: UserTagWhereInput[]
    NOT?: UserTagWhereInput | UserTagWhereInput[]
    userId?: StringFilter<"UserTag"> | string
    tagId?: StringFilter<"UserTag"> | string
    assignedAt?: DateTimeFilter<"UserTag"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tag?: XOR<OrganizationTagScalarRelationFilter, OrganizationTagWhereInput>
  }, "id" | "userId_tagId">

  export type UserTagOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserTagCountOrderByAggregateInput
    _max?: UserTagMaxOrderByAggregateInput
    _min?: UserTagMinOrderByAggregateInput
  }

  export type UserTagScalarWhereWithAggregatesInput = {
    AND?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    OR?: UserTagScalarWhereWithAggregatesInput[]
    NOT?: UserTagScalarWhereWithAggregatesInput | UserTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTag"> | string
    userId?: StringWithAggregatesFilter<"UserTag"> | string
    tagId?: StringWithAggregatesFilter<"UserTag"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"UserTag"> | Date | string
  }

  export type TagTrainingWhereInput = {
    AND?: TagTrainingWhereInput | TagTrainingWhereInput[]
    OR?: TagTrainingWhereInput[]
    NOT?: TagTrainingWhereInput | TagTrainingWhereInput[]
    id?: StringFilter<"TagTraining"> | string
    tagId?: StringFilter<"TagTraining"> | string
    courseId?: StringFilter<"TagTraining"> | string
    assignedAt?: DateTimeFilter<"TagTraining"> | Date | string
    tag?: XOR<OrganizationTagScalarRelationFilter, OrganizationTagWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type TagTrainingOrderByWithRelationInput = {
    id?: SortOrder
    tagId?: SortOrder
    courseId?: SortOrder
    assignedAt?: SortOrder
    tag?: OrganizationTagOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type TagTrainingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagId_courseId?: TagTrainingTagIdCourseIdCompoundUniqueInput
    AND?: TagTrainingWhereInput | TagTrainingWhereInput[]
    OR?: TagTrainingWhereInput[]
    NOT?: TagTrainingWhereInput | TagTrainingWhereInput[]
    tagId?: StringFilter<"TagTraining"> | string
    courseId?: StringFilter<"TagTraining"> | string
    assignedAt?: DateTimeFilter<"TagTraining"> | Date | string
    tag?: XOR<OrganizationTagScalarRelationFilter, OrganizationTagWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "tagId_courseId">

  export type TagTrainingOrderByWithAggregationInput = {
    id?: SortOrder
    tagId?: SortOrder
    courseId?: SortOrder
    assignedAt?: SortOrder
    _count?: TagTrainingCountOrderByAggregateInput
    _max?: TagTrainingMaxOrderByAggregateInput
    _min?: TagTrainingMinOrderByAggregateInput
  }

  export type TagTrainingScalarWhereWithAggregatesInput = {
    AND?: TagTrainingScalarWhereWithAggregatesInput | TagTrainingScalarWhereWithAggregatesInput[]
    OR?: TagTrainingScalarWhereWithAggregatesInput[]
    NOT?: TagTrainingScalarWhereWithAggregatesInput | TagTrainingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TagTraining"> | string
    tagId?: StringWithAggregatesFilter<"TagTraining"> | string
    courseId?: StringWithAggregatesFilter<"TagTraining"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TagTraining"> | Date | string
  }

  export type FormationContentWhereInput = {
    AND?: FormationContentWhereInput | FormationContentWhereInput[]
    OR?: FormationContentWhereInput[]
    NOT?: FormationContentWhereInput | FormationContentWhereInput[]
    id?: StringFilter<"FormationContent"> | string
    contentId?: StringFilter<"FormationContent"> | string
    formationId?: StringFilter<"FormationContent"> | string
    title?: StringFilter<"FormationContent"> | string
    description?: StringFilter<"FormationContent"> | string
    type?: StringFilter<"FormationContent"> | string
    order?: IntFilter<"FormationContent"> | number
    educationalTitle?: StringNullableFilter<"FormationContent"> | string | null
    educationalText?: StringNullableFilter<"FormationContent"> | string | null
    imageUrl?: StringNullableFilter<"FormationContent"> | string | null
    createdAt?: DateTimeFilter<"FormationContent"> | Date | string
    updatedAt?: DateTimeFilter<"FormationContent"> | Date | string
    formation?: XOR<FormationScalarRelationFilter, FormationWhereInput>
    steps?: FormationStepListRelationFilter
    questions?: FormationQuestionListRelationFilter
  }

  export type FormationContentOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    formationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    educationalTitle?: SortOrderInput | SortOrder
    educationalText?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    formation?: FormationOrderByWithRelationInput
    steps?: FormationStepOrderByRelationAggregateInput
    questions?: FormationQuestionOrderByRelationAggregateInput
  }

  export type FormationContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormationContentWhereInput | FormationContentWhereInput[]
    OR?: FormationContentWhereInput[]
    NOT?: FormationContentWhereInput | FormationContentWhereInput[]
    contentId?: StringFilter<"FormationContent"> | string
    formationId?: StringFilter<"FormationContent"> | string
    title?: StringFilter<"FormationContent"> | string
    description?: StringFilter<"FormationContent"> | string
    type?: StringFilter<"FormationContent"> | string
    order?: IntFilter<"FormationContent"> | number
    educationalTitle?: StringNullableFilter<"FormationContent"> | string | null
    educationalText?: StringNullableFilter<"FormationContent"> | string | null
    imageUrl?: StringNullableFilter<"FormationContent"> | string | null
    createdAt?: DateTimeFilter<"FormationContent"> | Date | string
    updatedAt?: DateTimeFilter<"FormationContent"> | Date | string
    formation?: XOR<FormationScalarRelationFilter, FormationWhereInput>
    steps?: FormationStepListRelationFilter
    questions?: FormationQuestionListRelationFilter
  }, "id">

  export type FormationContentOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    formationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    educationalTitle?: SortOrderInput | SortOrder
    educationalText?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormationContentCountOrderByAggregateInput
    _avg?: FormationContentAvgOrderByAggregateInput
    _max?: FormationContentMaxOrderByAggregateInput
    _min?: FormationContentMinOrderByAggregateInput
    _sum?: FormationContentSumOrderByAggregateInput
  }

  export type FormationContentScalarWhereWithAggregatesInput = {
    AND?: FormationContentScalarWhereWithAggregatesInput | FormationContentScalarWhereWithAggregatesInput[]
    OR?: FormationContentScalarWhereWithAggregatesInput[]
    NOT?: FormationContentScalarWhereWithAggregatesInput | FormationContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormationContent"> | string
    contentId?: StringWithAggregatesFilter<"FormationContent"> | string
    formationId?: StringWithAggregatesFilter<"FormationContent"> | string
    title?: StringWithAggregatesFilter<"FormationContent"> | string
    description?: StringWithAggregatesFilter<"FormationContent"> | string
    type?: StringWithAggregatesFilter<"FormationContent"> | string
    order?: IntWithAggregatesFilter<"FormationContent"> | number
    educationalTitle?: StringNullableWithAggregatesFilter<"FormationContent"> | string | null
    educationalText?: StringNullableWithAggregatesFilter<"FormationContent"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"FormationContent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FormationContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormationContent"> | Date | string
  }

  export type FormationStepWhereInput = {
    AND?: FormationStepWhereInput | FormationStepWhereInput[]
    OR?: FormationStepWhereInput[]
    NOT?: FormationStepWhereInput | FormationStepWhereInput[]
    id?: StringFilter<"FormationStep"> | string
    stepId?: StringFilter<"FormationStep"> | string
    contentId?: StringFilter<"FormationStep"> | string
    title?: StringFilter<"FormationStep"> | string
    instruction?: StringFilter<"FormationStep"> | string
    validationEvent?: StringFilter<"FormationStep"> | string
    validationType?: StringFilter<"FormationStep"> | string
    hint?: StringNullableFilter<"FormationStep"> | string | null
    createdAt?: DateTimeFilter<"FormationStep"> | Date | string
    updatedAt?: DateTimeFilter<"FormationStep"> | Date | string
    content?: XOR<FormationContentScalarRelationFilter, FormationContentWhereInput>
  }

  export type FormationStepOrderByWithRelationInput = {
    id?: SortOrder
    stepId?: SortOrder
    contentId?: SortOrder
    title?: SortOrder
    instruction?: SortOrder
    validationEvent?: SortOrder
    validationType?: SortOrder
    hint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: FormationContentOrderByWithRelationInput
  }

  export type FormationStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormationStepWhereInput | FormationStepWhereInput[]
    OR?: FormationStepWhereInput[]
    NOT?: FormationStepWhereInput | FormationStepWhereInput[]
    stepId?: StringFilter<"FormationStep"> | string
    contentId?: StringFilter<"FormationStep"> | string
    title?: StringFilter<"FormationStep"> | string
    instruction?: StringFilter<"FormationStep"> | string
    validationEvent?: StringFilter<"FormationStep"> | string
    validationType?: StringFilter<"FormationStep"> | string
    hint?: StringNullableFilter<"FormationStep"> | string | null
    createdAt?: DateTimeFilter<"FormationStep"> | Date | string
    updatedAt?: DateTimeFilter<"FormationStep"> | Date | string
    content?: XOR<FormationContentScalarRelationFilter, FormationContentWhereInput>
  }, "id">

  export type FormationStepOrderByWithAggregationInput = {
    id?: SortOrder
    stepId?: SortOrder
    contentId?: SortOrder
    title?: SortOrder
    instruction?: SortOrder
    validationEvent?: SortOrder
    validationType?: SortOrder
    hint?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormationStepCountOrderByAggregateInput
    _max?: FormationStepMaxOrderByAggregateInput
    _min?: FormationStepMinOrderByAggregateInput
  }

  export type FormationStepScalarWhereWithAggregatesInput = {
    AND?: FormationStepScalarWhereWithAggregatesInput | FormationStepScalarWhereWithAggregatesInput[]
    OR?: FormationStepScalarWhereWithAggregatesInput[]
    NOT?: FormationStepScalarWhereWithAggregatesInput | FormationStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormationStep"> | string
    stepId?: StringWithAggregatesFilter<"FormationStep"> | string
    contentId?: StringWithAggregatesFilter<"FormationStep"> | string
    title?: StringWithAggregatesFilter<"FormationStep"> | string
    instruction?: StringWithAggregatesFilter<"FormationStep"> | string
    validationEvent?: StringWithAggregatesFilter<"FormationStep"> | string
    validationType?: StringWithAggregatesFilter<"FormationStep"> | string
    hint?: StringNullableWithAggregatesFilter<"FormationStep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FormationStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormationStep"> | Date | string
  }

  export type FormationQuestionWhereInput = {
    AND?: FormationQuestionWhereInput | FormationQuestionWhereInput[]
    OR?: FormationQuestionWhereInput[]
    NOT?: FormationQuestionWhereInput | FormationQuestionWhereInput[]
    id?: StringFilter<"FormationQuestion"> | string
    questionId?: StringFilter<"FormationQuestion"> | string
    contentId?: StringFilter<"FormationQuestion"> | string
    text?: StringFilter<"FormationQuestion"> | string
    type?: StringFilter<"FormationQuestion"> | string
    image?: StringNullableFilter<"FormationQuestion"> | string | null
    createdAt?: DateTimeFilter<"FormationQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"FormationQuestion"> | Date | string
    content?: XOR<FormationContentScalarRelationFilter, FormationContentWhereInput>
    options?: FormationOptionListRelationFilter
  }

  export type FormationQuestionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    contentId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: FormationContentOrderByWithRelationInput
    options?: FormationOptionOrderByRelationAggregateInput
  }

  export type FormationQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormationQuestionWhereInput | FormationQuestionWhereInput[]
    OR?: FormationQuestionWhereInput[]
    NOT?: FormationQuestionWhereInput | FormationQuestionWhereInput[]
    questionId?: StringFilter<"FormationQuestion"> | string
    contentId?: StringFilter<"FormationQuestion"> | string
    text?: StringFilter<"FormationQuestion"> | string
    type?: StringFilter<"FormationQuestion"> | string
    image?: StringNullableFilter<"FormationQuestion"> | string | null
    createdAt?: DateTimeFilter<"FormationQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"FormationQuestion"> | Date | string
    content?: XOR<FormationContentScalarRelationFilter, FormationContentWhereInput>
    options?: FormationOptionListRelationFilter
  }, "id">

  export type FormationQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    contentId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormationQuestionCountOrderByAggregateInput
    _max?: FormationQuestionMaxOrderByAggregateInput
    _min?: FormationQuestionMinOrderByAggregateInput
  }

  export type FormationQuestionScalarWhereWithAggregatesInput = {
    AND?: FormationQuestionScalarWhereWithAggregatesInput | FormationQuestionScalarWhereWithAggregatesInput[]
    OR?: FormationQuestionScalarWhereWithAggregatesInput[]
    NOT?: FormationQuestionScalarWhereWithAggregatesInput | FormationQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormationQuestion"> | string
    questionId?: StringWithAggregatesFilter<"FormationQuestion"> | string
    contentId?: StringWithAggregatesFilter<"FormationQuestion"> | string
    text?: StringWithAggregatesFilter<"FormationQuestion"> | string
    type?: StringWithAggregatesFilter<"FormationQuestion"> | string
    image?: StringNullableWithAggregatesFilter<"FormationQuestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FormationQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormationQuestion"> | Date | string
  }

  export type FormationOptionWhereInput = {
    AND?: FormationOptionWhereInput | FormationOptionWhereInput[]
    OR?: FormationOptionWhereInput[]
    NOT?: FormationOptionWhereInput | FormationOptionWhereInput[]
    id?: StringFilter<"FormationOption"> | string
    optionId?: StringFilter<"FormationOption"> | string
    questionId?: StringFilter<"FormationOption"> | string
    text?: StringFilter<"FormationOption"> | string
    isCorrect?: BoolFilter<"FormationOption"> | boolean
    createdAt?: DateTimeFilter<"FormationOption"> | Date | string
    updatedAt?: DateTimeFilter<"FormationOption"> | Date | string
    question?: XOR<FormationQuestionScalarRelationFilter, FormationQuestionWhereInput>
  }

  export type FormationOptionOrderByWithRelationInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: FormationQuestionOrderByWithRelationInput
  }

  export type FormationOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormationOptionWhereInput | FormationOptionWhereInput[]
    OR?: FormationOptionWhereInput[]
    NOT?: FormationOptionWhereInput | FormationOptionWhereInput[]
    optionId?: StringFilter<"FormationOption"> | string
    questionId?: StringFilter<"FormationOption"> | string
    text?: StringFilter<"FormationOption"> | string
    isCorrect?: BoolFilter<"FormationOption"> | boolean
    createdAt?: DateTimeFilter<"FormationOption"> | Date | string
    updatedAt?: DateTimeFilter<"FormationOption"> | Date | string
    question?: XOR<FormationQuestionScalarRelationFilter, FormationQuestionWhereInput>
  }, "id">

  export type FormationOptionOrderByWithAggregationInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormationOptionCountOrderByAggregateInput
    _max?: FormationOptionMaxOrderByAggregateInput
    _min?: FormationOptionMinOrderByAggregateInput
  }

  export type FormationOptionScalarWhereWithAggregatesInput = {
    AND?: FormationOptionScalarWhereWithAggregatesInput | FormationOptionScalarWhereWithAggregatesInput[]
    OR?: FormationOptionScalarWhereWithAggregatesInput[]
    NOT?: FormationOptionScalarWhereWithAggregatesInput | FormationOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormationOption"> | string
    optionId?: StringWithAggregatesFilter<"FormationOption"> | string
    questionId?: StringWithAggregatesFilter<"FormationOption"> | string
    text?: StringWithAggregatesFilter<"FormationOption"> | string
    isCorrect?: BoolWithAggregatesFilter<"FormationOption"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FormationOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormationOption"> | Date | string
  }

  export type FormationWhereInput = {
    AND?: FormationWhereInput | FormationWhereInput[]
    OR?: FormationWhereInput[]
    NOT?: FormationWhereInput | FormationWhereInput[]
    id?: StringFilter<"Formation"> | string
    formationId?: StringFilter<"Formation"> | string
    name?: StringFilter<"Formation"> | string
    description?: StringFilter<"Formation"> | string
    imageUrl?: StringNullableFilter<"Formation"> | string | null
    category?: StringFilter<"Formation"> | string
    difficulty?: StringFilter<"Formation"> | string
    duration?: StringFilter<"Formation"> | string
    objectMapping?: JsonNullableFilter<"Formation">
    buildId?: StringNullableFilter<"Formation"> | string | null
    createdAt?: DateTimeFilter<"Formation"> | Date | string
    updatedAt?: DateTimeFilter<"Formation"> | Date | string
    contents?: FormationContentListRelationFilter
  }

  export type FormationOrderByWithRelationInput = {
    id?: SortOrder
    formationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    objectMapping?: SortOrderInput | SortOrder
    buildId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contents?: FormationContentOrderByRelationAggregateInput
  }

  export type FormationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    formationId?: string
    AND?: FormationWhereInput | FormationWhereInput[]
    OR?: FormationWhereInput[]
    NOT?: FormationWhereInput | FormationWhereInput[]
    name?: StringFilter<"Formation"> | string
    description?: StringFilter<"Formation"> | string
    imageUrl?: StringNullableFilter<"Formation"> | string | null
    category?: StringFilter<"Formation"> | string
    difficulty?: StringFilter<"Formation"> | string
    duration?: StringFilter<"Formation"> | string
    objectMapping?: JsonNullableFilter<"Formation">
    buildId?: StringNullableFilter<"Formation"> | string | null
    createdAt?: DateTimeFilter<"Formation"> | Date | string
    updatedAt?: DateTimeFilter<"Formation"> | Date | string
    contents?: FormationContentListRelationFilter
  }, "id" | "formationId">

  export type FormationOrderByWithAggregationInput = {
    id?: SortOrder
    formationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    objectMapping?: SortOrderInput | SortOrder
    buildId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FormationCountOrderByAggregateInput
    _max?: FormationMaxOrderByAggregateInput
    _min?: FormationMinOrderByAggregateInput
  }

  export type FormationScalarWhereWithAggregatesInput = {
    AND?: FormationScalarWhereWithAggregatesInput | FormationScalarWhereWithAggregatesInput[]
    OR?: FormationScalarWhereWithAggregatesInput[]
    NOT?: FormationScalarWhereWithAggregatesInput | FormationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Formation"> | string
    formationId?: StringWithAggregatesFilter<"Formation"> | string
    name?: StringWithAggregatesFilter<"Formation"> | string
    description?: StringWithAggregatesFilter<"Formation"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"Formation"> | string | null
    category?: StringWithAggregatesFilter<"Formation"> | string
    difficulty?: StringWithAggregatesFilter<"Formation"> | string
    duration?: StringWithAggregatesFilter<"Formation"> | string
    objectMapping?: JsonNullableWithAggregatesFilter<"Formation">
    buildId?: StringNullableWithAggregatesFilter<"Formation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Formation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Formation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUncheckedUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCreateInput = {
    id?: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCoursesInput
    course: CourseCreateNestedOneWithoutUserCoursesInput
    userModules?: UserModuleCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userModules?: UserModuleUncheckedCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutUserCoursesNestedInput
    userModules?: UserModuleUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userModules?: UserModuleUncheckedUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    scenarios?: ScenarioCreateNestedManyWithoutModuleInput
    userModules?: UserModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    moduleId: string
    courseId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutModuleInput
    userModules?: UserModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    scenarios?: ScenarioUpdateManyWithoutModuleNestedInput
    userModules?: UserModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: ScenarioUncheckedUpdateManyWithoutModuleNestedInput
    userModules?: UserModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    moduleId: string
    courseId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutScenariosInput
    questions?: QuestionCreateNestedManyWithoutScenarioInput
    userResponses?: UserResponseCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateInput = {
    id?: string
    scenarioId: string
    moduleId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutScenarioInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutScenariosNestedInput
    questions?: QuestionUpdateManyWithoutScenarioNestedInput
    userResponses?: UserResponseUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutScenarioNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioCreateManyInput = {
    id?: string
    scenarioId: string
    moduleId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scenario: ScenarioCreateNestedOneWithoutQuestionsInput
    options?: OptionCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    questionId: string
    scenarioId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenario?: ScenarioUpdateOneRequiredWithoutQuestionsNestedInput
    options?: OptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    questionId: string
    scenarioId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateInput = {
    id?: string
    optionId: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateManyInput = {
    id?: string
    optionId: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleCreateInput = {
    id?: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourse: UserCourseCreateNestedOneWithoutUserModulesInput
    module: ModuleCreateNestedOneWithoutUserModulesInput
  }

  export type UserModuleUncheckedCreateInput = {
    id?: string
    userCourseId: string
    moduleId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourse?: UserCourseUpdateOneRequiredWithoutUserModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutUserModulesNestedInput
  }

  export type UserModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userCourseId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleCreateManyInput = {
    id?: string
    userCourseId: string
    moduleId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userCourseId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseCreateInput = {
    id?: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserResponsesInput
    scenario: ScenarioCreateNestedOneWithoutUserResponsesInput
  }

  export type UserResponseUncheckedCreateInput = {
    id?: string
    userId: string
    scenarioId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserResponsesNestedInput
    scenario?: ScenarioUpdateOneRequiredWithoutUserResponsesNestedInput
  }

  export type UserResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseCreateManyInput = {
    id?: string
    userId: string
    scenarioId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsCreateInput = {
    id?: string
    totalTimeSpent?: number
    sessionsCompleted?: number
    questionsAnswered?: number
    correctAnswers?: number
    lastActivity?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserStatsInput
  }

  export type UserStatsUncheckedCreateInput = {
    id?: string
    userId: string
    totalTimeSpent?: number
    sessionsCompleted?: number
    questionsAnswered?: number
    correctAnswers?: number
    lastActivity?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserStatsNestedInput
  }

  export type UserStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsCreateManyInput = {
    id?: string
    userId: string
    totalTimeSpent?: number
    sessionsCompleted?: number
    questionsAnswered?: number
    correctAnswers?: number
    lastActivity?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSessionInput
    course?: CourseCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    courseId?: string | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSessionNestedInput
    course?: CourseUpdateOneWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    courseId?: string | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingCreateInput = {
    id?: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTrainingsInput
    course: CourseCreateNestedOneWithoutOrganizationTrainingInput
  }

  export type OrganizationTrainingUncheckedCreateInput = {
    id?: string
    organizationId: string
    courseId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTrainingsNestedInput
    course?: CourseUpdateOneRequiredWithoutOrganizationTrainingNestedInput
  }

  export type OrganizationTrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingCreateManyInput = {
    id?: string
    organizationId: string
    courseId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationCreateInput = {
    id?: string
    email: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInvitationsInput
  }

  export type OrganizationInvitationUncheckedCreateInput = {
    id?: string
    email: string
    organizationId: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type OrganizationInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationCreateManyInput = {
    id?: string
    email: string
    organizationId: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTagCreateInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTagsInput
    users?: UserTagCreateNestedManyWithoutTagInput
    trainings?: TagTrainingCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserTagUncheckedCreateNestedManyWithoutTagInput
    trainings?: TagTrainingUncheckedCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTagsNestedInput
    users?: UserTagUpdateManyWithoutTagNestedInput
    trainings?: TagTrainingUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserTagUncheckedUpdateManyWithoutTagNestedInput
    trainings?: TagTrainingUncheckedUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagCreateInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
    tag: OrganizationTagCreateNestedOneWithoutUsersInput
  }

  export type UserTagUncheckedCreateInput = {
    id?: string
    userId: string
    tagId: string
    assignedAt?: Date | string
  }

  export type UserTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
    tag?: OrganizationTagUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagCreateManyInput = {
    id?: string
    userId: string
    tagId: string
    assignedAt?: Date | string
  }

  export type UserTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingCreateInput = {
    id?: string
    assignedAt?: Date | string
    tag: OrganizationTagCreateNestedOneWithoutTrainingsInput
    course: CourseCreateNestedOneWithoutTagTrainingInput
  }

  export type TagTrainingUncheckedCreateInput = {
    id?: string
    tagId: string
    courseId: string
    assignedAt?: Date | string
  }

  export type TagTrainingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: OrganizationTagUpdateOneRequiredWithoutTrainingsNestedInput
    course?: CourseUpdateOneRequiredWithoutTagTrainingNestedInput
  }

  export type TagTrainingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingCreateManyInput = {
    id?: string
    tagId: string
    courseId: string
    assignedAt?: Date | string
  }

  export type TagTrainingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationContentCreateInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formation: FormationCreateNestedOneWithoutContentsInput
    steps?: FormationStepCreateNestedManyWithoutContentInput
    questions?: FormationQuestionCreateNestedManyWithoutContentInput
  }

  export type FormationContentUncheckedCreateInput = {
    id?: string
    contentId: string
    formationId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: FormationStepUncheckedCreateNestedManyWithoutContentInput
    questions?: FormationQuestionUncheckedCreateNestedManyWithoutContentInput
  }

  export type FormationContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formation?: FormationUpdateOneRequiredWithoutContentsNestedInput
    steps?: FormationStepUpdateManyWithoutContentNestedInput
    questions?: FormationQuestionUpdateManyWithoutContentNestedInput
  }

  export type FormationContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: FormationStepUncheckedUpdateManyWithoutContentNestedInput
    questions?: FormationQuestionUncheckedUpdateManyWithoutContentNestedInput
  }

  export type FormationContentCreateManyInput = {
    id?: string
    contentId: string
    formationId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepCreateInput = {
    id?: string
    stepId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: FormationContentCreateNestedOneWithoutStepsInput
  }

  export type FormationStepUncheckedCreateInput = {
    id?: string
    stepId: string
    contentId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: FormationContentUpdateOneRequiredWithoutStepsNestedInput
  }

  export type FormationStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepCreateManyInput = {
    id?: string
    stepId: string
    contentId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationQuestionCreateInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: FormationContentCreateNestedOneWithoutQuestionsInput
    options?: FormationOptionCreateNestedManyWithoutQuestionInput
  }

  export type FormationQuestionUncheckedCreateInput = {
    id?: string
    questionId: string
    contentId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: FormationOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type FormationQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: FormationContentUpdateOneRequiredWithoutQuestionsNestedInput
    options?: FormationOptionUpdateManyWithoutQuestionNestedInput
  }

  export type FormationQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: FormationOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type FormationQuestionCreateManyInput = {
    id?: string
    questionId: string
    contentId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionCreateInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: FormationQuestionCreateNestedOneWithoutOptionsInput
  }

  export type FormationOptionUncheckedCreateInput = {
    id?: string
    optionId: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: FormationQuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type FormationOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionCreateManyInput = {
    id?: string
    optionId: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationCreateInput = {
    id?: string
    formationId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contents?: FormationContentCreateNestedManyWithoutFormationInput
  }

  export type FormationUncheckedCreateInput = {
    id?: string
    formationId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contents?: FormationContentUncheckedCreateNestedManyWithoutFormationInput
  }

  export type FormationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contents?: FormationContentUpdateManyWithoutFormationNestedInput
  }

  export type FormationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contents?: FormationContentUncheckedUpdateManyWithoutFormationNestedInput
  }

  export type FormationCreateManyInput = {
    id?: string
    formationId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCourseListRelationFilter = {
    every?: UserCourseWhereInput
    some?: UserCourseWhereInput
    none?: UserCourseWhereInput
  }

  export type UserResponseListRelationFilter = {
    every?: UserResponseWhereInput
    some?: UserResponseWhereInput
    none?: UserResponseWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type UserStatsNullableScalarRelationFilter = {
    is?: UserStatsWhereInput | null
    isNot?: UserStatsWhereInput | null
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type UserTagListRelationFilter = {
    every?: UserTagWhereInput
    some?: UserTagWhereInput
    none?: UserTagWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    azureContainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    azureContainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    azureContainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type OrganizationTrainingListRelationFilter = {
    every?: OrganizationTrainingWhereInput
    some?: OrganizationTrainingWhereInput
    none?: OrganizationTrainingWhereInput
  }

  export type TagTrainingListRelationFilter = {
    every?: TagTrainingWhereInput
    some?: TagTrainingWhereInput
    none?: TagTrainingWhereInput
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationTrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagTrainingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCourseIdSourceTypeSourceOrganizationIdCompoundUniqueInput = {
    courseId: string
    sourceType: string
    sourceOrganizationId: string
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    sourceType?: SortOrder
    sourceOrganizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    sourceType?: SortOrder
    sourceOrganizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    sourceType?: SortOrder
    sourceOrganizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type UserModuleListRelationFilter = {
    every?: UserModuleWhereInput
    some?: UserModuleWhereInput
    none?: UserModuleWhereInput
  }

  export type UserModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCourseUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type UserCourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    lastAccessed?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCourseSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ScenarioListRelationFilter = {
    every?: ScenarioWhereInput
    some?: ScenarioWhereInput
    none?: ScenarioWhereInput
  }

  export type ScenarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCourseIdModuleIdCompoundUniqueInput = {
    courseId: string
    moduleId: string
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScenarioModuleIdScenarioIdCompoundUniqueInput = {
    moduleId: string
    scenarioId: string
  }

  export type ScenarioCountOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMaxOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioMinOrderByAggregateInput = {
    id?: SortOrder
    scenarioId?: SortOrder
    moduleId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScenarioScalarRelationFilter = {
    is?: ScenarioWhereInput
    isNot?: ScenarioWhereInput
  }

  export type OptionListRelationFilter = {
    every?: OptionWhereInput
    some?: OptionWhereInput
    none?: OptionWhereInput
  }

  export type OptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionScenarioIdQuestionIdCompoundUniqueInput = {
    scenarioId: string
    questionId: string
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    scenarioId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    scenarioId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    scenarioId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    explanation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type OptionQuestionIdOptionIdCompoundUniqueInput = {
    questionId: string
    optionId: string
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserCourseScalarRelationFilter = {
    is?: UserCourseWhereInput
    isNot?: UserCourseWhereInput
  }

  export type UserModuleUserCourseIdModuleIdCompoundUniqueInput = {
    userCourseId: string
    moduleId: string
  }

  export type UserModuleCountOrderByAggregateInput = {
    id?: SortOrder
    userCourseId?: SortOrder
    moduleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserModuleAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    userCourseId?: SortOrder
    moduleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserModuleMinOrderByAggregateInput = {
    id?: SortOrder
    userCourseId?: SortOrder
    moduleId?: SortOrder
    completed?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserModuleSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserResponseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    questionId?: SortOrder
    selectedAnswers?: SortOrder
    isCorrect?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserResponseAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    questionId?: SortOrder
    isCorrect?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserResponseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scenarioId?: SortOrder
    questionId?: SortOrder
    isCorrect?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserResponseSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    achievementId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iconName?: SortOrder
    criteria?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsAvgOrderByAggregateInput = {
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStatsSumOrderByAggregateInput = {
    totalTimeSpent?: SortOrder
    sessionsCompleted?: SortOrder
    questionsAnswered?: SortOrder
    correctAnswers?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    courseId?: SortOrder
    modulesViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    courseId?: SortOrder
    modulesViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    courseId?: SortOrder
    modulesViewed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrganizationInvitationListRelationFilter = {
    every?: OrganizationInvitationWhereInput
    some?: OrganizationInvitationWhereInput
    none?: OrganizationInvitationWhereInput
  }

  export type OrganizationTagListRelationFilter = {
    every?: OrganizationTagWhereInput
    some?: OrganizationTagWhereInput
    none?: OrganizationTagWhereInput
  }

  export type OrganizationInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    azureContainer?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    azureContainer?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    azureContainer?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrganizationMemberOrganizationIdUserIdCompoundUniqueInput = {
    organizationId: string
    userId: string
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTrainingOrganizationIdCourseIdCompoundUniqueInput = {
    organizationId: string
    courseId: string
  }

  export type OrganizationTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    courseId?: SortOrder
    buildId?: SortOrder
    isCustomBuild?: SortOrder
    isActive?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    courseId?: SortOrder
    buildId?: SortOrder
    isCustomBuild?: SortOrder
    isActive?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    courseId?: SortOrder
    buildId?: SortOrder
    isCustomBuild?: SortOrder
    isActive?: SortOrder
    assignedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationInvitationEmailOrganizationIdCompoundUniqueInput = {
    email: string
    organizationId: string
  }

  export type OrganizationInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organizationId?: SortOrder
    inviteCode?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    expiresAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organizationId?: SortOrder
    inviteCode?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    expiresAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    organizationId?: SortOrder
    inviteCode?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invitedBy?: SortOrder
    invitedAt?: SortOrder
    expiresAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTagOrganizationIdNameCompoundUniqueInput = {
    organizationId: string
    name: string
  }

  export type OrganizationTagCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTagMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTagMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationTagScalarRelationFilter = {
    is?: OrganizationTagWhereInput
    isNot?: OrganizationTagWhereInput
  }

  export type UserTagUserIdTagIdCompoundUniqueInput = {
    userId: string
    tagId: string
  }

  export type UserTagCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserTagMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserTagMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tagId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagTrainingTagIdCourseIdCompoundUniqueInput = {
    tagId: string
    courseId: string
  }

  export type TagTrainingCountOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    courseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagTrainingMaxOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    courseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagTrainingMinOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    courseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type FormationScalarRelationFilter = {
    is?: FormationWhereInput
    isNot?: FormationWhereInput
  }

  export type FormationStepListRelationFilter = {
    every?: FormationStepWhereInput
    some?: FormationStepWhereInput
    none?: FormationStepWhereInput
  }

  export type FormationQuestionListRelationFilter = {
    every?: FormationQuestionWhereInput
    some?: FormationQuestionWhereInput
    none?: FormationQuestionWhereInput
  }

  export type FormationStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormationQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormationContentCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    formationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    educationalTitle?: SortOrder
    educationalText?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationContentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FormationContentMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    formationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    educationalTitle?: SortOrder
    educationalText?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationContentMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    formationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    order?: SortOrder
    educationalTitle?: SortOrder
    educationalText?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationContentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FormationContentScalarRelationFilter = {
    is?: FormationContentWhereInput
    isNot?: FormationContentWhereInput
  }

  export type FormationStepCountOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    contentId?: SortOrder
    title?: SortOrder
    instruction?: SortOrder
    validationEvent?: SortOrder
    validationType?: SortOrder
    hint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationStepMaxOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    contentId?: SortOrder
    title?: SortOrder
    instruction?: SortOrder
    validationEvent?: SortOrder
    validationType?: SortOrder
    hint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationStepMinOrderByAggregateInput = {
    id?: SortOrder
    stepId?: SortOrder
    contentId?: SortOrder
    title?: SortOrder
    instruction?: SortOrder
    validationEvent?: SortOrder
    validationType?: SortOrder
    hint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationOptionListRelationFilter = {
    every?: FormationOptionWhereInput
    some?: FormationOptionWhereInput
    none?: FormationOptionWhereInput
  }

  export type FormationOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormationQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    contentId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    contentId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    contentId?: SortOrder
    text?: SortOrder
    type?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationQuestionScalarRelationFilter = {
    is?: FormationQuestionWhereInput
    isNot?: FormationQuestionWhereInput
  }

  export type FormationOptionCountOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationOptionMinOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FormationContentListRelationFilter = {
    every?: FormationContentWhereInput
    some?: FormationContentWhereInput
    none?: FormationContentWhereInput
  }

  export type FormationContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormationCountOrderByAggregateInput = {
    id?: SortOrder
    formationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    objectMapping?: SortOrder
    buildId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationMaxOrderByAggregateInput = {
    id?: SortOrder
    formationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    buildId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FormationMinOrderByAggregateInput = {
    id?: SortOrder
    formationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    duration?: SortOrder
    buildId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserCourseCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput> | UserCourseCreateWithoutUserInput[] | UserCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserInput | UserCourseCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseCreateManyUserInputEnvelope
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
  }

  export type UserResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput> | UserResponseCreateWithoutUserInput[] | UserResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutUserInput | UserResponseCreateOrConnectWithoutUserInput[]
    createMany?: UserResponseCreateManyUserInputEnvelope
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type UserTagCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput> | UserTagCreateWithoutUserInput[] | UserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserInput | UserTagCreateOrConnectWithoutUserInput[]
    createMany?: UserTagCreateManyUserInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type UserCourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput> | UserCourseCreateWithoutUserInput[] | UserCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserInput | UserCourseCreateOrConnectWithoutUserInput[]
    createMany?: UserCourseCreateManyUserInputEnvelope
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
  }

  export type UserResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput> | UserResponseCreateWithoutUserInput[] | UserResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutUserInput | UserResponseCreateOrConnectWithoutUserInput[]
    createMany?: UserResponseCreateManyUserInputEnvelope
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type UserTagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput> | UserTagCreateWithoutUserInput[] | UserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserInput | UserTagCreateOrConnectWithoutUserInput[]
    createMany?: UserTagCreateManyUserInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput> | UserCourseCreateWithoutUserInput[] | UserCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserInput | UserCourseCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseUpsertWithWhereUniqueWithoutUserInput | UserCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseCreateManyUserInputEnvelope
    set?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    disconnect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    delete?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    update?: UserCourseUpdateWithWhereUniqueWithoutUserInput | UserCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseUpdateManyWithWhereWithoutUserInput | UserCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
  }

  export type UserResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput> | UserResponseCreateWithoutUserInput[] | UserResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutUserInput | UserResponseCreateOrConnectWithoutUserInput[]
    upsert?: UserResponseUpsertWithWhereUniqueWithoutUserInput | UserResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserResponseCreateManyUserInputEnvelope
    set?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    disconnect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    delete?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    update?: UserResponseUpdateWithWhereUniqueWithoutUserInput | UserResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserResponseUpdateManyWithWhereWithoutUserInput | UserResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type UserTagUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput> | UserTagCreateWithoutUserInput[] | UserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserInput | UserTagCreateOrConnectWithoutUserInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUserInput | UserTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagCreateManyUserInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUserInput | UserTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUserInput | UserTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type UserCourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput> | UserCourseCreateWithoutUserInput[] | UserCourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserInput | UserCourseCreateOrConnectWithoutUserInput[]
    upsert?: UserCourseUpsertWithWhereUniqueWithoutUserInput | UserCourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCourseCreateManyUserInputEnvelope
    set?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    disconnect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    delete?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    update?: UserCourseUpdateWithWhereUniqueWithoutUserInput | UserCourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCourseUpdateManyWithWhereWithoutUserInput | UserCourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
  }

  export type UserResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput> | UserResponseCreateWithoutUserInput[] | UserResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutUserInput | UserResponseCreateOrConnectWithoutUserInput[]
    upsert?: UserResponseUpsertWithWhereUniqueWithoutUserInput | UserResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserResponseCreateManyUserInputEnvelope
    set?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    disconnect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    delete?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    update?: UserResponseUpdateWithWhereUniqueWithoutUserInput | UserResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserResponseUpdateManyWithWhereWithoutUserInput | UserResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type UserTagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput> | UserTagCreateWithoutUserInput[] | UserTagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutUserInput | UserTagCreateOrConnectWithoutUserInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutUserInput | UserTagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTagCreateManyUserInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutUserInput | UserTagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutUserInput | UserTagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type ModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type UserCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput> | UserCourseCreateWithoutCourseInput[] | UserCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutCourseInput | UserCourseCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseCreateManyCourseInputEnvelope
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput> | UserSessionCreateWithoutCourseInput[] | UserSessionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutCourseInput | UserSessionCreateOrConnectWithoutCourseInput[]
    createMany?: UserSessionCreateManyCourseInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OrganizationTrainingCreateNestedManyWithoutCourseInput = {
    create?: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput> | OrganizationTrainingCreateWithoutCourseInput[] | OrganizationTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutCourseInput | OrganizationTrainingCreateOrConnectWithoutCourseInput[]
    createMany?: OrganizationTrainingCreateManyCourseInputEnvelope
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
  }

  export type TagTrainingCreateNestedManyWithoutCourseInput = {
    create?: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput> | TagTrainingCreateWithoutCourseInput[] | TagTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutCourseInput | TagTrainingCreateOrConnectWithoutCourseInput[]
    createMany?: TagTrainingCreateManyCourseInputEnvelope
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type UserCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput> | UserCourseCreateWithoutCourseInput[] | UserCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutCourseInput | UserCourseCreateOrConnectWithoutCourseInput[]
    createMany?: UserCourseCreateManyCourseInputEnvelope
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput> | UserSessionCreateWithoutCourseInput[] | UserSessionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutCourseInput | UserSessionCreateOrConnectWithoutCourseInput[]
    createMany?: UserSessionCreateManyCourseInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput> | OrganizationTrainingCreateWithoutCourseInput[] | OrganizationTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutCourseInput | OrganizationTrainingCreateOrConnectWithoutCourseInput[]
    createMany?: OrganizationTrainingCreateManyCourseInputEnvelope
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
  }

  export type TagTrainingUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput> | TagTrainingCreateWithoutCourseInput[] | TagTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutCourseInput | TagTrainingCreateOrConnectWithoutCourseInput[]
    createMany?: TagTrainingCreateManyCourseInputEnvelope
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
  }

  export type ModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type UserCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput> | UserCourseCreateWithoutCourseInput[] | UserCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutCourseInput | UserCourseCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseUpsertWithWhereUniqueWithoutCourseInput | UserCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseCreateManyCourseInputEnvelope
    set?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    disconnect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    delete?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    update?: UserCourseUpdateWithWhereUniqueWithoutCourseInput | UserCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseUpdateManyWithWhereWithoutCourseInput | UserCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput> | UserSessionCreateWithoutCourseInput[] | UserSessionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutCourseInput | UserSessionCreateOrConnectWithoutCourseInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutCourseInput | UserSessionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserSessionCreateManyCourseInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutCourseInput | UserSessionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutCourseInput | UserSessionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OrganizationTrainingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput> | OrganizationTrainingCreateWithoutCourseInput[] | OrganizationTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutCourseInput | OrganizationTrainingCreateOrConnectWithoutCourseInput[]
    upsert?: OrganizationTrainingUpsertWithWhereUniqueWithoutCourseInput | OrganizationTrainingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OrganizationTrainingCreateManyCourseInputEnvelope
    set?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    disconnect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    delete?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    update?: OrganizationTrainingUpdateWithWhereUniqueWithoutCourseInput | OrganizationTrainingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OrganizationTrainingUpdateManyWithWhereWithoutCourseInput | OrganizationTrainingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
  }

  export type TagTrainingUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput> | TagTrainingCreateWithoutCourseInput[] | TagTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutCourseInput | TagTrainingCreateOrConnectWithoutCourseInput[]
    upsert?: TagTrainingUpsertWithWhereUniqueWithoutCourseInput | TagTrainingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TagTrainingCreateManyCourseInputEnvelope
    set?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    disconnect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    delete?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    update?: TagTrainingUpdateWithWhereUniqueWithoutCourseInput | TagTrainingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TagTrainingUpdateManyWithWhereWithoutCourseInput | TagTrainingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type UserCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput> | UserCourseCreateWithoutCourseInput[] | UserCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserCourseCreateOrConnectWithoutCourseInput | UserCourseCreateOrConnectWithoutCourseInput[]
    upsert?: UserCourseUpsertWithWhereUniqueWithoutCourseInput | UserCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserCourseCreateManyCourseInputEnvelope
    set?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    disconnect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    delete?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    connect?: UserCourseWhereUniqueInput | UserCourseWhereUniqueInput[]
    update?: UserCourseUpdateWithWhereUniqueWithoutCourseInput | UserCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserCourseUpdateManyWithWhereWithoutCourseInput | UserCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput> | UserSessionCreateWithoutCourseInput[] | UserSessionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutCourseInput | UserSessionCreateOrConnectWithoutCourseInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutCourseInput | UserSessionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: UserSessionCreateManyCourseInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutCourseInput | UserSessionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutCourseInput | UserSessionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput> | OrganizationTrainingCreateWithoutCourseInput[] | OrganizationTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutCourseInput | OrganizationTrainingCreateOrConnectWithoutCourseInput[]
    upsert?: OrganizationTrainingUpsertWithWhereUniqueWithoutCourseInput | OrganizationTrainingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OrganizationTrainingCreateManyCourseInputEnvelope
    set?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    disconnect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    delete?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    update?: OrganizationTrainingUpdateWithWhereUniqueWithoutCourseInput | OrganizationTrainingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OrganizationTrainingUpdateManyWithWhereWithoutCourseInput | OrganizationTrainingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
  }

  export type TagTrainingUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput> | TagTrainingCreateWithoutCourseInput[] | TagTrainingUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutCourseInput | TagTrainingCreateOrConnectWithoutCourseInput[]
    upsert?: TagTrainingUpsertWithWhereUniqueWithoutCourseInput | TagTrainingUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: TagTrainingCreateManyCourseInputEnvelope
    set?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    disconnect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    delete?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    update?: TagTrainingUpdateWithWhereUniqueWithoutCourseInput | TagTrainingUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: TagTrainingUpdateManyWithWhereWithoutCourseInput | TagTrainingUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserCoursesInput = {
    create?: XOR<UserCreateWithoutUserCoursesInput, UserUncheckedCreateWithoutUserCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutUserCoursesInput = {
    create?: XOR<CourseCreateWithoutUserCoursesInput, CourseUncheckedCreateWithoutUserCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type UserModuleCreateNestedManyWithoutUserCourseInput = {
    create?: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput> | UserModuleCreateWithoutUserCourseInput[] | UserModuleUncheckedCreateWithoutUserCourseInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutUserCourseInput | UserModuleCreateOrConnectWithoutUserCourseInput[]
    createMany?: UserModuleCreateManyUserCourseInputEnvelope
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
  }

  export type UserModuleUncheckedCreateNestedManyWithoutUserCourseInput = {
    create?: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput> | UserModuleCreateWithoutUserCourseInput[] | UserModuleUncheckedCreateWithoutUserCourseInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutUserCourseInput | UserModuleCreateOrConnectWithoutUserCourseInput[]
    createMany?: UserModuleCreateManyUserCourseInputEnvelope
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutUserCoursesNestedInput = {
    create?: XOR<UserCreateWithoutUserCoursesInput, UserUncheckedCreateWithoutUserCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCoursesInput
    upsert?: UserUpsertWithoutUserCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCoursesInput, UserUpdateWithoutUserCoursesInput>, UserUncheckedUpdateWithoutUserCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutUserCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutUserCoursesInput, CourseUncheckedCreateWithoutUserCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserCoursesInput
    upsert?: CourseUpsertWithoutUserCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutUserCoursesInput, CourseUpdateWithoutUserCoursesInput>, CourseUncheckedUpdateWithoutUserCoursesInput>
  }

  export type UserModuleUpdateManyWithoutUserCourseNestedInput = {
    create?: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput> | UserModuleCreateWithoutUserCourseInput[] | UserModuleUncheckedCreateWithoutUserCourseInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutUserCourseInput | UserModuleCreateOrConnectWithoutUserCourseInput[]
    upsert?: UserModuleUpsertWithWhereUniqueWithoutUserCourseInput | UserModuleUpsertWithWhereUniqueWithoutUserCourseInput[]
    createMany?: UserModuleCreateManyUserCourseInputEnvelope
    set?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    disconnect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    delete?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    update?: UserModuleUpdateWithWhereUniqueWithoutUserCourseInput | UserModuleUpdateWithWhereUniqueWithoutUserCourseInput[]
    updateMany?: UserModuleUpdateManyWithWhereWithoutUserCourseInput | UserModuleUpdateManyWithWhereWithoutUserCourseInput[]
    deleteMany?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
  }

  export type UserModuleUncheckedUpdateManyWithoutUserCourseNestedInput = {
    create?: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput> | UserModuleCreateWithoutUserCourseInput[] | UserModuleUncheckedCreateWithoutUserCourseInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutUserCourseInput | UserModuleCreateOrConnectWithoutUserCourseInput[]
    upsert?: UserModuleUpsertWithWhereUniqueWithoutUserCourseInput | UserModuleUpsertWithWhereUniqueWithoutUserCourseInput[]
    createMany?: UserModuleCreateManyUserCourseInputEnvelope
    set?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    disconnect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    delete?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    update?: UserModuleUpdateWithWhereUniqueWithoutUserCourseInput | UserModuleUpdateWithWhereUniqueWithoutUserCourseInput[]
    updateMany?: UserModuleUpdateManyWithWhereWithoutUserCourseInput | UserModuleUpdateManyWithWhereWithoutUserCourseInput[]
    deleteMany?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutModulesInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    connect?: CourseWhereUniqueInput
  }

  export type ScenarioCreateNestedManyWithoutModuleInput = {
    create?: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput> | ScenarioCreateWithoutModuleInput[] | ScenarioUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutModuleInput | ScenarioCreateOrConnectWithoutModuleInput[]
    createMany?: ScenarioCreateManyModuleInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type UserModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput> | UserModuleCreateWithoutModuleInput[] | UserModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutModuleInput | UserModuleCreateOrConnectWithoutModuleInput[]
    createMany?: UserModuleCreateManyModuleInputEnvelope
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
  }

  export type ScenarioUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput> | ScenarioCreateWithoutModuleInput[] | ScenarioUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutModuleInput | ScenarioCreateOrConnectWithoutModuleInput[]
    createMany?: ScenarioCreateManyModuleInputEnvelope
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
  }

  export type UserModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput> | UserModuleCreateWithoutModuleInput[] | UserModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutModuleInput | UserModuleCreateOrConnectWithoutModuleInput[]
    createMany?: UserModuleCreateManyModuleInputEnvelope
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModulesInput
    upsert?: CourseUpsertWithoutModulesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModulesInput, CourseUpdateWithoutModulesInput>, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type ScenarioUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput> | ScenarioCreateWithoutModuleInput[] | ScenarioUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutModuleInput | ScenarioCreateOrConnectWithoutModuleInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutModuleInput | ScenarioUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ScenarioCreateManyModuleInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutModuleInput | ScenarioUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutModuleInput | ScenarioUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type UserModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput> | UserModuleCreateWithoutModuleInput[] | UserModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutModuleInput | UserModuleCreateOrConnectWithoutModuleInput[]
    upsert?: UserModuleUpsertWithWhereUniqueWithoutModuleInput | UserModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: UserModuleCreateManyModuleInputEnvelope
    set?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    disconnect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    delete?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    update?: UserModuleUpdateWithWhereUniqueWithoutModuleInput | UserModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: UserModuleUpdateManyWithWhereWithoutModuleInput | UserModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
  }

  export type ScenarioUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput> | ScenarioCreateWithoutModuleInput[] | ScenarioUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ScenarioCreateOrConnectWithoutModuleInput | ScenarioCreateOrConnectWithoutModuleInput[]
    upsert?: ScenarioUpsertWithWhereUniqueWithoutModuleInput | ScenarioUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ScenarioCreateManyModuleInputEnvelope
    set?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    disconnect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    delete?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    connect?: ScenarioWhereUniqueInput | ScenarioWhereUniqueInput[]
    update?: ScenarioUpdateWithWhereUniqueWithoutModuleInput | ScenarioUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ScenarioUpdateManyWithWhereWithoutModuleInput | ScenarioUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
  }

  export type UserModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput> | UserModuleCreateWithoutModuleInput[] | UserModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: UserModuleCreateOrConnectWithoutModuleInput | UserModuleCreateOrConnectWithoutModuleInput[]
    upsert?: UserModuleUpsertWithWhereUniqueWithoutModuleInput | UserModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: UserModuleCreateManyModuleInputEnvelope
    set?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    disconnect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    delete?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    connect?: UserModuleWhereUniqueInput | UserModuleWhereUniqueInput[]
    update?: UserModuleUpdateWithWhereUniqueWithoutModuleInput | UserModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: UserModuleUpdateManyWithWhereWithoutModuleInput | UserModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutScenariosInput = {
    create?: XOR<ModuleCreateWithoutScenariosInput, ModuleUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutScenariosInput
    connect?: ModuleWhereUniqueInput
  }

  export type QuestionCreateNestedManyWithoutScenarioInput = {
    create?: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput> | QuestionCreateWithoutScenarioInput[] | QuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutScenarioInput | QuestionCreateOrConnectWithoutScenarioInput[]
    createMany?: QuestionCreateManyScenarioInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type UserResponseCreateNestedManyWithoutScenarioInput = {
    create?: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput> | UserResponseCreateWithoutScenarioInput[] | UserResponseUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutScenarioInput | UserResponseCreateOrConnectWithoutScenarioInput[]
    createMany?: UserResponseCreateManyScenarioInputEnvelope
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput> | QuestionCreateWithoutScenarioInput[] | QuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutScenarioInput | QuestionCreateOrConnectWithoutScenarioInput[]
    createMany?: QuestionCreateManyScenarioInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type UserResponseUncheckedCreateNestedManyWithoutScenarioInput = {
    create?: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput> | UserResponseCreateWithoutScenarioInput[] | UserResponseUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutScenarioInput | UserResponseCreateOrConnectWithoutScenarioInput[]
    createMany?: UserResponseCreateManyScenarioInputEnvelope
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
  }

  export type ModuleUpdateOneRequiredWithoutScenariosNestedInput = {
    create?: XOR<ModuleCreateWithoutScenariosInput, ModuleUncheckedCreateWithoutScenariosInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutScenariosInput
    upsert?: ModuleUpsertWithoutScenariosInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutScenariosInput, ModuleUpdateWithoutScenariosInput>, ModuleUncheckedUpdateWithoutScenariosInput>
  }

  export type QuestionUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput> | QuestionCreateWithoutScenarioInput[] | QuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutScenarioInput | QuestionCreateOrConnectWithoutScenarioInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutScenarioInput | QuestionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: QuestionCreateManyScenarioInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutScenarioInput | QuestionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutScenarioInput | QuestionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type UserResponseUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput> | UserResponseCreateWithoutScenarioInput[] | UserResponseUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutScenarioInput | UserResponseCreateOrConnectWithoutScenarioInput[]
    upsert?: UserResponseUpsertWithWhereUniqueWithoutScenarioInput | UserResponseUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: UserResponseCreateManyScenarioInputEnvelope
    set?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    disconnect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    delete?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    update?: UserResponseUpdateWithWhereUniqueWithoutScenarioInput | UserResponseUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: UserResponseUpdateManyWithWhereWithoutScenarioInput | UserResponseUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput> | QuestionCreateWithoutScenarioInput[] | QuestionUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutScenarioInput | QuestionCreateOrConnectWithoutScenarioInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutScenarioInput | QuestionUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: QuestionCreateManyScenarioInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutScenarioInput | QuestionUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutScenarioInput | QuestionUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type UserResponseUncheckedUpdateManyWithoutScenarioNestedInput = {
    create?: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput> | UserResponseCreateWithoutScenarioInput[] | UserResponseUncheckedCreateWithoutScenarioInput[]
    connectOrCreate?: UserResponseCreateOrConnectWithoutScenarioInput | UserResponseCreateOrConnectWithoutScenarioInput[]
    upsert?: UserResponseUpsertWithWhereUniqueWithoutScenarioInput | UserResponseUpsertWithWhereUniqueWithoutScenarioInput[]
    createMany?: UserResponseCreateManyScenarioInputEnvelope
    set?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    disconnect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    delete?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    connect?: UserResponseWhereUniqueInput | UserResponseWhereUniqueInput[]
    update?: UserResponseUpdateWithWhereUniqueWithoutScenarioInput | UserResponseUpdateWithWhereUniqueWithoutScenarioInput[]
    updateMany?: UserResponseUpdateManyWithWhereWithoutScenarioInput | UserResponseUpdateManyWithWhereWithoutScenarioInput[]
    deleteMany?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
  }

  export type ScenarioCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ScenarioCreateWithoutQuestionsInput, ScenarioUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutQuestionsInput
    connect?: ScenarioWhereUniqueInput
  }

  export type OptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type OptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type ScenarioUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ScenarioCreateWithoutQuestionsInput, ScenarioUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutQuestionsInput
    upsert?: ScenarioUpsertWithoutQuestionsInput
    connect?: ScenarioWhereUniqueInput
    update?: XOR<XOR<ScenarioUpdateToOneWithWhereWithoutQuestionsInput, ScenarioUpdateWithoutQuestionsInput>, ScenarioUncheckedUpdateWithoutQuestionsInput>
  }

  export type OptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutQuestionInput | OptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutQuestionInput | OptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutQuestionInput | OptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type OptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutQuestionInput | OptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutQuestionInput | OptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutQuestionInput | OptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type QuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuestionUpsertWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutOptionsInput, QuestionUpdateWithoutOptionsInput>, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type UserCourseCreateNestedOneWithoutUserModulesInput = {
    create?: XOR<UserCourseCreateWithoutUserModulesInput, UserCourseUncheckedCreateWithoutUserModulesInput>
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserModulesInput
    connect?: UserCourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutUserModulesInput = {
    create?: XOR<ModuleCreateWithoutUserModulesInput, ModuleUncheckedCreateWithoutUserModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutUserModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type UserCourseUpdateOneRequiredWithoutUserModulesNestedInput = {
    create?: XOR<UserCourseCreateWithoutUserModulesInput, UserCourseUncheckedCreateWithoutUserModulesInput>
    connectOrCreate?: UserCourseCreateOrConnectWithoutUserModulesInput
    upsert?: UserCourseUpsertWithoutUserModulesInput
    connect?: UserCourseWhereUniqueInput
    update?: XOR<XOR<UserCourseUpdateToOneWithWhereWithoutUserModulesInput, UserCourseUpdateWithoutUserModulesInput>, UserCourseUncheckedUpdateWithoutUserModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutUserModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutUserModulesInput, ModuleUncheckedCreateWithoutUserModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutUserModulesInput
    upsert?: ModuleUpsertWithoutUserModulesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutUserModulesInput, ModuleUpdateWithoutUserModulesInput>, ModuleUncheckedUpdateWithoutUserModulesInput>
  }

  export type UserResponseCreateselectedAnswersInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutUserResponsesInput = {
    create?: XOR<UserCreateWithoutUserResponsesInput, UserUncheckedCreateWithoutUserResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type ScenarioCreateNestedOneWithoutUserResponsesInput = {
    create?: XOR<ScenarioCreateWithoutUserResponsesInput, ScenarioUncheckedCreateWithoutUserResponsesInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserResponsesInput
    connect?: ScenarioWhereUniqueInput
  }

  export type UserResponseUpdateselectedAnswersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutUserResponsesNestedInput = {
    create?: XOR<UserCreateWithoutUserResponsesInput, UserUncheckedCreateWithoutUserResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserResponsesInput
    upsert?: UserUpsertWithoutUserResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserResponsesInput, UserUpdateWithoutUserResponsesInput>, UserUncheckedUpdateWithoutUserResponsesInput>
  }

  export type ScenarioUpdateOneRequiredWithoutUserResponsesNestedInput = {
    create?: XOR<ScenarioCreateWithoutUserResponsesInput, ScenarioUncheckedCreateWithoutUserResponsesInput>
    connectOrCreate?: ScenarioCreateOrConnectWithoutUserResponsesInput
    upsert?: ScenarioUpsertWithoutUserResponsesInput
    connect?: ScenarioWhereUniqueInput
    update?: XOR<XOR<ScenarioUpdateToOneWithWhereWithoutUserResponsesInput, ScenarioUpdateWithoutUserResponsesInput>, ScenarioUncheckedUpdateWithoutUserResponsesInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<UserCreateWithoutUserAchievementsInput, UserUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutUserAchievementsInput, UserUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAchievementsInput
    upsert?: UserUpsertWithoutUserAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAchievementsInput, UserUpdateWithoutUserAchievementsInput>, UserUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserCreateNestedOneWithoutUserStatsInput = {
    create?: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserStatsNestedInput = {
    create?: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserStatsInput
    upsert?: UserUpsertWithoutUserStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserStatsInput, UserUpdateWithoutUserStatsInput>, UserUncheckedUpdateWithoutUserStatsInput>
  }

  export type UserCreateNestedOneWithoutUserSessionInput = {
    create?: XOR<UserCreateWithoutUserSessionInput, UserUncheckedCreateWithoutUserSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<CourseCreateWithoutUserSessionsInput, CourseUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserSessionsInput
    connect?: CourseWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutUserSessionNestedInput = {
    create?: XOR<UserCreateWithoutUserSessionInput, UserUncheckedCreateWithoutUserSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionInput
    upsert?: UserUpsertWithoutUserSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSessionInput, UserUpdateWithoutUserSessionInput>, UserUncheckedUpdateWithoutUserSessionInput>
  }

  export type CourseUpdateOneWithoutUserSessionsNestedInput = {
    create?: XOR<CourseCreateWithoutUserSessionsInput, CourseUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutUserSessionsInput
    upsert?: CourseUpsertWithoutUserSessionsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutUserSessionsInput, CourseUpdateWithoutUserSessionsInput>, CourseUncheckedUpdateWithoutUserSessionsInput>
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type OrganizationTrainingCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput> | OrganizationTrainingCreateWithoutOrganizationInput[] | OrganizationTrainingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutOrganizationInput | OrganizationTrainingCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationTrainingCreateManyOrganizationInputEnvelope
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
  }

  export type OrganizationInvitationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
  }

  export type OrganizationTagCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput> | OrganizationTagCreateWithoutOrganizationInput[] | OrganizationTagUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutOrganizationInput | OrganizationTagCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationTagCreateManyOrganizationInputEnvelope
    connect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type OrganizationTrainingUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput> | OrganizationTrainingCreateWithoutOrganizationInput[] | OrganizationTrainingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutOrganizationInput | OrganizationTrainingCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationTrainingCreateManyOrganizationInputEnvelope
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
  }

  export type OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
  }

  export type OrganizationTagUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput> | OrganizationTagCreateWithoutOrganizationInput[] | OrganizationTagUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutOrganizationInput | OrganizationTagCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationTagCreateManyOrganizationInputEnvelope
    connect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type OrganizationTrainingUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput> | OrganizationTrainingCreateWithoutOrganizationInput[] | OrganizationTrainingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutOrganizationInput | OrganizationTrainingCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationTrainingUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationTrainingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationTrainingCreateManyOrganizationInputEnvelope
    set?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    disconnect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    delete?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    update?: OrganizationTrainingUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationTrainingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationTrainingUpdateManyWithWhereWithoutOrganizationInput | OrganizationTrainingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
  }

  export type OrganizationInvitationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    disconnect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    delete?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    update?: OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput | OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
  }

  export type OrganizationTagUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput> | OrganizationTagCreateWithoutOrganizationInput[] | OrganizationTagUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutOrganizationInput | OrganizationTagCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationTagUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationTagUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationTagCreateManyOrganizationInputEnvelope
    set?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    disconnect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    delete?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    connect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    update?: OrganizationTagUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationTagUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationTagUpdateManyWithWhereWithoutOrganizationInput | OrganizationTagUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationTagScalarWhereInput | OrganizationTagScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type OrganizationTrainingUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput> | OrganizationTrainingCreateWithoutOrganizationInput[] | OrganizationTrainingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTrainingCreateOrConnectWithoutOrganizationInput | OrganizationTrainingCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationTrainingUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationTrainingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationTrainingCreateManyOrganizationInputEnvelope
    set?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    disconnect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    delete?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    connect?: OrganizationTrainingWhereUniqueInput | OrganizationTrainingWhereUniqueInput[]
    update?: OrganizationTrainingUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationTrainingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationTrainingUpdateManyWithWhereWithoutOrganizationInput | OrganizationTrainingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput> | OrganizationInvitationCreateWithoutOrganizationInput[] | OrganizationInvitationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationInvitationCreateOrConnectWithoutOrganizationInput | OrganizationInvitationCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationInvitationCreateManyOrganizationInputEnvelope
    set?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    disconnect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    delete?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    connect?: OrganizationInvitationWhereUniqueInput | OrganizationInvitationWhereUniqueInput[]
    update?: OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput | OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
  }

  export type OrganizationTagUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput> | OrganizationTagCreateWithoutOrganizationInput[] | OrganizationTagUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutOrganizationInput | OrganizationTagCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationTagUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationTagUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationTagCreateManyOrganizationInputEnvelope
    set?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    disconnect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    delete?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    connect?: OrganizationTagWhereUniqueInput | OrganizationTagWhereUniqueInput[]
    update?: OrganizationTagUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationTagUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationTagUpdateManyWithWhereWithoutOrganizationInput | OrganizationTagUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationTagScalarWhereInput | OrganizationTagScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    upsert?: UserUpsertWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationsInput, UserUpdateWithoutOrganizationsInput>, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type OrganizationCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<OrganizationCreateWithoutTrainingsInput, OrganizationUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTrainingsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutOrganizationTrainingInput = {
    create?: XOR<CourseCreateWithoutOrganizationTrainingInput, CourseUncheckedCreateWithoutOrganizationTrainingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOrganizationTrainingInput
    connect?: CourseWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTrainingsInput, OrganizationUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTrainingsInput
    upsert?: OrganizationUpsertWithoutTrainingsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTrainingsInput, OrganizationUpdateWithoutTrainingsInput>, OrganizationUncheckedUpdateWithoutTrainingsInput>
  }

  export type CourseUpdateOneRequiredWithoutOrganizationTrainingNestedInput = {
    create?: XOR<CourseCreateWithoutOrganizationTrainingInput, CourseUncheckedCreateWithoutOrganizationTrainingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOrganizationTrainingInput
    upsert?: CourseUpsertWithoutOrganizationTrainingInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOrganizationTrainingInput, CourseUpdateWithoutOrganizationTrainingInput>, CourseUncheckedUpdateWithoutOrganizationTrainingInput>
  }

  export type OrganizationCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInvitationsInput
    upsert?: OrganizationUpsertWithoutInvitationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInvitationsInput, OrganizationUpdateWithoutInvitationsInput>, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationCreateNestedOneWithoutTagsInput = {
    create?: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserTagCreateNestedManyWithoutTagInput = {
    create?: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput> | UserTagCreateWithoutTagInput[] | UserTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutTagInput | UserTagCreateOrConnectWithoutTagInput[]
    createMany?: UserTagCreateManyTagInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type TagTrainingCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput> | TagTrainingCreateWithoutTagInput[] | TagTrainingUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutTagInput | TagTrainingCreateOrConnectWithoutTagInput[]
    createMany?: TagTrainingCreateManyTagInputEnvelope
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
  }

  export type UserTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput> | UserTagCreateWithoutTagInput[] | UserTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutTagInput | UserTagCreateOrConnectWithoutTagInput[]
    createMany?: UserTagCreateManyTagInputEnvelope
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
  }

  export type TagTrainingUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput> | TagTrainingCreateWithoutTagInput[] | TagTrainingUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutTagInput | TagTrainingCreateOrConnectWithoutTagInput[]
    createMany?: TagTrainingCreateManyTagInputEnvelope
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTagsInput
    upsert?: OrganizationUpsertWithoutTagsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTagsInput, OrganizationUpdateWithoutTagsInput>, OrganizationUncheckedUpdateWithoutTagsInput>
  }

  export type UserTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput> | UserTagCreateWithoutTagInput[] | UserTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutTagInput | UserTagCreateOrConnectWithoutTagInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutTagInput | UserTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: UserTagCreateManyTagInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutTagInput | UserTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutTagInput | UserTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type TagTrainingUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput> | TagTrainingCreateWithoutTagInput[] | TagTrainingUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutTagInput | TagTrainingCreateOrConnectWithoutTagInput[]
    upsert?: TagTrainingUpsertWithWhereUniqueWithoutTagInput | TagTrainingUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTrainingCreateManyTagInputEnvelope
    set?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    disconnect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    delete?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    update?: TagTrainingUpdateWithWhereUniqueWithoutTagInput | TagTrainingUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTrainingUpdateManyWithWhereWithoutTagInput | TagTrainingUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
  }

  export type UserTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput> | UserTagCreateWithoutTagInput[] | UserTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: UserTagCreateOrConnectWithoutTagInput | UserTagCreateOrConnectWithoutTagInput[]
    upsert?: UserTagUpsertWithWhereUniqueWithoutTagInput | UserTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: UserTagCreateManyTagInputEnvelope
    set?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    disconnect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    delete?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    connect?: UserTagWhereUniqueInput | UserTagWhereUniqueInput[]
    update?: UserTagUpdateWithWhereUniqueWithoutTagInput | UserTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: UserTagUpdateManyWithWhereWithoutTagInput | UserTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
  }

  export type TagTrainingUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput> | TagTrainingCreateWithoutTagInput[] | TagTrainingUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagTrainingCreateOrConnectWithoutTagInput | TagTrainingCreateOrConnectWithoutTagInput[]
    upsert?: TagTrainingUpsertWithWhereUniqueWithoutTagInput | TagTrainingUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagTrainingCreateManyTagInputEnvelope
    set?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    disconnect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    delete?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    connect?: TagTrainingWhereUniqueInput | TagTrainingWhereUniqueInput[]
    update?: TagTrainingUpdateWithWhereUniqueWithoutTagInput | TagTrainingUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagTrainingUpdateManyWithWhereWithoutTagInput | TagTrainingUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTagsInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationTagCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationTagCreateWithoutUsersInput, OrganizationTagUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutUsersInput
    connect?: OrganizationTagWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTagsInput
    upsert?: UserUpsertWithoutTagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTagsInput, UserUpdateWithoutTagsInput>, UserUncheckedUpdateWithoutTagsInput>
  }

  export type OrganizationTagUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationTagCreateWithoutUsersInput, OrganizationTagUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutUsersInput
    upsert?: OrganizationTagUpsertWithoutUsersInput
    connect?: OrganizationTagWhereUniqueInput
    update?: XOR<XOR<OrganizationTagUpdateToOneWithWhereWithoutUsersInput, OrganizationTagUpdateWithoutUsersInput>, OrganizationTagUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationTagCreateNestedOneWithoutTrainingsInput = {
    create?: XOR<OrganizationTagCreateWithoutTrainingsInput, OrganizationTagUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutTrainingsInput
    connect?: OrganizationTagWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutTagTrainingInput = {
    create?: XOR<CourseCreateWithoutTagTrainingInput, CourseUncheckedCreateWithoutTagTrainingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagTrainingInput
    connect?: CourseWhereUniqueInput
  }

  export type OrganizationTagUpdateOneRequiredWithoutTrainingsNestedInput = {
    create?: XOR<OrganizationTagCreateWithoutTrainingsInput, OrganizationTagUncheckedCreateWithoutTrainingsInput>
    connectOrCreate?: OrganizationTagCreateOrConnectWithoutTrainingsInput
    upsert?: OrganizationTagUpsertWithoutTrainingsInput
    connect?: OrganizationTagWhereUniqueInput
    update?: XOR<XOR<OrganizationTagUpdateToOneWithWhereWithoutTrainingsInput, OrganizationTagUpdateWithoutTrainingsInput>, OrganizationTagUncheckedUpdateWithoutTrainingsInput>
  }

  export type CourseUpdateOneRequiredWithoutTagTrainingNestedInput = {
    create?: XOR<CourseCreateWithoutTagTrainingInput, CourseUncheckedCreateWithoutTagTrainingInput>
    connectOrCreate?: CourseCreateOrConnectWithoutTagTrainingInput
    upsert?: CourseUpsertWithoutTagTrainingInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutTagTrainingInput, CourseUpdateWithoutTagTrainingInput>, CourseUncheckedUpdateWithoutTagTrainingInput>
  }

  export type FormationCreateNestedOneWithoutContentsInput = {
    create?: XOR<FormationCreateWithoutContentsInput, FormationUncheckedCreateWithoutContentsInput>
    connectOrCreate?: FormationCreateOrConnectWithoutContentsInput
    connect?: FormationWhereUniqueInput
  }

  export type FormationStepCreateNestedManyWithoutContentInput = {
    create?: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput> | FormationStepCreateWithoutContentInput[] | FormationStepUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationStepCreateOrConnectWithoutContentInput | FormationStepCreateOrConnectWithoutContentInput[]
    createMany?: FormationStepCreateManyContentInputEnvelope
    connect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
  }

  export type FormationQuestionCreateNestedManyWithoutContentInput = {
    create?: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput> | FormationQuestionCreateWithoutContentInput[] | FormationQuestionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutContentInput | FormationQuestionCreateOrConnectWithoutContentInput[]
    createMany?: FormationQuestionCreateManyContentInputEnvelope
    connect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
  }

  export type FormationStepUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput> | FormationStepCreateWithoutContentInput[] | FormationStepUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationStepCreateOrConnectWithoutContentInput | FormationStepCreateOrConnectWithoutContentInput[]
    createMany?: FormationStepCreateManyContentInputEnvelope
    connect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
  }

  export type FormationQuestionUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput> | FormationQuestionCreateWithoutContentInput[] | FormationQuestionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutContentInput | FormationQuestionCreateOrConnectWithoutContentInput[]
    createMany?: FormationQuestionCreateManyContentInputEnvelope
    connect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
  }

  export type FormationUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<FormationCreateWithoutContentsInput, FormationUncheckedCreateWithoutContentsInput>
    connectOrCreate?: FormationCreateOrConnectWithoutContentsInput
    upsert?: FormationUpsertWithoutContentsInput
    connect?: FormationWhereUniqueInput
    update?: XOR<XOR<FormationUpdateToOneWithWhereWithoutContentsInput, FormationUpdateWithoutContentsInput>, FormationUncheckedUpdateWithoutContentsInput>
  }

  export type FormationStepUpdateManyWithoutContentNestedInput = {
    create?: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput> | FormationStepCreateWithoutContentInput[] | FormationStepUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationStepCreateOrConnectWithoutContentInput | FormationStepCreateOrConnectWithoutContentInput[]
    upsert?: FormationStepUpsertWithWhereUniqueWithoutContentInput | FormationStepUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FormationStepCreateManyContentInputEnvelope
    set?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    disconnect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    delete?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    connect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    update?: FormationStepUpdateWithWhereUniqueWithoutContentInput | FormationStepUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FormationStepUpdateManyWithWhereWithoutContentInput | FormationStepUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FormationStepScalarWhereInput | FormationStepScalarWhereInput[]
  }

  export type FormationQuestionUpdateManyWithoutContentNestedInput = {
    create?: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput> | FormationQuestionCreateWithoutContentInput[] | FormationQuestionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutContentInput | FormationQuestionCreateOrConnectWithoutContentInput[]
    upsert?: FormationQuestionUpsertWithWhereUniqueWithoutContentInput | FormationQuestionUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FormationQuestionCreateManyContentInputEnvelope
    set?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    disconnect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    delete?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    connect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    update?: FormationQuestionUpdateWithWhereUniqueWithoutContentInput | FormationQuestionUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FormationQuestionUpdateManyWithWhereWithoutContentInput | FormationQuestionUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FormationQuestionScalarWhereInput | FormationQuestionScalarWhereInput[]
  }

  export type FormationStepUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput> | FormationStepCreateWithoutContentInput[] | FormationStepUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationStepCreateOrConnectWithoutContentInput | FormationStepCreateOrConnectWithoutContentInput[]
    upsert?: FormationStepUpsertWithWhereUniqueWithoutContentInput | FormationStepUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FormationStepCreateManyContentInputEnvelope
    set?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    disconnect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    delete?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    connect?: FormationStepWhereUniqueInput | FormationStepWhereUniqueInput[]
    update?: FormationStepUpdateWithWhereUniqueWithoutContentInput | FormationStepUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FormationStepUpdateManyWithWhereWithoutContentInput | FormationStepUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FormationStepScalarWhereInput | FormationStepScalarWhereInput[]
  }

  export type FormationQuestionUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput> | FormationQuestionCreateWithoutContentInput[] | FormationQuestionUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutContentInput | FormationQuestionCreateOrConnectWithoutContentInput[]
    upsert?: FormationQuestionUpsertWithWhereUniqueWithoutContentInput | FormationQuestionUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FormationQuestionCreateManyContentInputEnvelope
    set?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    disconnect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    delete?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    connect?: FormationQuestionWhereUniqueInput | FormationQuestionWhereUniqueInput[]
    update?: FormationQuestionUpdateWithWhereUniqueWithoutContentInput | FormationQuestionUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FormationQuestionUpdateManyWithWhereWithoutContentInput | FormationQuestionUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FormationQuestionScalarWhereInput | FormationQuestionScalarWhereInput[]
  }

  export type FormationContentCreateNestedOneWithoutStepsInput = {
    create?: XOR<FormationContentCreateWithoutStepsInput, FormationContentUncheckedCreateWithoutStepsInput>
    connectOrCreate?: FormationContentCreateOrConnectWithoutStepsInput
    connect?: FormationContentWhereUniqueInput
  }

  export type FormationContentUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<FormationContentCreateWithoutStepsInput, FormationContentUncheckedCreateWithoutStepsInput>
    connectOrCreate?: FormationContentCreateOrConnectWithoutStepsInput
    upsert?: FormationContentUpsertWithoutStepsInput
    connect?: FormationContentWhereUniqueInput
    update?: XOR<XOR<FormationContentUpdateToOneWithWhereWithoutStepsInput, FormationContentUpdateWithoutStepsInput>, FormationContentUncheckedUpdateWithoutStepsInput>
  }

  export type FormationContentCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<FormationContentCreateWithoutQuestionsInput, FormationContentUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FormationContentCreateOrConnectWithoutQuestionsInput
    connect?: FormationContentWhereUniqueInput
  }

  export type FormationOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput> | FormationOptionCreateWithoutQuestionInput[] | FormationOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: FormationOptionCreateOrConnectWithoutQuestionInput | FormationOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: FormationOptionCreateManyQuestionInputEnvelope
    connect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
  }

  export type FormationOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput> | FormationOptionCreateWithoutQuestionInput[] | FormationOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: FormationOptionCreateOrConnectWithoutQuestionInput | FormationOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: FormationOptionCreateManyQuestionInputEnvelope
    connect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
  }

  export type FormationContentUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<FormationContentCreateWithoutQuestionsInput, FormationContentUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: FormationContentCreateOrConnectWithoutQuestionsInput
    upsert?: FormationContentUpsertWithoutQuestionsInput
    connect?: FormationContentWhereUniqueInput
    update?: XOR<XOR<FormationContentUpdateToOneWithWhereWithoutQuestionsInput, FormationContentUpdateWithoutQuestionsInput>, FormationContentUncheckedUpdateWithoutQuestionsInput>
  }

  export type FormationOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput> | FormationOptionCreateWithoutQuestionInput[] | FormationOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: FormationOptionCreateOrConnectWithoutQuestionInput | FormationOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: FormationOptionUpsertWithWhereUniqueWithoutQuestionInput | FormationOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: FormationOptionCreateManyQuestionInputEnvelope
    set?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    disconnect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    delete?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    connect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    update?: FormationOptionUpdateWithWhereUniqueWithoutQuestionInput | FormationOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: FormationOptionUpdateManyWithWhereWithoutQuestionInput | FormationOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: FormationOptionScalarWhereInput | FormationOptionScalarWhereInput[]
  }

  export type FormationOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput> | FormationOptionCreateWithoutQuestionInput[] | FormationOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: FormationOptionCreateOrConnectWithoutQuestionInput | FormationOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: FormationOptionUpsertWithWhereUniqueWithoutQuestionInput | FormationOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: FormationOptionCreateManyQuestionInputEnvelope
    set?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    disconnect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    delete?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    connect?: FormationOptionWhereUniqueInput | FormationOptionWhereUniqueInput[]
    update?: FormationOptionUpdateWithWhereUniqueWithoutQuestionInput | FormationOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: FormationOptionUpdateManyWithWhereWithoutQuestionInput | FormationOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: FormationOptionScalarWhereInput | FormationOptionScalarWhereInput[]
  }

  export type FormationQuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<FormationQuestionCreateWithoutOptionsInput, FormationQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutOptionsInput
    connect?: FormationQuestionWhereUniqueInput
  }

  export type FormationQuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<FormationQuestionCreateWithoutOptionsInput, FormationQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FormationQuestionCreateOrConnectWithoutOptionsInput
    upsert?: FormationQuestionUpsertWithoutOptionsInput
    connect?: FormationQuestionWhereUniqueInput
    update?: XOR<XOR<FormationQuestionUpdateToOneWithWhereWithoutOptionsInput, FormationQuestionUpdateWithoutOptionsInput>, FormationQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type FormationContentCreateNestedManyWithoutFormationInput = {
    create?: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput> | FormationContentCreateWithoutFormationInput[] | FormationContentUncheckedCreateWithoutFormationInput[]
    connectOrCreate?: FormationContentCreateOrConnectWithoutFormationInput | FormationContentCreateOrConnectWithoutFormationInput[]
    createMany?: FormationContentCreateManyFormationInputEnvelope
    connect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
  }

  export type FormationContentUncheckedCreateNestedManyWithoutFormationInput = {
    create?: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput> | FormationContentCreateWithoutFormationInput[] | FormationContentUncheckedCreateWithoutFormationInput[]
    connectOrCreate?: FormationContentCreateOrConnectWithoutFormationInput | FormationContentCreateOrConnectWithoutFormationInput[]
    createMany?: FormationContentCreateManyFormationInputEnvelope
    connect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
  }

  export type FormationContentUpdateManyWithoutFormationNestedInput = {
    create?: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput> | FormationContentCreateWithoutFormationInput[] | FormationContentUncheckedCreateWithoutFormationInput[]
    connectOrCreate?: FormationContentCreateOrConnectWithoutFormationInput | FormationContentCreateOrConnectWithoutFormationInput[]
    upsert?: FormationContentUpsertWithWhereUniqueWithoutFormationInput | FormationContentUpsertWithWhereUniqueWithoutFormationInput[]
    createMany?: FormationContentCreateManyFormationInputEnvelope
    set?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    disconnect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    delete?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    connect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    update?: FormationContentUpdateWithWhereUniqueWithoutFormationInput | FormationContentUpdateWithWhereUniqueWithoutFormationInput[]
    updateMany?: FormationContentUpdateManyWithWhereWithoutFormationInput | FormationContentUpdateManyWithWhereWithoutFormationInput[]
    deleteMany?: FormationContentScalarWhereInput | FormationContentScalarWhereInput[]
  }

  export type FormationContentUncheckedUpdateManyWithoutFormationNestedInput = {
    create?: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput> | FormationContentCreateWithoutFormationInput[] | FormationContentUncheckedCreateWithoutFormationInput[]
    connectOrCreate?: FormationContentCreateOrConnectWithoutFormationInput | FormationContentCreateOrConnectWithoutFormationInput[]
    upsert?: FormationContentUpsertWithWhereUniqueWithoutFormationInput | FormationContentUpsertWithWhereUniqueWithoutFormationInput[]
    createMany?: FormationContentCreateManyFormationInputEnvelope
    set?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    disconnect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    delete?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    connect?: FormationContentWhereUniqueInput | FormationContentWhereUniqueInput[]
    update?: FormationContentUpdateWithWhereUniqueWithoutFormationInput | FormationContentUpdateWithWhereUniqueWithoutFormationInput[]
    updateMany?: FormationContentUpdateManyWithWhereWithoutFormationInput | FormationContentUpdateManyWithWhereWithoutFormationInput[]
    deleteMany?: FormationContentScalarWhereInput | FormationContentScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserCourseCreateWithoutUserInput = {
    id?: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutUserCoursesInput
    userModules?: UserModuleCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userModules?: UserModuleUncheckedCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseCreateOrConnectWithoutUserInput = {
    where: UserCourseWhereUniqueInput
    create: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput>
  }

  export type UserCourseCreateManyUserInputEnvelope = {
    data: UserCourseCreateManyUserInput | UserCourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserResponseCreateWithoutUserInput = {
    id?: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenario: ScenarioCreateNestedOneWithoutUserResponsesInput
  }

  export type UserResponseUncheckedCreateWithoutUserInput = {
    id?: string
    scenarioId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseCreateOrConnectWithoutUserInput = {
    where: UserResponseWhereUniqueInput
    create: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput>
  }

  export type UserResponseCreateManyUserInputEnvelope = {
    data: UserResponseCreateManyUserInput | UserResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStatsCreateWithoutUserInput = {
    id?: string
    totalTimeSpent?: number
    sessionsCompleted?: number
    questionsAnswered?: number
    correctAnswers?: number
    lastActivity?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsUncheckedCreateWithoutUserInput = {
    id?: string
    totalTimeSpent?: number
    sessionsCompleted?: number
    questionsAnswered?: number
    correctAnswers?: number
    lastActivity?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStatsCreateOrConnectWithoutUserInput = {
    where: UserStatsWhereUniqueInput
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    course?: CourseCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    courseId?: string | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutUserInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateManyUserInputEnvelope = {
    data: OrganizationMemberCreateManyUserInput | OrganizationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTagCreateWithoutUserInput = {
    id?: string
    assignedAt?: Date | string
    tag: OrganizationTagCreateNestedOneWithoutUsersInput
  }

  export type UserTagUncheckedCreateWithoutUserInput = {
    id?: string
    tagId: string
    assignedAt?: Date | string
  }

  export type UserTagCreateOrConnectWithoutUserInput = {
    where: UserTagWhereUniqueInput
    create: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput>
  }

  export type UserTagCreateManyUserInputEnvelope = {
    data: UserTagCreateManyUserInput | UserTagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCourseWhereUniqueInput
    update: XOR<UserCourseUpdateWithoutUserInput, UserCourseUncheckedUpdateWithoutUserInput>
    create: XOR<UserCourseCreateWithoutUserInput, UserCourseUncheckedCreateWithoutUserInput>
  }

  export type UserCourseUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCourseWhereUniqueInput
    data: XOR<UserCourseUpdateWithoutUserInput, UserCourseUncheckedUpdateWithoutUserInput>
  }

  export type UserCourseUpdateManyWithWhereWithoutUserInput = {
    where: UserCourseScalarWhereInput
    data: XOR<UserCourseUpdateManyMutationInput, UserCourseUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCourseScalarWhereInput = {
    AND?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
    OR?: UserCourseScalarWhereInput[]
    NOT?: UserCourseScalarWhereInput | UserCourseScalarWhereInput[]
    id?: StringFilter<"UserCourse"> | string
    userId?: StringFilter<"UserCourse"> | string
    courseId?: StringFilter<"UserCourse"> | string
    progress?: IntFilter<"UserCourse"> | number
    lastAccessed?: DateTimeFilter<"UserCourse"> | Date | string
    startedAt?: DateTimeFilter<"UserCourse"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserCourse"> | Date | string | null
    createdAt?: DateTimeFilter<"UserCourse"> | Date | string
    updatedAt?: DateTimeFilter<"UserCourse"> | Date | string
  }

  export type UserResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: UserResponseWhereUniqueInput
    update: XOR<UserResponseUpdateWithoutUserInput, UserResponseUncheckedUpdateWithoutUserInput>
    create: XOR<UserResponseCreateWithoutUserInput, UserResponseUncheckedCreateWithoutUserInput>
  }

  export type UserResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: UserResponseWhereUniqueInput
    data: XOR<UserResponseUpdateWithoutUserInput, UserResponseUncheckedUpdateWithoutUserInput>
  }

  export type UserResponseUpdateManyWithWhereWithoutUserInput = {
    where: UserResponseScalarWhereInput
    data: XOR<UserResponseUpdateManyMutationInput, UserResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type UserResponseScalarWhereInput = {
    AND?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
    OR?: UserResponseScalarWhereInput[]
    NOT?: UserResponseScalarWhereInput | UserResponseScalarWhereInput[]
    id?: StringFilter<"UserResponse"> | string
    userId?: StringFilter<"UserResponse"> | string
    scenarioId?: StringFilter<"UserResponse"> | string
    questionId?: StringFilter<"UserResponse"> | string
    selectedAnswers?: StringNullableListFilter<"UserResponse">
    isCorrect?: BoolFilter<"UserResponse"> | boolean
    score?: IntFilter<"UserResponse"> | number
    createdAt?: DateTimeFilter<"UserResponse"> | Date | string
    updatedAt?: DateTimeFilter<"UserResponse"> | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    data?: StringNullableFilter<"UserAchievement"> | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type UserStatsUpsertWithoutUserInput = {
    update: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    where?: UserStatsWhereInput
  }

  export type UserStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStatsWhereInput
    data: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    sessionsCompleted?: IntFieldUpdateOperationsInput | number
    questionsAnswered?: IntFieldUpdateOperationsInput | number
    correctAnswers?: IntFieldUpdateOperationsInput | number
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    startTime?: DateTimeFilter<"UserSession"> | Date | string
    endTime?: DateTimeNullableFilter<"UserSession"> | Date | string | null
    duration?: IntNullableFilter<"UserSession"> | number | null
    courseId?: StringNullableFilter<"UserSession"> | string | null
    modulesViewed?: StringNullableFilter<"UserSession"> | string | null
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: StringFilter<"OrganizationMember"> | string
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
  }

  export type UserTagUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTagWhereUniqueInput
    update: XOR<UserTagUpdateWithoutUserInput, UserTagUncheckedUpdateWithoutUserInput>
    create: XOR<UserTagCreateWithoutUserInput, UserTagUncheckedCreateWithoutUserInput>
  }

  export type UserTagUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTagWhereUniqueInput
    data: XOR<UserTagUpdateWithoutUserInput, UserTagUncheckedUpdateWithoutUserInput>
  }

  export type UserTagUpdateManyWithWhereWithoutUserInput = {
    where: UserTagScalarWhereInput
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTagScalarWhereInput = {
    AND?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    OR?: UserTagScalarWhereInput[]
    NOT?: UserTagScalarWhereInput | UserTagScalarWhereInput[]
    id?: StringFilter<"UserTag"> | string
    userId?: StringFilter<"UserTag"> | string
    tagId?: StringFilter<"UserTag"> | string
    assignedAt?: DateTimeFilter<"UserTag"> | Date | string
  }

  export type ModuleCreateWithoutCourseInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: ScenarioCreateNestedManyWithoutModuleInput
    userModules?: UserModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutModuleInput
    userModules?: UserModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleCreateManyCourseInputEnvelope = {
    data: ModuleCreateManyCourseInput | ModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserCourseCreateWithoutCourseInput = {
    id?: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCoursesInput
    userModules?: UserModuleCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userModules?: UserModuleUncheckedCreateNestedManyWithoutUserCourseInput
  }

  export type UserCourseCreateOrConnectWithoutCourseInput = {
    where: UserCourseWhereUniqueInput
    create: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseCreateManyCourseInputEnvelope = {
    data: UserCourseCreateManyCourseInput | UserCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutCourseInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSessionInput
  }

  export type UserSessionUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutCourseInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput>
  }

  export type UserSessionCreateManyCourseInputEnvelope = {
    data: UserSessionCreateManyCourseInput | UserSessionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationTrainingCreateWithoutCourseInput = {
    id?: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTrainingsInput
  }

  export type OrganizationTrainingUncheckedCreateWithoutCourseInput = {
    id?: string
    organizationId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingCreateOrConnectWithoutCourseInput = {
    where: OrganizationTrainingWhereUniqueInput
    create: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput>
  }

  export type OrganizationTrainingCreateManyCourseInputEnvelope = {
    data: OrganizationTrainingCreateManyCourseInput | OrganizationTrainingCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type TagTrainingCreateWithoutCourseInput = {
    id?: string
    assignedAt?: Date | string
    tag: OrganizationTagCreateNestedOneWithoutTrainingsInput
  }

  export type TagTrainingUncheckedCreateWithoutCourseInput = {
    id?: string
    tagId: string
    assignedAt?: Date | string
  }

  export type TagTrainingCreateOrConnectWithoutCourseInput = {
    where: TagTrainingWhereUniqueInput
    create: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput>
  }

  export type TagTrainingCreateManyCourseInputEnvelope = {
    data: TagTrainingCreateManyCourseInput | TagTrainingCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCourseInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    moduleId?: StringFilter<"Module"> | string
    courseId?: StringFilter<"Module"> | string
    title?: StringFilter<"Module"> | string
    description?: StringFilter<"Module"> | string
    order?: IntFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type UserCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserCourseWhereUniqueInput
    update: XOR<UserCourseUpdateWithoutCourseInput, UserCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCourseCreateWithoutCourseInput, UserCourseUncheckedCreateWithoutCourseInput>
  }

  export type UserCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserCourseWhereUniqueInput
    data: XOR<UserCourseUpdateWithoutCourseInput, UserCourseUncheckedUpdateWithoutCourseInput>
  }

  export type UserCourseUpdateManyWithWhereWithoutCourseInput = {
    where: UserCourseScalarWhereInput
    data: XOR<UserCourseUpdateManyMutationInput, UserCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserSessionUpsertWithWhereUniqueWithoutCourseInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutCourseInput, UserSessionUncheckedUpdateWithoutCourseInput>
    create: XOR<UserSessionCreateWithoutCourseInput, UserSessionUncheckedCreateWithoutCourseInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutCourseInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutCourseInput, UserSessionUncheckedUpdateWithoutCourseInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutCourseInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutCourseInput>
  }

  export type OrganizationTrainingUpsertWithWhereUniqueWithoutCourseInput = {
    where: OrganizationTrainingWhereUniqueInput
    update: XOR<OrganizationTrainingUpdateWithoutCourseInput, OrganizationTrainingUncheckedUpdateWithoutCourseInput>
    create: XOR<OrganizationTrainingCreateWithoutCourseInput, OrganizationTrainingUncheckedCreateWithoutCourseInput>
  }

  export type OrganizationTrainingUpdateWithWhereUniqueWithoutCourseInput = {
    where: OrganizationTrainingWhereUniqueInput
    data: XOR<OrganizationTrainingUpdateWithoutCourseInput, OrganizationTrainingUncheckedUpdateWithoutCourseInput>
  }

  export type OrganizationTrainingUpdateManyWithWhereWithoutCourseInput = {
    where: OrganizationTrainingScalarWhereInput
    data: XOR<OrganizationTrainingUpdateManyMutationInput, OrganizationTrainingUncheckedUpdateManyWithoutCourseInput>
  }

  export type OrganizationTrainingScalarWhereInput = {
    AND?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
    OR?: OrganizationTrainingScalarWhereInput[]
    NOT?: OrganizationTrainingScalarWhereInput | OrganizationTrainingScalarWhereInput[]
    id?: StringFilter<"OrganizationTraining"> | string
    organizationId?: StringFilter<"OrganizationTraining"> | string
    courseId?: StringFilter<"OrganizationTraining"> | string
    buildId?: StringNullableFilter<"OrganizationTraining"> | string | null
    isCustomBuild?: BoolFilter<"OrganizationTraining"> | boolean
    isActive?: BoolFilter<"OrganizationTraining"> | boolean
    assignedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTraining"> | Date | string
  }

  export type TagTrainingUpsertWithWhereUniqueWithoutCourseInput = {
    where: TagTrainingWhereUniqueInput
    update: XOR<TagTrainingUpdateWithoutCourseInput, TagTrainingUncheckedUpdateWithoutCourseInput>
    create: XOR<TagTrainingCreateWithoutCourseInput, TagTrainingUncheckedCreateWithoutCourseInput>
  }

  export type TagTrainingUpdateWithWhereUniqueWithoutCourseInput = {
    where: TagTrainingWhereUniqueInput
    data: XOR<TagTrainingUpdateWithoutCourseInput, TagTrainingUncheckedUpdateWithoutCourseInput>
  }

  export type TagTrainingUpdateManyWithWhereWithoutCourseInput = {
    where: TagTrainingScalarWhereInput
    data: XOR<TagTrainingUpdateManyMutationInput, TagTrainingUncheckedUpdateManyWithoutCourseInput>
  }

  export type TagTrainingScalarWhereInput = {
    AND?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
    OR?: TagTrainingScalarWhereInput[]
    NOT?: TagTrainingScalarWhereInput | TagTrainingScalarWhereInput[]
    id?: StringFilter<"TagTraining"> | string
    tagId?: StringFilter<"TagTraining"> | string
    courseId?: StringFilter<"TagTraining"> | string
    assignedAt?: DateTimeFilter<"TagTraining"> | Date | string
  }

  export type UserCreateWithoutUserCoursesInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCoursesInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCoursesInput, UserUncheckedCreateWithoutUserCoursesInput>
  }

  export type CourseCreateWithoutUserCoursesInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserCoursesInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserCoursesInput, CourseUncheckedCreateWithoutUserCoursesInput>
  }

  export type UserModuleCreateWithoutUserCourseInput = {
    id?: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutUserModulesInput
  }

  export type UserModuleUncheckedCreateWithoutUserCourseInput = {
    id?: string
    moduleId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleCreateOrConnectWithoutUserCourseInput = {
    where: UserModuleWhereUniqueInput
    create: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput>
  }

  export type UserModuleCreateManyUserCourseInputEnvelope = {
    data: UserModuleCreateManyUserCourseInput | UserModuleCreateManyUserCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserCoursesInput = {
    update: XOR<UserUpdateWithoutUserCoursesInput, UserUncheckedUpdateWithoutUserCoursesInput>
    create: XOR<UserCreateWithoutUserCoursesInput, UserUncheckedCreateWithoutUserCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCoursesInput, UserUncheckedUpdateWithoutUserCoursesInput>
  }

  export type UserUpdateWithoutUserCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutUserCoursesInput = {
    update: XOR<CourseUpdateWithoutUserCoursesInput, CourseUncheckedUpdateWithoutUserCoursesInput>
    create: XOR<CourseCreateWithoutUserCoursesInput, CourseUncheckedCreateWithoutUserCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutUserCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutUserCoursesInput, CourseUncheckedUpdateWithoutUserCoursesInput>
  }

  export type CourseUpdateWithoutUserCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserModuleUpsertWithWhereUniqueWithoutUserCourseInput = {
    where: UserModuleWhereUniqueInput
    update: XOR<UserModuleUpdateWithoutUserCourseInput, UserModuleUncheckedUpdateWithoutUserCourseInput>
    create: XOR<UserModuleCreateWithoutUserCourseInput, UserModuleUncheckedCreateWithoutUserCourseInput>
  }

  export type UserModuleUpdateWithWhereUniqueWithoutUserCourseInput = {
    where: UserModuleWhereUniqueInput
    data: XOR<UserModuleUpdateWithoutUserCourseInput, UserModuleUncheckedUpdateWithoutUserCourseInput>
  }

  export type UserModuleUpdateManyWithWhereWithoutUserCourseInput = {
    where: UserModuleScalarWhereInput
    data: XOR<UserModuleUpdateManyMutationInput, UserModuleUncheckedUpdateManyWithoutUserCourseInput>
  }

  export type UserModuleScalarWhereInput = {
    AND?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
    OR?: UserModuleScalarWhereInput[]
    NOT?: UserModuleScalarWhereInput | UserModuleScalarWhereInput[]
    id?: StringFilter<"UserModule"> | string
    userCourseId?: StringFilter<"UserModule"> | string
    moduleId?: StringFilter<"UserModule"> | string
    completed?: BoolFilter<"UserModule"> | boolean
    score?: IntFilter<"UserModule"> | number
    createdAt?: DateTimeFilter<"UserModule"> | Date | string
    updatedAt?: DateTimeFilter<"UserModule"> | Date | string
  }

  export type CourseCreateWithoutModulesInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModulesInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModulesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
  }

  export type ScenarioCreateWithoutModuleInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutScenarioInput
    userResponses?: UserResponseCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutModuleInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutScenarioInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioCreateOrConnectWithoutModuleInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput>
  }

  export type ScenarioCreateManyModuleInputEnvelope = {
    data: ScenarioCreateManyModuleInput | ScenarioCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type UserModuleCreateWithoutModuleInput = {
    id?: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourse: UserCourseCreateNestedOneWithoutUserModulesInput
  }

  export type UserModuleUncheckedCreateWithoutModuleInput = {
    id?: string
    userCourseId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleCreateOrConnectWithoutModuleInput = {
    where: UserModuleWhereUniqueInput
    create: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput>
  }

  export type UserModuleCreateManyModuleInputEnvelope = {
    data: UserModuleCreateManyModuleInput | UserModuleCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModulesInput = {
    update: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
    create: XOR<CourseCreateWithoutModulesInput, CourseUncheckedCreateWithoutModulesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModulesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModulesInput, CourseUncheckedUpdateWithoutModulesInput>
  }

  export type CourseUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ScenarioUpsertWithWhereUniqueWithoutModuleInput = {
    where: ScenarioWhereUniqueInput
    update: XOR<ScenarioUpdateWithoutModuleInput, ScenarioUncheckedUpdateWithoutModuleInput>
    create: XOR<ScenarioCreateWithoutModuleInput, ScenarioUncheckedCreateWithoutModuleInput>
  }

  export type ScenarioUpdateWithWhereUniqueWithoutModuleInput = {
    where: ScenarioWhereUniqueInput
    data: XOR<ScenarioUpdateWithoutModuleInput, ScenarioUncheckedUpdateWithoutModuleInput>
  }

  export type ScenarioUpdateManyWithWhereWithoutModuleInput = {
    where: ScenarioScalarWhereInput
    data: XOR<ScenarioUpdateManyMutationInput, ScenarioUncheckedUpdateManyWithoutModuleInput>
  }

  export type ScenarioScalarWhereInput = {
    AND?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    OR?: ScenarioScalarWhereInput[]
    NOT?: ScenarioScalarWhereInput | ScenarioScalarWhereInput[]
    id?: StringFilter<"Scenario"> | string
    scenarioId?: StringFilter<"Scenario"> | string
    moduleId?: StringFilter<"Scenario"> | string
    title?: StringFilter<"Scenario"> | string
    description?: StringFilter<"Scenario"> | string
    createdAt?: DateTimeFilter<"Scenario"> | Date | string
    updatedAt?: DateTimeFilter<"Scenario"> | Date | string
  }

  export type UserModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: UserModuleWhereUniqueInput
    update: XOR<UserModuleUpdateWithoutModuleInput, UserModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<UserModuleCreateWithoutModuleInput, UserModuleUncheckedCreateWithoutModuleInput>
  }

  export type UserModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: UserModuleWhereUniqueInput
    data: XOR<UserModuleUpdateWithoutModuleInput, UserModuleUncheckedUpdateWithoutModuleInput>
  }

  export type UserModuleUpdateManyWithWhereWithoutModuleInput = {
    where: UserModuleScalarWhereInput
    data: XOR<UserModuleUpdateManyMutationInput, UserModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleCreateWithoutScenariosInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    userModules?: UserModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutScenariosInput = {
    id?: string
    moduleId: string
    courseId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userModules?: UserModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutScenariosInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutScenariosInput, ModuleUncheckedCreateWithoutScenariosInput>
  }

  export type QuestionCreateWithoutScenarioInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: OptionCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutScenarioInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutScenarioInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput>
  }

  export type QuestionCreateManyScenarioInputEnvelope = {
    data: QuestionCreateManyScenarioInput | QuestionCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type UserResponseCreateWithoutScenarioInput = {
    id?: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserResponsesInput
  }

  export type UserResponseUncheckedCreateWithoutScenarioInput = {
    id?: string
    userId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseCreateOrConnectWithoutScenarioInput = {
    where: UserResponseWhereUniqueInput
    create: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput>
  }

  export type UserResponseCreateManyScenarioInputEnvelope = {
    data: UserResponseCreateManyScenarioInput | UserResponseCreateManyScenarioInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutScenariosInput = {
    update: XOR<ModuleUpdateWithoutScenariosInput, ModuleUncheckedUpdateWithoutScenariosInput>
    create: XOR<ModuleCreateWithoutScenariosInput, ModuleUncheckedCreateWithoutScenariosInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutScenariosInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutScenariosInput, ModuleUncheckedUpdateWithoutScenariosInput>
  }

  export type ModuleUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    userModules?: UserModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutScenariosInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userModules?: UserModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type QuestionUpsertWithWhereUniqueWithoutScenarioInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutScenarioInput, QuestionUncheckedUpdateWithoutScenarioInput>
    create: XOR<QuestionCreateWithoutScenarioInput, QuestionUncheckedCreateWithoutScenarioInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutScenarioInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutScenarioInput, QuestionUncheckedUpdateWithoutScenarioInput>
  }

  export type QuestionUpdateManyWithWhereWithoutScenarioInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutScenarioInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    questionId?: StringFilter<"Question"> | string
    scenarioId?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    explanation?: StringNullableFilter<"Question"> | string | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type UserResponseUpsertWithWhereUniqueWithoutScenarioInput = {
    where: UserResponseWhereUniqueInput
    update: XOR<UserResponseUpdateWithoutScenarioInput, UserResponseUncheckedUpdateWithoutScenarioInput>
    create: XOR<UserResponseCreateWithoutScenarioInput, UserResponseUncheckedCreateWithoutScenarioInput>
  }

  export type UserResponseUpdateWithWhereUniqueWithoutScenarioInput = {
    where: UserResponseWhereUniqueInput
    data: XOR<UserResponseUpdateWithoutScenarioInput, UserResponseUncheckedUpdateWithoutScenarioInput>
  }

  export type UserResponseUpdateManyWithWhereWithoutScenarioInput = {
    where: UserResponseScalarWhereInput
    data: XOR<UserResponseUpdateManyMutationInput, UserResponseUncheckedUpdateManyWithoutScenarioInput>
  }

  export type ScenarioCreateWithoutQuestionsInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutScenariosInput
    userResponses?: UserResponseCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutQuestionsInput = {
    id?: string
    scenarioId: string
    moduleId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioCreateOrConnectWithoutQuestionsInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutQuestionsInput, ScenarioUncheckedCreateWithoutQuestionsInput>
  }

  export type OptionCreateWithoutQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionCreateOrConnectWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionCreateManyQuestionInputEnvelope = {
    data: OptionCreateManyQuestionInput | OptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ScenarioUpsertWithoutQuestionsInput = {
    update: XOR<ScenarioUpdateWithoutQuestionsInput, ScenarioUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ScenarioCreateWithoutQuestionsInput, ScenarioUncheckedCreateWithoutQuestionsInput>
    where?: ScenarioWhereInput
  }

  export type ScenarioUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ScenarioWhereInput
    data: XOR<ScenarioUpdateWithoutQuestionsInput, ScenarioUncheckedUpdateWithoutQuestionsInput>
  }

  export type ScenarioUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutScenariosNestedInput
    userResponses?: UserResponseUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userResponses?: UserResponseUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type OptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    update: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    data: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
  }

  export type OptionUpdateManyWithWhereWithoutQuestionInput = {
    where: OptionScalarWhereInput
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type OptionScalarWhereInput = {
    AND?: OptionScalarWhereInput | OptionScalarWhereInput[]
    OR?: OptionScalarWhereInput[]
    NOT?: OptionScalarWhereInput | OptionScalarWhereInput[]
    id?: StringFilter<"Option"> | string
    optionId?: StringFilter<"Option"> | string
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
  }

  export type QuestionCreateWithoutOptionsInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    scenario: ScenarioCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    questionId: string
    scenarioId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutOptionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuestionUpsertWithoutOptionsInput = {
    update: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenario?: ScenarioUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseCreateWithoutUserModulesInput = {
    id?: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserCoursesInput
    course: CourseCreateNestedOneWithoutUserCoursesInput
  }

  export type UserCourseUncheckedCreateWithoutUserModulesInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCreateOrConnectWithoutUserModulesInput = {
    where: UserCourseWhereUniqueInput
    create: XOR<UserCourseCreateWithoutUserModulesInput, UserCourseUncheckedCreateWithoutUserModulesInput>
  }

  export type ModuleCreateWithoutUserModulesInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutModulesInput
    scenarios?: ScenarioCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutUserModulesInput = {
    id?: string
    moduleId: string
    courseId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    scenarios?: ScenarioUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutUserModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutUserModulesInput, ModuleUncheckedCreateWithoutUserModulesInput>
  }

  export type UserCourseUpsertWithoutUserModulesInput = {
    update: XOR<UserCourseUpdateWithoutUserModulesInput, UserCourseUncheckedUpdateWithoutUserModulesInput>
    create: XOR<UserCourseCreateWithoutUserModulesInput, UserCourseUncheckedCreateWithoutUserModulesInput>
    where?: UserCourseWhereInput
  }

  export type UserCourseUpdateToOneWithWhereWithoutUserModulesInput = {
    where?: UserCourseWhereInput
    data: XOR<UserCourseUpdateWithoutUserModulesInput, UserCourseUncheckedUpdateWithoutUserModulesInput>
  }

  export type UserCourseUpdateWithoutUserModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutUserCoursesNestedInput
  }

  export type UserCourseUncheckedUpdateWithoutUserModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpsertWithoutUserModulesInput = {
    update: XOR<ModuleUpdateWithoutUserModulesInput, ModuleUncheckedUpdateWithoutUserModulesInput>
    create: XOR<ModuleCreateWithoutUserModulesInput, ModuleUncheckedCreateWithoutUserModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutUserModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutUserModulesInput, ModuleUncheckedUpdateWithoutUserModulesInput>
  }

  export type ModuleUpdateWithoutUserModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutModulesNestedInput
    scenarios?: ScenarioUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutUserModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: ScenarioUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type UserCreateWithoutUserResponsesInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserResponsesInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserResponsesInput, UserUncheckedCreateWithoutUserResponsesInput>
  }

  export type ScenarioCreateWithoutUserResponsesInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutScenariosInput
    questions?: QuestionCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioUncheckedCreateWithoutUserResponsesInput = {
    id?: string
    scenarioId: string
    moduleId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutScenarioInput
  }

  export type ScenarioCreateOrConnectWithoutUserResponsesInput = {
    where: ScenarioWhereUniqueInput
    create: XOR<ScenarioCreateWithoutUserResponsesInput, ScenarioUncheckedCreateWithoutUserResponsesInput>
  }

  export type UserUpsertWithoutUserResponsesInput = {
    update: XOR<UserUpdateWithoutUserResponsesInput, UserUncheckedUpdateWithoutUserResponsesInput>
    create: XOR<UserCreateWithoutUserResponsesInput, UserUncheckedCreateWithoutUserResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserResponsesInput, UserUncheckedUpdateWithoutUserResponsesInput>
  }

  export type UserUpdateWithoutUserResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScenarioUpsertWithoutUserResponsesInput = {
    update: XOR<ScenarioUpdateWithoutUserResponsesInput, ScenarioUncheckedUpdateWithoutUserResponsesInput>
    create: XOR<ScenarioCreateWithoutUserResponsesInput, ScenarioUncheckedCreateWithoutUserResponsesInput>
    where?: ScenarioWhereInput
  }

  export type ScenarioUpdateToOneWithWhereWithoutUserResponsesInput = {
    where?: ScenarioWhereInput
    data: XOR<ScenarioUpdateWithoutUserResponsesInput, ScenarioUncheckedUpdateWithoutUserResponsesInput>
  }

  export type ScenarioUpdateWithoutUserResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutScenariosNestedInput
    questions?: QuestionUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutUserResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutUserAchievementsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAchievementsInput, UserUncheckedCreateWithoutUserAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    id?: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    achievementId: string
    title: string
    description: string
    iconName: string
    criteria: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutUserAchievementsInput = {
    update: XOR<UserUpdateWithoutUserAchievementsInput, UserUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<UserCreateWithoutUserAchievementsInput, UserUncheckedCreateWithoutUserAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAchievementsInput, UserUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconName?: StringFieldUpdateOperationsInput | string
    criteria?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserStatsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserStatsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
  }

  export type UserUpsertWithoutUserStatsInput = {
    update: XOR<UserUpdateWithoutUserStatsInput, UserUncheckedUpdateWithoutUserStatsInput>
    create: XOR<UserCreateWithoutUserStatsInput, UserUncheckedCreateWithoutUserStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserStatsInput, UserUncheckedUpdateWithoutUserStatsInput>
  }

  export type UserUpdateWithoutUserStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSessionInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSessionInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSessionInput, UserUncheckedCreateWithoutUserSessionInput>
  }

  export type CourseCreateWithoutUserSessionsInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserSessionsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserSessionsInput, CourseUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserUpsertWithoutUserSessionInput = {
    update: XOR<UserUpdateWithoutUserSessionInput, UserUncheckedUpdateWithoutUserSessionInput>
    create: XOR<UserCreateWithoutUserSessionInput, UserUncheckedCreateWithoutUserSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSessionInput, UserUncheckedUpdateWithoutUserSessionInput>
  }

  export type UserUpdateWithoutUserSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutUserSessionsInput = {
    update: XOR<CourseUpdateWithoutUserSessionsInput, CourseUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<CourseCreateWithoutUserSessionsInput, CourseUncheckedCreateWithoutUserSessionsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutUserSessionsInput, CourseUncheckedUpdateWithoutUserSessionsInput>
  }

  export type CourseUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUncheckedUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationTrainingCreateWithoutOrganizationInput = {
    id?: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOrganizationTrainingInput
  }

  export type OrganizationTrainingUncheckedCreateWithoutOrganizationInput = {
    id?: string
    courseId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationTrainingWhereUniqueInput
    create: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationTrainingCreateManyOrganizationInputEnvelope = {
    data: OrganizationTrainingCreateManyOrganizationInput | OrganizationTrainingCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationInvitationCreateWithoutOrganizationInput = {
    id?: string
    email: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationInvitationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationInvitationCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationCreateManyOrganizationInputEnvelope = {
    data: OrganizationInvitationCreateManyOrganizationInput | OrganizationInvitationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationTagCreateWithoutOrganizationInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserTagCreateNestedManyWithoutTagInput
    trainings?: TagTrainingCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserTagUncheckedCreateNestedManyWithoutTagInput
    trainings?: TagTrainingUncheckedCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationTagWhereUniqueInput
    create: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationTagCreateManyOrganizationInputEnvelope = {
    data: OrganizationTagCreateManyOrganizationInput | OrganizationTagCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationTrainingUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationTrainingWhereUniqueInput
    update: XOR<OrganizationTrainingUpdateWithoutOrganizationInput, OrganizationTrainingUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationTrainingCreateWithoutOrganizationInput, OrganizationTrainingUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationTrainingUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationTrainingWhereUniqueInput
    data: XOR<OrganizationTrainingUpdateWithoutOrganizationInput, OrganizationTrainingUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationTrainingUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationTrainingScalarWhereInput
    data: XOR<OrganizationTrainingUpdateManyMutationInput, OrganizationTrainingUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    update: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationInvitationCreateWithoutOrganizationInput, OrganizationInvitationUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationInvitationWhereUniqueInput
    data: XOR<OrganizationInvitationUpdateWithoutOrganizationInput, OrganizationInvitationUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationInvitationScalarWhereInput
    data: XOR<OrganizationInvitationUpdateManyMutationInput, OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationInvitationScalarWhereInput = {
    AND?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
    OR?: OrganizationInvitationScalarWhereInput[]
    NOT?: OrganizationInvitationScalarWhereInput | OrganizationInvitationScalarWhereInput[]
    id?: StringFilter<"OrganizationInvitation"> | string
    email?: StringFilter<"OrganizationInvitation"> | string
    organizationId?: StringFilter<"OrganizationInvitation"> | string
    inviteCode?: StringFilter<"OrganizationInvitation"> | string
    role?: StringFilter<"OrganizationInvitation"> | string
    status?: StringFilter<"OrganizationInvitation"> | string
    invitedBy?: StringFilter<"OrganizationInvitation"> | string
    invitedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    expiresAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationInvitation"> | Date | string
  }

  export type OrganizationTagUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationTagWhereUniqueInput
    update: XOR<OrganizationTagUpdateWithoutOrganizationInput, OrganizationTagUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationTagCreateWithoutOrganizationInput, OrganizationTagUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationTagUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationTagWhereUniqueInput
    data: XOR<OrganizationTagUpdateWithoutOrganizationInput, OrganizationTagUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationTagUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationTagScalarWhereInput
    data: XOR<OrganizationTagUpdateManyMutationInput, OrganizationTagUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationTagScalarWhereInput = {
    AND?: OrganizationTagScalarWhereInput | OrganizationTagScalarWhereInput[]
    OR?: OrganizationTagScalarWhereInput[]
    NOT?: OrganizationTagScalarWhereInput | OrganizationTagScalarWhereInput[]
    id?: StringFilter<"OrganizationTag"> | string
    organizationId?: StringFilter<"OrganizationTag"> | string
    name?: StringFilter<"OrganizationTag"> | string
    color?: StringNullableFilter<"OrganizationTag"> | string | null
    description?: StringNullableFilter<"OrganizationTag"> | string | null
    createdAt?: DateTimeFilter<"OrganizationTag"> | Date | string
    updatedAt?: DateTimeFilter<"OrganizationTag"> | Date | string
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: OrganizationTrainingCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: OrganizationTrainingUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutOrganizationsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    tags?: UserTagCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    tags?: UserTagUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: OrganizationTrainingUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: OrganizationTrainingUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationsInput = {
    update: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type UserUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    tags?: UserTagUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    tags?: UserTagUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutTrainingsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTrainingsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTrainingsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTrainingsInput, OrganizationUncheckedCreateWithoutTrainingsInput>
  }

  export type CourseCreateWithoutOrganizationTrainingInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOrganizationTrainingInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutCourseInput
    TagTraining?: TagTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOrganizationTrainingInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOrganizationTrainingInput, CourseUncheckedCreateWithoutOrganizationTrainingInput>
  }

  export type OrganizationUpsertWithoutTrainingsInput = {
    update: XOR<OrganizationUpdateWithoutTrainingsInput, OrganizationUncheckedUpdateWithoutTrainingsInput>
    create: XOR<OrganizationCreateWithoutTrainingsInput, OrganizationUncheckedCreateWithoutTrainingsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTrainingsInput, OrganizationUncheckedUpdateWithoutTrainingsInput>
  }

  export type OrganizationUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CourseUpsertWithoutOrganizationTrainingInput = {
    update: XOR<CourseUpdateWithoutOrganizationTrainingInput, CourseUncheckedUpdateWithoutOrganizationTrainingInput>
    create: XOR<CourseCreateWithoutOrganizationTrainingInput, CourseUncheckedCreateWithoutOrganizationTrainingInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOrganizationTrainingInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOrganizationTrainingInput, CourseUncheckedUpdateWithoutOrganizationTrainingInput>
  }

  export type CourseUpdateWithoutOrganizationTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOrganizationTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUncheckedUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutCourseNestedInput
    TagTraining?: TagTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type OrganizationCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingUncheckedCreateNestedManyWithoutOrganizationInput
    tags?: OrganizationTagUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInvitationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
  }

  export type OrganizationUpsertWithoutInvitationsInput = {
    update: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
    create: XOR<OrganizationCreateWithoutInvitationsInput, OrganizationUncheckedCreateWithoutInvitationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInvitationsInput, OrganizationUncheckedUpdateWithoutInvitationsInput>
  }

  export type OrganizationUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUncheckedUpdateManyWithoutOrganizationNestedInput
    tags?: OrganizationTagUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateWithoutTagsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    description?: string | null
    logoUrl?: string | null
    azureContainer?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    trainings?: OrganizationTrainingUncheckedCreateNestedManyWithoutOrganizationInput
    invitations?: OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTagsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
  }

  export type UserTagCreateWithoutTagInput = {
    id?: string
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutTagsInput
  }

  export type UserTagUncheckedCreateWithoutTagInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type UserTagCreateOrConnectWithoutTagInput = {
    where: UserTagWhereUniqueInput
    create: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput>
  }

  export type UserTagCreateManyTagInputEnvelope = {
    data: UserTagCreateManyTagInput | UserTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagTrainingCreateWithoutTagInput = {
    id?: string
    assignedAt?: Date | string
    course: CourseCreateNestedOneWithoutTagTrainingInput
  }

  export type TagTrainingUncheckedCreateWithoutTagInput = {
    id?: string
    courseId: string
    assignedAt?: Date | string
  }

  export type TagTrainingCreateOrConnectWithoutTagInput = {
    where: TagTrainingWhereUniqueInput
    create: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput>
  }

  export type TagTrainingCreateManyTagInputEnvelope = {
    data: TagTrainingCreateManyTagInput | TagTrainingCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutTagsInput = {
    update: XOR<OrganizationUpdateWithoutTagsInput, OrganizationUncheckedUpdateWithoutTagsInput>
    create: XOR<OrganizationCreateWithoutTagsInput, OrganizationUncheckedCreateWithoutTagsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTagsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTagsInput, OrganizationUncheckedUpdateWithoutTagsInput>
  }

  export type OrganizationUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    trainings?: OrganizationTrainingUncheckedUpdateManyWithoutOrganizationNestedInput
    invitations?: OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserTagUpsertWithWhereUniqueWithoutTagInput = {
    where: UserTagWhereUniqueInput
    update: XOR<UserTagUpdateWithoutTagInput, UserTagUncheckedUpdateWithoutTagInput>
    create: XOR<UserTagCreateWithoutTagInput, UserTagUncheckedCreateWithoutTagInput>
  }

  export type UserTagUpdateWithWhereUniqueWithoutTagInput = {
    where: UserTagWhereUniqueInput
    data: XOR<UserTagUpdateWithoutTagInput, UserTagUncheckedUpdateWithoutTagInput>
  }

  export type UserTagUpdateManyWithWhereWithoutTagInput = {
    where: UserTagScalarWhereInput
    data: XOR<UserTagUpdateManyMutationInput, UserTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TagTrainingUpsertWithWhereUniqueWithoutTagInput = {
    where: TagTrainingWhereUniqueInput
    update: XOR<TagTrainingUpdateWithoutTagInput, TagTrainingUncheckedUpdateWithoutTagInput>
    create: XOR<TagTrainingCreateWithoutTagInput, TagTrainingUncheckedCreateWithoutTagInput>
  }

  export type TagTrainingUpdateWithWhereUniqueWithoutTagInput = {
    where: TagTrainingWhereUniqueInput
    data: XOR<TagTrainingUpdateWithoutTagInput, TagTrainingUncheckedUpdateWithoutTagInput>
  }

  export type TagTrainingUpdateManyWithWhereWithoutTagInput = {
    where: TagTrainingScalarWhereInput
    data: XOR<TagTrainingUpdateManyMutationInput, TagTrainingUncheckedUpdateManyWithoutTagInput>
  }

  export type UserCreateWithoutTagsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseCreateNestedManyWithoutUserInput
    userResponses?: UserResponseCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementCreateNestedManyWithoutUserInput
    userStats?: UserStatsCreateNestedOneWithoutUserInput
    UserSession?: UserSessionCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTagsInput = {
    id?: string
    auth0Id: string
    email: string
    name?: string | null
    azureContainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutUserInput
    userResponses?: UserResponseUncheckedCreateNestedManyWithoutUserInput
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    userStats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
    UserSession?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
  }

  export type OrganizationTagCreateWithoutUsersInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTagsInput
    trainings?: TagTrainingCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagUncheckedCreateWithoutUsersInput = {
    id?: string
    organizationId: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trainings?: TagTrainingUncheckedCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagCreateOrConnectWithoutUsersInput = {
    where: OrganizationTagWhereUniqueInput
    create: XOR<OrganizationTagCreateWithoutUsersInput, OrganizationTagUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutTagsInput = {
    update: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
    create: XOR<UserCreateWithoutTagsInput, UserUncheckedCreateWithoutTagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTagsInput, UserUncheckedUpdateWithoutTagsInput>
  }

  export type UserUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    azureContainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourses?: UserCourseUncheckedUpdateManyWithoutUserNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutUserNestedInput
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    userStats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
    UserSession?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationTagUpsertWithoutUsersInput = {
    update: XOR<OrganizationTagUpdateWithoutUsersInput, OrganizationTagUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationTagCreateWithoutUsersInput, OrganizationTagUncheckedCreateWithoutUsersInput>
    where?: OrganizationTagWhereInput
  }

  export type OrganizationTagUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationTagWhereInput
    data: XOR<OrganizationTagUpdateWithoutUsersInput, OrganizationTagUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationTagUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTagsNestedInput
    trainings?: TagTrainingUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trainings?: TagTrainingUncheckedUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagCreateWithoutTrainingsInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutTagsInput
    users?: UserTagCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagUncheckedCreateWithoutTrainingsInput = {
    id?: string
    organizationId: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type OrganizationTagCreateOrConnectWithoutTrainingsInput = {
    where: OrganizationTagWhereUniqueInput
    create: XOR<OrganizationTagCreateWithoutTrainingsInput, OrganizationTagUncheckedCreateWithoutTrainingsInput>
  }

  export type CourseCreateWithoutTagTrainingInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutTagTrainingInput = {
    id?: string
    courseId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    sourceType?: string | null
    sourceOrganizationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    userCourses?: UserCourseUncheckedCreateNestedManyWithoutCourseInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutCourseInput
    OrganizationTraining?: OrganizationTrainingUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutTagTrainingInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutTagTrainingInput, CourseUncheckedCreateWithoutTagTrainingInput>
  }

  export type OrganizationTagUpsertWithoutTrainingsInput = {
    update: XOR<OrganizationTagUpdateWithoutTrainingsInput, OrganizationTagUncheckedUpdateWithoutTrainingsInput>
    create: XOR<OrganizationTagCreateWithoutTrainingsInput, OrganizationTagUncheckedCreateWithoutTrainingsInput>
    where?: OrganizationTagWhereInput
  }

  export type OrganizationTagUpdateToOneWithWhereWithoutTrainingsInput = {
    where?: OrganizationTagWhereInput
    data: XOR<OrganizationTagUpdateWithoutTrainingsInput, OrganizationTagUncheckedUpdateWithoutTrainingsInput>
  }

  export type OrganizationTagUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTagsNestedInput
    users?: UserTagUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CourseUpsertWithoutTagTrainingInput = {
    update: XOR<CourseUpdateWithoutTagTrainingInput, CourseUncheckedUpdateWithoutTagTrainingInput>
    create: XOR<CourseCreateWithoutTagTrainingInput, CourseUncheckedCreateWithoutTagTrainingInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutTagTrainingInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutTagTrainingInput, CourseUncheckedUpdateWithoutTagTrainingInput>
  }

  export type CourseUpdateWithoutTagTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutTagTrainingInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    sourceType?: NullableStringFieldUpdateOperationsInput | string | null
    sourceOrganizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    userCourses?: UserCourseUncheckedUpdateManyWithoutCourseNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutCourseNestedInput
    OrganizationTraining?: OrganizationTrainingUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FormationCreateWithoutContentsInput = {
    id?: string
    formationId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationUncheckedCreateWithoutContentsInput = {
    id?: string
    formationId: string
    name: string
    description: string
    imageUrl?: string | null
    category: string
    difficulty: string
    duration: string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationCreateOrConnectWithoutContentsInput = {
    where: FormationWhereUniqueInput
    create: XOR<FormationCreateWithoutContentsInput, FormationUncheckedCreateWithoutContentsInput>
  }

  export type FormationStepCreateWithoutContentInput = {
    id?: string
    stepId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationStepUncheckedCreateWithoutContentInput = {
    id?: string
    stepId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationStepCreateOrConnectWithoutContentInput = {
    where: FormationStepWhereUniqueInput
    create: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput>
  }

  export type FormationStepCreateManyContentInputEnvelope = {
    data: FormationStepCreateManyContentInput | FormationStepCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type FormationQuestionCreateWithoutContentInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: FormationOptionCreateNestedManyWithoutQuestionInput
  }

  export type FormationQuestionUncheckedCreateWithoutContentInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: FormationOptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type FormationQuestionCreateOrConnectWithoutContentInput = {
    where: FormationQuestionWhereUniqueInput
    create: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput>
  }

  export type FormationQuestionCreateManyContentInputEnvelope = {
    data: FormationQuestionCreateManyContentInput | FormationQuestionCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type FormationUpsertWithoutContentsInput = {
    update: XOR<FormationUpdateWithoutContentsInput, FormationUncheckedUpdateWithoutContentsInput>
    create: XOR<FormationCreateWithoutContentsInput, FormationUncheckedCreateWithoutContentsInput>
    where?: FormationWhereInput
  }

  export type FormationUpdateToOneWithWhereWithoutContentsInput = {
    where?: FormationWhereInput
    data: XOR<FormationUpdateWithoutContentsInput, FormationUncheckedUpdateWithoutContentsInput>
  }

  export type FormationUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    objectMapping?: NullableJsonNullValueInput | InputJsonValue
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepUpsertWithWhereUniqueWithoutContentInput = {
    where: FormationStepWhereUniqueInput
    update: XOR<FormationStepUpdateWithoutContentInput, FormationStepUncheckedUpdateWithoutContentInput>
    create: XOR<FormationStepCreateWithoutContentInput, FormationStepUncheckedCreateWithoutContentInput>
  }

  export type FormationStepUpdateWithWhereUniqueWithoutContentInput = {
    where: FormationStepWhereUniqueInput
    data: XOR<FormationStepUpdateWithoutContentInput, FormationStepUncheckedUpdateWithoutContentInput>
  }

  export type FormationStepUpdateManyWithWhereWithoutContentInput = {
    where: FormationStepScalarWhereInput
    data: XOR<FormationStepUpdateManyMutationInput, FormationStepUncheckedUpdateManyWithoutContentInput>
  }

  export type FormationStepScalarWhereInput = {
    AND?: FormationStepScalarWhereInput | FormationStepScalarWhereInput[]
    OR?: FormationStepScalarWhereInput[]
    NOT?: FormationStepScalarWhereInput | FormationStepScalarWhereInput[]
    id?: StringFilter<"FormationStep"> | string
    stepId?: StringFilter<"FormationStep"> | string
    contentId?: StringFilter<"FormationStep"> | string
    title?: StringFilter<"FormationStep"> | string
    instruction?: StringFilter<"FormationStep"> | string
    validationEvent?: StringFilter<"FormationStep"> | string
    validationType?: StringFilter<"FormationStep"> | string
    hint?: StringNullableFilter<"FormationStep"> | string | null
    createdAt?: DateTimeFilter<"FormationStep"> | Date | string
    updatedAt?: DateTimeFilter<"FormationStep"> | Date | string
  }

  export type FormationQuestionUpsertWithWhereUniqueWithoutContentInput = {
    where: FormationQuestionWhereUniqueInput
    update: XOR<FormationQuestionUpdateWithoutContentInput, FormationQuestionUncheckedUpdateWithoutContentInput>
    create: XOR<FormationQuestionCreateWithoutContentInput, FormationQuestionUncheckedCreateWithoutContentInput>
  }

  export type FormationQuestionUpdateWithWhereUniqueWithoutContentInput = {
    where: FormationQuestionWhereUniqueInput
    data: XOR<FormationQuestionUpdateWithoutContentInput, FormationQuestionUncheckedUpdateWithoutContentInput>
  }

  export type FormationQuestionUpdateManyWithWhereWithoutContentInput = {
    where: FormationQuestionScalarWhereInput
    data: XOR<FormationQuestionUpdateManyMutationInput, FormationQuestionUncheckedUpdateManyWithoutContentInput>
  }

  export type FormationQuestionScalarWhereInput = {
    AND?: FormationQuestionScalarWhereInput | FormationQuestionScalarWhereInput[]
    OR?: FormationQuestionScalarWhereInput[]
    NOT?: FormationQuestionScalarWhereInput | FormationQuestionScalarWhereInput[]
    id?: StringFilter<"FormationQuestion"> | string
    questionId?: StringFilter<"FormationQuestion"> | string
    contentId?: StringFilter<"FormationQuestion"> | string
    text?: StringFilter<"FormationQuestion"> | string
    type?: StringFilter<"FormationQuestion"> | string
    image?: StringNullableFilter<"FormationQuestion"> | string | null
    createdAt?: DateTimeFilter<"FormationQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"FormationQuestion"> | Date | string
  }

  export type FormationContentCreateWithoutStepsInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formation: FormationCreateNestedOneWithoutContentsInput
    questions?: FormationQuestionCreateNestedManyWithoutContentInput
  }

  export type FormationContentUncheckedCreateWithoutStepsInput = {
    id?: string
    contentId: string
    formationId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: FormationQuestionUncheckedCreateNestedManyWithoutContentInput
  }

  export type FormationContentCreateOrConnectWithoutStepsInput = {
    where: FormationContentWhereUniqueInput
    create: XOR<FormationContentCreateWithoutStepsInput, FormationContentUncheckedCreateWithoutStepsInput>
  }

  export type FormationContentUpsertWithoutStepsInput = {
    update: XOR<FormationContentUpdateWithoutStepsInput, FormationContentUncheckedUpdateWithoutStepsInput>
    create: XOR<FormationContentCreateWithoutStepsInput, FormationContentUncheckedCreateWithoutStepsInput>
    where?: FormationContentWhereInput
  }

  export type FormationContentUpdateToOneWithWhereWithoutStepsInput = {
    where?: FormationContentWhereInput
    data: XOR<FormationContentUpdateWithoutStepsInput, FormationContentUncheckedUpdateWithoutStepsInput>
  }

  export type FormationContentUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formation?: FormationUpdateOneRequiredWithoutContentsNestedInput
    questions?: FormationQuestionUpdateManyWithoutContentNestedInput
  }

  export type FormationContentUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: FormationQuestionUncheckedUpdateManyWithoutContentNestedInput
  }

  export type FormationContentCreateWithoutQuestionsInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    formation: FormationCreateNestedOneWithoutContentsInput
    steps?: FormationStepCreateNestedManyWithoutContentInput
  }

  export type FormationContentUncheckedCreateWithoutQuestionsInput = {
    id?: string
    contentId: string
    formationId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: FormationStepUncheckedCreateNestedManyWithoutContentInput
  }

  export type FormationContentCreateOrConnectWithoutQuestionsInput = {
    where: FormationContentWhereUniqueInput
    create: XOR<FormationContentCreateWithoutQuestionsInput, FormationContentUncheckedCreateWithoutQuestionsInput>
  }

  export type FormationOptionCreateWithoutQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationOptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationOptionCreateOrConnectWithoutQuestionInput = {
    where: FormationOptionWhereUniqueInput
    create: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput>
  }

  export type FormationOptionCreateManyQuestionInputEnvelope = {
    data: FormationOptionCreateManyQuestionInput | FormationOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type FormationContentUpsertWithoutQuestionsInput = {
    update: XOR<FormationContentUpdateWithoutQuestionsInput, FormationContentUncheckedUpdateWithoutQuestionsInput>
    create: XOR<FormationContentCreateWithoutQuestionsInput, FormationContentUncheckedCreateWithoutQuestionsInput>
    where?: FormationContentWhereInput
  }

  export type FormationContentUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: FormationContentWhereInput
    data: XOR<FormationContentUpdateWithoutQuestionsInput, FormationContentUncheckedUpdateWithoutQuestionsInput>
  }

  export type FormationContentUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formation?: FormationUpdateOneRequiredWithoutContentsNestedInput
    steps?: FormationStepUpdateManyWithoutContentNestedInput
  }

  export type FormationContentUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    formationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: FormationStepUncheckedUpdateManyWithoutContentNestedInput
  }

  export type FormationOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: FormationOptionWhereUniqueInput
    update: XOR<FormationOptionUpdateWithoutQuestionInput, FormationOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<FormationOptionCreateWithoutQuestionInput, FormationOptionUncheckedCreateWithoutQuestionInput>
  }

  export type FormationOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: FormationOptionWhereUniqueInput
    data: XOR<FormationOptionUpdateWithoutQuestionInput, FormationOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type FormationOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: FormationOptionScalarWhereInput
    data: XOR<FormationOptionUpdateManyMutationInput, FormationOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type FormationOptionScalarWhereInput = {
    AND?: FormationOptionScalarWhereInput | FormationOptionScalarWhereInput[]
    OR?: FormationOptionScalarWhereInput[]
    NOT?: FormationOptionScalarWhereInput | FormationOptionScalarWhereInput[]
    id?: StringFilter<"FormationOption"> | string
    optionId?: StringFilter<"FormationOption"> | string
    questionId?: StringFilter<"FormationOption"> | string
    text?: StringFilter<"FormationOption"> | string
    isCorrect?: BoolFilter<"FormationOption"> | boolean
    createdAt?: DateTimeFilter<"FormationOption"> | Date | string
    updatedAt?: DateTimeFilter<"FormationOption"> | Date | string
  }

  export type FormationQuestionCreateWithoutOptionsInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content: FormationContentCreateNestedOneWithoutQuestionsInput
  }

  export type FormationQuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    questionId: string
    contentId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationQuestionCreateOrConnectWithoutOptionsInput = {
    where: FormationQuestionWhereUniqueInput
    create: XOR<FormationQuestionCreateWithoutOptionsInput, FormationQuestionUncheckedCreateWithoutOptionsInput>
  }

  export type FormationQuestionUpsertWithoutOptionsInput = {
    update: XOR<FormationQuestionUpdateWithoutOptionsInput, FormationQuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<FormationQuestionCreateWithoutOptionsInput, FormationQuestionUncheckedCreateWithoutOptionsInput>
    where?: FormationQuestionWhereInput
  }

  export type FormationQuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: FormationQuestionWhereInput
    data: XOR<FormationQuestionUpdateWithoutOptionsInput, FormationQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type FormationQuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: FormationContentUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type FormationQuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationContentCreateWithoutFormationInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: FormationStepCreateNestedManyWithoutContentInput
    questions?: FormationQuestionCreateNestedManyWithoutContentInput
  }

  export type FormationContentUncheckedCreateWithoutFormationInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: FormationStepUncheckedCreateNestedManyWithoutContentInput
    questions?: FormationQuestionUncheckedCreateNestedManyWithoutContentInput
  }

  export type FormationContentCreateOrConnectWithoutFormationInput = {
    where: FormationContentWhereUniqueInput
    create: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput>
  }

  export type FormationContentCreateManyFormationInputEnvelope = {
    data: FormationContentCreateManyFormationInput | FormationContentCreateManyFormationInput[]
    skipDuplicates?: boolean
  }

  export type FormationContentUpsertWithWhereUniqueWithoutFormationInput = {
    where: FormationContentWhereUniqueInput
    update: XOR<FormationContentUpdateWithoutFormationInput, FormationContentUncheckedUpdateWithoutFormationInput>
    create: XOR<FormationContentCreateWithoutFormationInput, FormationContentUncheckedCreateWithoutFormationInput>
  }

  export type FormationContentUpdateWithWhereUniqueWithoutFormationInput = {
    where: FormationContentWhereUniqueInput
    data: XOR<FormationContentUpdateWithoutFormationInput, FormationContentUncheckedUpdateWithoutFormationInput>
  }

  export type FormationContentUpdateManyWithWhereWithoutFormationInput = {
    where: FormationContentScalarWhereInput
    data: XOR<FormationContentUpdateManyMutationInput, FormationContentUncheckedUpdateManyWithoutFormationInput>
  }

  export type FormationContentScalarWhereInput = {
    AND?: FormationContentScalarWhereInput | FormationContentScalarWhereInput[]
    OR?: FormationContentScalarWhereInput[]
    NOT?: FormationContentScalarWhereInput | FormationContentScalarWhereInput[]
    id?: StringFilter<"FormationContent"> | string
    contentId?: StringFilter<"FormationContent"> | string
    formationId?: StringFilter<"FormationContent"> | string
    title?: StringFilter<"FormationContent"> | string
    description?: StringFilter<"FormationContent"> | string
    type?: StringFilter<"FormationContent"> | string
    order?: IntFilter<"FormationContent"> | number
    educationalTitle?: StringNullableFilter<"FormationContent"> | string | null
    educationalText?: StringNullableFilter<"FormationContent"> | string | null
    imageUrl?: StringNullableFilter<"FormationContent"> | string | null
    createdAt?: DateTimeFilter<"FormationContent"> | Date | string
    updatedAt?: DateTimeFilter<"FormationContent"> | Date | string
  }

  export type UserCourseCreateManyUserInput = {
    id?: string
    courseId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseCreateManyUserInput = {
    id?: string
    scenarioId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    courseId?: string | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberCreateManyUserInput = {
    id?: string
    organizationId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTagCreateManyUserInput = {
    id?: string
    tagId: string
    assignedAt?: Date | string
  }

  export type UserCourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutUserCoursesNestedInput
    userModules?: UserModuleUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userModules?: UserModuleUncheckedUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenario?: ScenarioUpdateOneRequiredWithoutUserResponsesNestedInput
  }

  export type UserResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: OrganizationTagUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserTagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateManyCourseInput = {
    id?: string
    moduleId: string
    title: string
    description: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCourseCreateManyCourseInput = {
    id?: string
    userId: string
    progress?: number
    lastAccessed?: Date | string
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyCourseInput = {
    id?: string
    userId: string
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    modulesViewed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingCreateManyCourseInput = {
    id?: string
    organizationId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagTrainingCreateManyCourseInput = {
    id?: string
    tagId: string
    assignedAt?: Date | string
  }

  export type ModuleUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: ScenarioUpdateManyWithoutModuleNestedInput
    userModules?: UserModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scenarios?: ScenarioUncheckedUpdateManyWithoutModuleNestedInput
    userModules?: UserModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserCoursesNestedInput
    userModules?: UserModuleUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userModules?: UserModuleUncheckedUpdateManyWithoutUserCourseNestedInput
  }

  export type UserCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSessionNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    modulesViewed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type OrganizationTrainingUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: OrganizationTagUpdateOneRequiredWithoutTrainingsNestedInput
  }

  export type TagTrainingUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleCreateManyUserCourseInput = {
    id?: string
    moduleId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleUpdateWithoutUserCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutUserModulesNestedInput
  }

  export type UserModuleUncheckedUpdateWithoutUserCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleUncheckedUpdateManyWithoutUserCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScenarioCreateManyModuleInput = {
    id?: string
    scenarioId: string
    title: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserModuleCreateManyModuleInput = {
    id?: string
    userCourseId: string
    completed?: boolean
    score?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScenarioUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutScenarioNestedInput
    userResponses?: UserResponseUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutScenarioNestedInput
    userResponses?: UserResponseUncheckedUpdateManyWithoutScenarioNestedInput
  }

  export type ScenarioUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    scenarioId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userCourse?: UserCourseUpdateOneRequiredWithoutUserModulesNestedInput
  }

  export type UserModuleUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userCourseId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserModuleUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userCourseId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyScenarioInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    explanation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserResponseCreateManyScenarioInput = {
    id?: string
    userId: string
    questionId: string
    selectedAnswers?: UserResponseCreateselectedAnswersInput | string[]
    isCorrect: boolean
    score: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserResponsesNestedInput
  }

  export type UserResponseUncheckedUpdateWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserResponseUncheckedUpdateManyWithoutScenarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedAnswers?: UserResponseUpdateselectedAnswersInput | string[]
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateManyQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
    data?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role: string
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTrainingCreateManyOrganizationInput = {
    id?: string
    courseId: string
    buildId?: string | null
    isCustomBuild?: boolean
    isActive?: boolean
    assignedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationInvitationCreateManyOrganizationInput = {
    id?: string
    email: string
    inviteCode: string
    role?: string
    status?: string
    invitedBy: string
    invitedAt?: Date | string
    expiresAt: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationTagCreateManyOrganizationInput = {
    id?: string
    name: string
    color?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOrganizationTrainingNestedInput
  }

  export type OrganizationTrainingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTrainingUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    buildId?: NullableStringFieldUpdateOperationsInput | string | null
    isCustomBuild?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    inviteCode?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationTagUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserTagUpdateManyWithoutTagNestedInput
    trainings?: TagTrainingUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserTagUncheckedUpdateManyWithoutTagNestedInput
    trainings?: TagTrainingUncheckedUpdateManyWithoutTagNestedInput
  }

  export type OrganizationTagUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagCreateManyTagInput = {
    id?: string
    userId: string
    assignedAt?: Date | string
  }

  export type TagTrainingCreateManyTagInput = {
    id?: string
    courseId: string
    assignedAt?: Date | string
  }

  export type UserTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTagsNestedInput
  }

  export type UserTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutTagTrainingNestedInput
  }

  export type TagTrainingUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagTrainingUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepCreateManyContentInput = {
    id?: string
    stepId: string
    title: string
    instruction: string
    validationEvent: string
    validationType?: string
    hint?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationQuestionCreateManyContentInput = {
    id?: string
    questionId: string
    text: string
    type?: string
    image?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationStepUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationStepUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instruction?: StringFieldUpdateOperationsInput | string
    validationEvent?: StringFieldUpdateOperationsInput | string
    validationType?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationQuestionUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: FormationOptionUpdateManyWithoutQuestionNestedInput
  }

  export type FormationQuestionUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: FormationOptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type FormationQuestionUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionCreateManyQuestionInput = {
    id?: string
    optionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationOptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    optionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormationContentCreateManyFormationInput = {
    id?: string
    contentId: string
    title: string
    description: string
    type?: string
    order: number
    educationalTitle?: string | null
    educationalText?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormationContentUpdateWithoutFormationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: FormationStepUpdateManyWithoutContentNestedInput
    questions?: FormationQuestionUpdateManyWithoutContentNestedInput
  }

  export type FormationContentUncheckedUpdateWithoutFormationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: FormationStepUncheckedUpdateManyWithoutContentNestedInput
    questions?: FormationQuestionUncheckedUpdateManyWithoutContentNestedInput
  }

  export type FormationContentUncheckedUpdateManyWithoutFormationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    educationalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    educationalText?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}